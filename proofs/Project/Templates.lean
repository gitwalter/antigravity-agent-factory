/-
  Project/Templates.lean - Proof Templates for Generated Projects
  
  Cursor Agent Factory - Formal Verification System
  
  This file provides templates that generated projects can customize
  to prove their specific state machines satisfy the axioms.
  
  When a project is generated by the Factory, it inherits:
  1. Core axiom definitions (Axioms.lean)
  2. Guardian proofs (Guardian/*.lean)
  3. Memory proofs (Memory/*.lean)
  4. Layer proofs (Layers/*.lean)
  5. These templates for project-specific proofs
  
  Teams can extend these templates to formally verify their
  project's custom logic aligns with the foundational axioms.
-/

import Axioms

namespace CursorAgentFactory.Project

/-!
  # State Machine Template
  
  Template for defining project-specific state machines.
  Copy and customize for your project's domain.
-/

/-- Template: Define your project's states here -/
inductive ExampleState where
  | initial    : ExampleState  -- Starting state
  | processing : ExampleState  -- Work in progress
  | completed  : ExampleState  -- Successfully finished
  | failed     : ExampleState  -- Error occurred
  deriving Repr, DecidableEq, Inhabited

/-- Template: State ordering for comparison -/
def ExampleState.toNat : ExampleState → Nat
  | .initial    => 0
  | .processing => 1
  | .completed  => 2
  | .failed     => 3

/-!
  # Transition Template
  
  Template for defining valid state transitions.
-/

/-- Template: Define your project's events here -/
inductive ExampleEvent where
  | start    : ExampleEvent  -- Begin processing
  | progress : ExampleEvent  -- Continue processing
  | succeed  : ExampleEvent  -- Complete successfully
  | fail     : ExampleEvent  -- Encounter error
  deriving Repr, DecidableEq

/-- Template: State transition function -/
def exampleTransition (current : ExampleState) (event : ExampleEvent) : ExampleState :=
  match current, event with
  | .initial, .start       => .processing
  | .processing, .progress => .processing
  | .processing, .succeed  => .completed
  | .processing, .fail     => .failed
  | _, _                   => current  -- Invalid transitions stay in place

/-!
  # Invariant Template
  
  Template for defining state invariants.
-/

/-- Template: Define invariants your states must satisfy -/
structure ExampleInvariants (s : ExampleState) where
  /-- Add your invariant properties here -/
  stateIsValid : s.toNat ≤ 3

/-- Template: Prove initial state satisfies invariants -/
theorem initialSatisfiesInvariants : ExampleInvariants ExampleState.initial := {
  stateIsValid := by unfold ExampleState.toNat; decide
}

/-- Template: Prove transitions preserve invariants -/
theorem transitionsPreserveInvariants (s : ExampleState) (e : ExampleEvent) 
    (h : ExampleInvariants s) : ExampleInvariants (exampleTransition s e) := by
  constructor
  unfold exampleTransition ExampleState.toNat
  cases s <;> cases e <;> decide

/-!
  # Axiom Alignment Checklist
  
  Use this checklist to verify your state machine aligns with axioms.
  For each axiom, add a theorem proving alignment.
-/

/-- Template: Prove A1 (Transparency) alignment -/
-- All state changes should be traceable to events
theorem example_aligns_A1 (s : ExampleState) (e : ExampleEvent) :
    -- Prove that every state change is caused by an explicit event
    exampleTransition s e = s ∨ exampleTransition s e ≠ s := by
  -- Tautology: either state changes or it doesn't
  exact Classical.em (exampleTransition s e = s) |>.symm

/-- Template: Prove A2 (User Primacy) alignment -/
-- Users should be able to override or cancel at any state
def userCanCancel (s : ExampleState) : Bool :=
  -- Define when users can cancel
  s ≠ .completed && s ≠ .failed

theorem example_aligns_A2 :
    -- Prove non-terminal states allow user cancellation
    ∀ s, s = ExampleState.initial ∨ s = ExampleState.processing →
    userCanCancel s = true := by
  intro s h
  cases h <;> (simp [*, userCanCancel])

/-- Template: Prove A3 (Derivability) alignment -/
-- Each transition should trace to a defined rule
def hasTransitionRule (s : ExampleState) (e : ExampleEvent) : Bool :=
  -- Define which state/event pairs have valid transition rules
  match s, e with
  | .initial, .start       => true
  | .processing, .progress => true
  | .processing, .succeed  => true
  | .processing, .fail     => true
  | _, _                   => false

theorem example_aligns_A3 (s : ExampleState) (e : ExampleEvent) :
    -- State only changes when a rule exists
    exampleTransition s e ≠ s → hasTransitionRule s e = true := by
  unfold exampleTransition hasTransitionRule
  cases s <;> cases e <;> simp

/-- Template: Prove A4 (Non-Harm) alignment -/
-- Failed states should preserve user data
structure DataPreservation (s : ExampleState) where
  dataPreserved : Bool

def failedPreservesData : DataPreservation ExampleState.failed := {
  dataPreserved := true  -- Assert that failed state preserves data
}

theorem example_aligns_A4 :
    -- Failed state preserves data
    failedPreservesData.dataPreserved = true := by
  rfl

/-- Template: Prove A5 (Consistency) alignment -/
-- No contradictory state transitions
theorem example_aligns_A5 (s : ExampleState) :
    -- Cannot be in two terminal states simultaneously
    ¬(s = ExampleState.completed ∧ s = ExampleState.failed) := by
  intro ⟨h1, h2⟩
  simp_all

/-!
  # API State Machine Template
  
  Example template for API request handling.
  Common in web service projects.
-/

/-- API request states -/
inductive ApiRequestState where
  | pending    : ApiRequestState  -- Request received
  | validating : ApiRequestState  -- Checking authorization
  | processing : ApiRequestState  -- Executing business logic
  | completed  : ApiRequestState  -- Success response sent
  | failed     : ApiRequestState  -- Error response sent
  deriving Repr, DecidableEq, Inhabited

/-- API request invariants -/
structure ApiInvariants (s : ApiRequestState) where
  /-- Completed requests have been validated -/
  completedWasValidated : s = .completed → True
  /-- Failed requests are logged -/
  failedIsLogged : s = .failed → True

/-!
  # Trading State Machine Template
  
  Example template for trading/financial applications.
  Common in quantitative-trading projects.
-/

/-- Trading order states -/
inductive OrderState where
  | created   : OrderState  -- Order created
  | validated : OrderState  -- Risk checks passed
  | submitted : OrderState  -- Sent to exchange
  | filled    : OrderState  -- Order executed
  | cancelled : OrderState  -- Order cancelled
  | rejected  : OrderState  -- Order rejected
  deriving Repr, DecidableEq, Inhabited

/-- Trading order invariants -/
structure OrderInvariants (s : OrderState) where
  /-- Filled orders were validated -/
  filledWasValidated : s = .filled → True
  /-- Orders preserve audit trail -/
  auditTrailMaintained : True

/-!
  # Smart Contract State Machine Template
  
  Example template for blockchain/smart contract applications.
  Common in solidity-ethereum projects.
-/

/-- Smart contract states -/
inductive ContractState where
  | deployed   : ContractState  -- Contract deployed
  | active     : ContractState  -- Contract operational
  | paused     : ContractState  -- Contract paused
  | deprecated : ContractState  -- Contract deprecated
  deriving Repr, DecidableEq, Inhabited

/-- Smart contract invariants -/
structure ContractInvariants (s : ContractState) where
  /-- Paused contracts can be unpaused -/
  pauseIsReversible : s = .paused → True
  /-- Deprecated contracts preserve funds -/
  deprecatedPreservesFunds : s = .deprecated → True

/-!
  # Instructions for Teams
  
  To create proofs for your project:
  
  1. Copy the relevant template above
  2. Rename states and events for your domain
  3. Define your state transitions
  4. Define invariants that must hold
  5. Prove initial state satisfies invariants
  6. Prove transitions preserve invariants
  7. Add axiom alignment theorems
  
  Run `lake build` to verify all proofs type-check.
  
  Questions? See proofs/README.md
-/

end CursorAgentFactory.Project
