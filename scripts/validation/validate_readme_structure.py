#!/usr/bin/env python3
"""
README Structure Validator

Generated by Cursor Agent Factory

Validates that the project structure documented in README.md accurately reflects
the actual filesystem structure. Supports check, generate, and update modes.

Usage:
    python scripts/validation/validate_readme_structure.py --check
    python scripts/validation/validate_readme_structure.py --generate
    python scripts/validation/validate_readme_structure.py --update
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


# Customize SCAN_CONFIG for your project layout
SCAN_CONFIG = {
    "agents": {
        "dir": ".agent/agents",
        "pattern": "*.md",
        "readme_pattern": r"\((\d+)(\+)? agents?\)"
    },
    "skills": {
        "dir": ".agent/skills",
        "count_method": "subdirs_with_file",
        "sentinel": "SKILL.md",
        "readme_pattern": r"\((\d+)(\+)? skills?\)"
    },
    "blueprints": {
        "dir": "blueprints",
        "count_method": "subdirs_with_file",
        "sentinel": "blueprint.json",
        "readme_pattern": r"\((\d+)(\+)? blueprints?\)"
    },
    "knowledge": {
        "dir": "knowledge",
        "pattern": "*.json",
        "readme_pattern": r"\((\d+)(\+)? (?:JSON )?files?\)"
    },
    "patterns": {
        "dir": "patterns",
        "pattern": "*.json",
        "recursive": True,
        "readme_pattern": r"\((\d+)(\+)? patterns?\)"
    },
    "templates": {
        "dir": "templates",
        "pattern": "*.tmpl",
        "recursive": True,
        "readme_pattern": r"\((\d+)(\+)? templates?\)"
    },
    "tests": {
        "dir": "tests",
        "pattern": "test_*.py",
        "readme_pattern": r"\((\d+)(\+)? tests?\)",
        "recursive": True
    },
}


class StructureValidator:
    """
    Validates README.md structure documentation against actual filesystem.
    
    Scans configured directories and compares counts against patterns
    found in README.md.
    """
    
    def __init__(self, root_dir: Path, readme_path: Optional[Path] = None, scan_config: Optional[Dict] = None):
        """
        Initialize validator.
        
        Args:
            root_dir: Project root directory
            readme_path: Path to README.md
            scan_config: Configuration dict for scanning sections
        """
        self.root_dir = root_dir.resolve()
        self.readme_path = (readme_path or (root_dir / "README.md")).resolve()
        self.scan_config = scan_config or SCAN_CONFIG
        
    def scan_section(self, section_name: str, config: Dict) -> int:
        """
        Scan a single section and return count.
        
        Args:
            section_name: Name of the section
            config: Configuration for this section
            
        Returns:
            Count of items found
        """
        section_dir = self.root_dir / config["dir"]
        
        if not section_dir.exists():
            return 0
            
        if config.get("count_method") == "subdirs_with_file":
            # Count subdirectories containing the sentinel file
            sentinel = config.get("sentinel", "SKILL.md")
            count = 0
            for item in section_dir.iterdir():
                if item.is_dir():
                    if (item / sentinel).exists():
                        count += 1
            return count
        
        # Default: count files matching pattern
        pattern = config.get("pattern", "*")
        recursive = config.get("recursive", False)
        
        if recursive:
            count = len(list(section_dir.rglob(pattern)))
        else:
            count = len(list(section_dir.glob(pattern)))
            
        return count
    
    def scan_all(self) -> Dict[str, int]:
        """
        Scan all configured sections.
        
        Returns:
            Dict mapping section names to actual counts
        """
        results = {}
        for section_name, config in self.scan_config.items():
            results[section_name] = self.scan_section(section_name, config)
        return results
        
    def generate_counts_summary(self) -> Dict[str, int]:
        """
        Generate a summary of all counts.
        
        Returns:
            Dict mapping section names to actual counts
        """
        return self.scan_all()

    def _round_to_threshold(self, count: int) -> int:
        """
        Round count down to nearest threshold (5, 10, 25, 50, 100, etc.).
        
        Args:
            count: Number to round
            
        Returns:
            Rounded number
        """
        if count < 5: return count
        if count < 10: return 5
        if count < 25: return 10
        if count < 50: return 25
        if count < 100: return 50
        if count < 500: return 100 * (count // 100)
        return 500 * (count // 500)

    def extract_readme_counts(self) -> Dict[str, Dict[str, Any]]:
        """
        Extract expected counts from README.md using configured patterns.
        
        Returns:
            Dict mapping section names to results info (count and is_threshold)
        """
        if not self.readme_path.exists():
            return {}
            
        content = self.readme_path.read_text(encoding="utf-8")
        results = {}
        
        for section_name, config in self.scan_config.items():
            pattern = config.get("readme_pattern")
            if not pattern:
                results[section_name] = {"count": 0, "is_threshold": False, "found": False}
                continue
                
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                results[section_name] = {
                    "count": int(match.group(1)),
                    "is_threshold": match.group(2) == "+",
                    "found": True
                }
            else:
                results[section_name] = {"count": 0, "is_threshold": False, "found": False}
                
        return results
    
    def validate(self) -> Tuple[bool, List[str]]:
        """
        Validate structure against README.md.
        
        Returns:
            Tuple of (is_valid, list_of_messages)
        """
        is_valid = True
        messages = []
        
        actual_counts = self.scan_all()
        expected_info = self.extract_readme_counts()
        
        for section, info in expected_info.items():
            actual = actual_counts.get(section, 0)
            
            if not info["found"]:
                messages.append(f"⚠️  Section '{section}' count not found in README.md")
                # Don't fail the build for a missing section count in README, just warning
                continue
            
            expected = info["count"]
            is_threshold = info["is_threshold"]
                
            if is_threshold:
                if actual < expected:
                    messages.append(f"❌ '{section}' counts below minimum threshold: actual {actual} < expected {expected}+")
                    is_valid = False
                else:
                    messages.append(f"✅ '{section}': {actual} (matches README.md threshold {expected}+)")
            else:
                if actual != expected:
                    messages.append(f"❌ '{section}' counts mismatch: actual {actual} vs README {expected}")
                    is_valid = False
                else:
                    messages.append(f"✅ '{section}': {actual} (matches README.md)")
                
        return is_valid, messages
    
    def update_readme(self) -> bool:
        """
        Update README.md with current counts.
        
        Returns:
            True if updated, False if no changes needed
        """
        if not self.readme_path.exists():
            return False
            
        content = self.readme_path.read_text(encoding="utf-8")
        actual_counts = self.scan_all()
        updated_content = content
        
        for section_name, config in self.scan_config.items():
            pattern = config.get("readme_pattern")
            if not pattern:
                continue
                
            actual = actual_counts.get(section_name, 0)
            
            # Replace pattern match with new count
            def replacer(match):
                # Preserve the format but update the number
                prefix = match.group(0)[:match.start(1) - match.start(0)]
                suffix = match.group(0)[match.end(1) - match.start(0):]
                return f"{prefix}{actual}{suffix}"
            
            updated_content = re.sub(pattern, replacer, updated_content, flags=re.IGNORECASE)
            
        if updated_content != content:
            self.readme_path.write_text(updated_content, encoding="utf-8")
            return True
        return False
    
    def generate_structure_markdown(self) -> str:
        """
        Generate markdown documentation of current structure.
        
        Returns:
            Markdown string
        """
        actual_counts = self.scan_all()
        lines = ["# Project Structure", ""]
        
        for section_name, config in self.scan_config.items():
            count = actual_counts.get(section_name, 0)
            dir_path = config.get("dir", "")
            lines.append(f"- **{section_name.title()}**: {count} ({dir_path})")
            
        return "\n".join(lines)


def main():
    """Main entry point."""
    if sys.platform == 'win32':
        sys.stdout.reconfigure(encoding='utf-8')

    parser = argparse.ArgumentParser(
        description="Validate README.md structure documentation"
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check structure and exit with code 1 if mismatched"
    )
    parser.add_argument(
        "--generate",
        action="store_true",
        help="Generate markdown documentation of current structure"
    )
    parser.add_argument(
        "--update",
        action="store_true",
        help="Update README.md with current counts"
    )
    parser.add_argument(
        "--root",
        type=str,
        default=".",
        help="Project root directory (default: current directory)"
    )
    parser.add_argument(
        "--readme",
        type=str,
        default="README.md",
        help="Path to README.md (default: README.md)"
    )
    
    args = parser.parse_args()
    
    root_dir = Path(args.root).resolve()
    readme_path = root_dir / args.readme
    
    validator = StructureValidator(root_dir, readme_path, SCAN_CONFIG)
    
    if args.generate:
        print(validator.generate_structure_markdown())
        return 0
        
    if args.update:
        if validator.update_readme():
            print("✅ Updated README.md with current structure counts")
            return 0
        else:
            print("ℹ️  README.md already up to date")
            return 0
            
    # Default: check mode
    is_valid, messages = validator.validate()
    
    for msg in messages:
        print(msg)
        
    if not is_valid:
        print("\n❌ Structure validation failed. Run with --update to fix.")
        return 1
        
    print("\n✅ All structure counts match README.md")
    return 0


if __name__ == "__main__":
    sys.exit(main())
