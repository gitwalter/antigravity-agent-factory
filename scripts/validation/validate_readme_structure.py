#!/usr/bin/env python3
"""
README Structure Validator

Generated by Cursor Agent Factory

Validates that the project structure documented in README.md accurately reflects
the actual filesystem structure. Supports check, generate, and update modes.

Usage:
    python scripts/validation/validate_readme_structure.py --check
    python scripts/validation/validate_readme_structure.py --generate
    python scripts/validation/validate_readme_structure.py --update
"""

import argparse
import json
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple


# Customize SCAN_CONFIG for your project layout
SCAN_CONFIG = {
    "agents": {
        "dir": ".cursor/agents",
        "pattern": "*.md",
        "readme_pattern": r"\((\d+) agents?\)"
    },
    "skills": {
        "dir": ".cursor/skills",
        "count_method": "subdirs_with_file",
        "sentinel": "SKILL.md",
        "readme_pattern": r"\((\d+) skills?\)"
    },
    "knowledge": {
        "dir": "knowledge",
        "pattern": "*.json",
        "readme_pattern": r"\((\d+) (?:JSON )?files?\)"
    },
    "tests": {
        "dir": "tests",
        "pattern": "test_*.py",
        "readme_pattern": r"\((\d+) tests?\)",
        "recursive": True
    },
}


class StructureValidator:
    """
    Validates README.md structure documentation against actual filesystem.
    
    Scans configured directories and compares counts against patterns
    found in README.md.
    """
    
    def __init__(self, root_dir: Path, readme_path: Path, scan_config: Dict):
        """
        Initialize validator.
        
        Args:
            root_dir: Project root directory
            readme_path: Path to README.md
            scan_config: Configuration dict for scanning sections
        """
        self.root_dir = root_dir.resolve()
        self.readme_path = readme_path.resolve()
        self.scan_config = scan_config
        
    def scan_section(self, section_name: str, config: Dict) -> int:
        """
        Scan a single section and return count.
        
        Args:
            section_name: Name of the section
            config: Configuration for this section
            
        Returns:
            Count of items found
        """
        section_dir = self.root_dir / config["dir"]
        
        if not section_dir.exists():
            return 0
            
        if config.get("count_method") == "subdirs_with_file":
            # Count subdirectories containing the sentinel file
            sentinel = config.get("sentinel", "SKILL.md")
            count = 0
            for item in section_dir.iterdir():
                if item.is_dir():
                    if (item / sentinel).exists():
                        count += 1
            return count
        
        # Default: count files matching pattern
        pattern = config.get("pattern", "*")
        recursive = config.get("recursive", False)
        
        if recursive:
            count = len(list(section_dir.rglob(pattern)))
        else:
            count = len(list(section_dir.glob(pattern)))
            
        return count
    
    def scan_all(self) -> Dict[str, int]:
        """
        Scan all configured sections.
        
        Returns:
            Dict mapping section names to counts
        """
        results = {}
        for section_name, config in self.scan_config.items():
            results[section_name] = self.scan_section(section_name, config)
        return results
    
    def extract_readme_counts(self) -> Dict[str, Optional[int]]:
        """
        Extract expected counts from README.md using configured patterns.
        
        Returns:
            Dict mapping section names to expected counts (None if not found)
        """
        if not self.readme_path.exists():
            return {}
            
        content = self.readme_path.read_text(encoding="utf-8")
        results = {}
        
        for section_name, config in self.scan_config.items():
            pattern = config.get("readme_pattern")
            if not pattern:
                results[section_name] = None
                continue
                
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                results[section_name] = int(match.group(1))
            else:
                results[section_name] = None
                
        return results
    
    def validate(self) -> Tuple[bool, List[str]]:
        """
        Validate structure against README.md.
        
        Returns:
            Tuple of (is_valid, list_of_messages)
        """
        actual_counts = self.scan_all()
        expected_counts = self.extract_readme_counts()
        
        messages = []
        is_valid = True
        
        for section_name in self.scan_config.keys():
            actual = actual_counts.get(section_name, 0)
            expected = expected_counts.get(section_name)
            
            if expected is None:
                messages.append(
                    f"⚠️  {section_name}: Found {actual}, but no pattern match in README.md"
                )
            elif actual != expected:
                is_valid = False
                messages.append(
                    f"❌ {section_name}: Expected {expected}, found {actual}"
                )
            else:
                messages.append(
                    f"✅ {section_name}: {actual} (matches README.md)"
                )
                
        return is_valid, messages
    
    def update_readme(self) -> bool:
        """
        Update README.md with current counts.
        
        Returns:
            True if updated, False if no changes needed
        """
        if not self.readme_path.exists():
            return False
            
        content = self.readme_path.read_text(encoding="utf-8")
        actual_counts = self.scan_all()
        updated_content = content
        
        for section_name, config in self.scan_config.items():
            pattern = config.get("readme_pattern")
            if not pattern:
                continue
                
            actual = actual_counts.get(section_name, 0)
            
            # Replace pattern match with new count
            def replacer(match):
                # Preserve the format but update the number
                prefix = match.group(0)[:match.start(1) - match.start(0)]
                suffix = match.group(0)[match.end(1) - match.start(0):]
                return f"{prefix}{actual}{suffix}"
            
            updated_content = re.sub(pattern, replacer, updated_content, flags=re.IGNORECASE)
            
        if updated_content != content:
            self.readme_path.write_text(updated_content, encoding="utf-8")
            return True
        return False
    
    def generate_markdown(self) -> str:
        """
        Generate markdown documentation of current structure.
        
        Returns:
            Markdown string
        """
        actual_counts = self.scan_all()
        lines = ["# Project Structure", ""]
        
        for section_name, config in self.scan_config.items():
            count = actual_counts.get(section_name, 0)
            dir_path = config.get("dir", "")
            lines.append(f"- **{section_name.title()}**: {count} ({dir_path})")
            
        return "\n".join(lines)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Validate README.md structure documentation"
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check structure and exit with code 1 if mismatched"
    )
    parser.add_argument(
        "--generate",
        action="store_true",
        help="Generate markdown documentation of current structure"
    )
    parser.add_argument(
        "--update",
        action="store_true",
        help="Update README.md with current counts"
    )
    parser.add_argument(
        "--root",
        type=str,
        default=".",
        help="Project root directory (default: current directory)"
    )
    parser.add_argument(
        "--readme",
        type=str,
        default="README.md",
        help="Path to README.md (default: README.md)"
    )
    
    args = parser.parse_args()
    
    root_dir = Path(args.root).resolve()
    readme_path = root_dir / args.readme
    
    validator = StructureValidator(root_dir, readme_path, SCAN_CONFIG)
    
    if args.generate:
        print(validator.generate_markdown())
        return 0
        
    if args.update:
        if validator.update_readme():
            print("✅ Updated README.md with current structure counts")
            return 0
        else:
            print("ℹ️  README.md already up to date")
            return 0
            
    # Default: check mode
    is_valid, messages = validator.validate()
    
    for msg in messages:
        print(msg)
        
    if not is_valid:
        print("\n❌ Structure validation failed. Run with --update to fix.")
        return 1
        
    print("\n✅ All structure counts match README.md")
    return 0


if __name__ == "__main__":
    sys.exit(main())
