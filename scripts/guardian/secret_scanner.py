#!/usr/bin/env python3
"""
Secret Scanner

Generated by Cursor Agent Factory

Scans files for common secret patterns like API keys, tokens, and private keys.
Designed for pre-commit hooks and CI/CD pipelines.

Usage:
    python scripts/guardian/secret_scanner.py --scan
    python scripts/guardian/secret_scanner.py --check
"""

import argparse
import re
import sys
from pathlib import Path
from typing import Dict, List, Tuple


# Secret patterns to detect
SECRET_PATTERNS = {
    "aws_access_key": {
        "pattern": r"AKIA[0-9A-Z]{16}",
        "description": "AWS Access Key ID"
    },
    "aws_secret_key": {
        "pattern": r"(?i)(aws[_-]?secret[_-]?access[_-]?key|aws[_-]?secret[_-]?key)\s*[=:]\s*['\"]?([A-Za-z0-9/+=]{40})['\"]?",
        "description": "AWS Secret Access Key"
    },
    "openai_key": {
        "pattern": r"sk-[A-Za-z0-9]{32,}",
        "description": "OpenAI API Key"
    },
    "github_token": {
        "pattern": r"ghp_[A-Za-z0-9]{36}",
        "description": "GitHub Personal Access Token"
    },
    "github_oauth": {
        "pattern": r"gho_[A-Za-z0-9]{36}",
        "description": "GitHub OAuth Token"
    },
    "private_key": {
        "pattern": r"-----BEGIN (?:RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----",
        "description": "Private Key"
    },
    "mongodb_uri": {
        "pattern": r"mongodb\+srv://[^\s]+",
        "description": "MongoDB Connection String"
    },
    "postgres_uri": {
        "pattern": r"postgres(ql)?://[^\s]+",
        "description": "PostgreSQL Connection String"
    },
    "mysql_uri": {
        "pattern": r"mysql://[^\s]+",
        "description": "MySQL Connection String"
    },
    "redis_uri": {
        "pattern": r"redis://[^\s]+",
        "description": "Redis Connection String"
    },
    "slack_token": {
        "pattern": r"xox[baprs]-[0-9a-zA-Z-]{10,}",
        "description": "Slack Token"
    },
    "stripe_key": {
        "pattern": r"sk_live_[0-9a-zA-Z]{24,}",
        "description": "Stripe Secret Key"
    },
    "jwt_secret": {
        "pattern": r"(?i)(jwt[_-]?secret|jwt[_-]?key)\s*[=:]\s*['\"]?([A-Za-z0-9+/=]{32,})['\"]?",
        "description": "JWT Secret"
    },
}

# Default exclude patterns
DEFAULT_EXCLUDE_PATTERNS = [
    r".*\.pyc$",
    r".*__pycache__.*",
    r".*\.git.*",
    r".*node_modules.*",
    r".*\.venv.*",
    r".*venv.*",
    r".*\.env\.example$",
    r".*secret_scanner\.py$",  # Exclude this script itself
    r".*test.*secret.*",  # Exclude test files with "secret" in name
]


class SecretScanner:
    """
    Scans files for secret patterns.
    
    Supports configurable patterns, exclude rules, and multiple
    output modes for CI/CD integration.
    """
    
    def __init__(
        self,
        root_dir: Path,
        exclude_patterns: List[str] = None,
        custom_patterns: Dict = None
    ):
        """
        Initialize scanner.
        
        Args:
            root_dir: Root directory to scan
            exclude_patterns: List of regex patterns for files to exclude
            custom_patterns: Additional secret patterns to check
        """
        self.root_dir = root_dir.resolve()
        self.exclude_patterns = exclude_patterns or DEFAULT_EXCLUDE_PATTERNS.copy()
        self.patterns = SECRET_PATTERNS.copy()
        if custom_patterns:
            self.patterns.update(custom_patterns)
    
    def should_exclude(self, file_path: Path) -> bool:
        """
        Check if file should be excluded from scanning.
        
        Args:
            file_path: Path to check
            
        Returns:
            True if file should be excluded
        """
        path_str = str(file_path)
        for pattern in self.exclude_patterns:
            if re.search(pattern, path_str):
                return True
        return False
    
    def scan_file(self, file_path: Path) -> List[Tuple[str, str, int]]:
        """
        Scan a single file for secrets.
        
        Args:
            file_path: Path to file
            
        Returns:
            List of tuples: (pattern_name, matched_text, line_number)
        """
        if self.should_exclude(file_path):
            return []
        
        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")
        except Exception:
            return []
        
        findings = []
        lines = content.splitlines()
        
        for line_num, line in enumerate(lines, 1):
            for pattern_name, pattern_info in self.patterns.items():
                pattern = pattern_info["pattern"]
                matches = re.finditer(pattern, line, re.IGNORECASE)
                for match in matches:
                    matched_text = match.group(0)
                    # Mask sensitive parts
                    if len(matched_text) > 20:
                        masked = matched_text[:8] + "..." + matched_text[-4:]
                    else:
                        masked = matched_text[:4] + "..."
                    findings.append((pattern_name, masked, line_num))
        
        return findings
    
    def scan_directory(self) -> Dict[Path, List[Tuple[str, str, int]]]:
        """
        Scan entire directory recursively.
        
        Returns:
            Dict mapping file paths to lists of findings
        """
        results = {}
        
        # Find all files
        for file_path in self.root_dir.rglob("*"):
            if file_path.is_file():
                findings = self.scan_file(file_path)
                if findings:
                    results[file_path] = findings
                    
        return results
    
    def format_findings(self, results: Dict[Path, List[Tuple[str, str, int]]]) -> str:
        """
        Format findings for output.
        
        Args:
            results: Dict of findings
            
        Returns:
            Formatted string
        """
        if not results:
            return "‚úÖ No secrets found"
        
        lines = ["‚ùå Potential secrets found:\n"]
        
        for file_path, findings in sorted(results.items()):
            rel_path = file_path.relative_to(self.root_dir)
            lines.append(f"üìÑ {rel_path}")
            
            # Group by pattern type
            by_pattern = {}
            for pattern_name, masked_text, line_num in findings:
                if pattern_name not in by_pattern:
                    by_pattern[pattern_name] = []
                by_pattern[pattern_name].append((masked_text, line_num))
            
            for pattern_name, matches in sorted(by_pattern.items()):
                pattern_desc = self.patterns[pattern_name]["description"]
                lines.append(f"   ‚ö†Ô∏è  {pattern_desc} ({pattern_name})")
                for masked_text, line_num in matches:
                    lines.append(f"      Line {line_num}: {masked_text}")
            
            lines.append("")
        
        return "\n".join(lines)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Scan files for secret patterns"
    )
    parser.add_argument(
        "--scan",
        action="store_true",
        help="Scan and report findings"
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check mode: exit with code 1 if secrets found"
    )
    parser.add_argument(
        "--root",
        type=str,
        default=".",
        help="Root directory to scan (default: current directory)"
    )
    parser.add_argument(
        "--exclude",
        type=str,
        action="append",
        help="Additional exclude patterns (can be used multiple times)"
    )
    
    args = parser.parse_args()
    
    root_dir = Path(args.root).resolve()
    
    exclude_patterns = DEFAULT_EXCLUDE_PATTERNS.copy()
    if args.exclude:
        exclude_patterns.extend(args.exclude)
    
    scanner = SecretScanner(root_dir, exclude_patterns=exclude_patterns)
    results = scanner.scan_directory()
    
    output = scanner.format_findings(results)
    print(output)
    
    if args.check or args.scan:
        if results:
            if args.check:
                print("\n‚ùå Secret scan failed. Commit blocked.")
            return 1
        else:
            if args.check:
                print("\n‚úÖ Secret scan passed")
            return 0
    
    # Default: just scan
    return 0 if not results else 1


if __name__ == "__main__":
    sys.exit(main())
