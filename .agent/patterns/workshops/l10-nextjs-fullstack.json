{
  "$schema": "../learning-workshop-pattern.json",
  "workshopId": "L10_nextjs_fullstack",
  "name": "Next.js Fullstack Development",
  "technology": {
    "category": "web_fullstack",
    "stack": "Next.js 14+",
    "language": "TypeScript",
    "version": "Next.js 14+"
  },
  "level": "intermediate",
  "prerequisites": {
    "workshops": ["L9_react_modern"],
    "knowledge": [
      "React fundamentals and hooks",
      "TypeScript basics",
      "REST API concepts",
      "HTTP methods and status codes"
    ],
    "tools": [
      "Node.js 18+",
      "npm or yarn",
      "VS Code or similar IDE",
      "Git"
    ]
  },
  "duration": {
    "total_hours": 2.5,
    "concept_minutes": 30,
    "demo_minutes": 30,
    "exercise_minutes": 45,
    "challenge_minutes": 30,
    "reflection_minutes": 15
  },
  "learning_objectives": [
    {
      "objective": "Understand Next.js App Router architecture and routing",
      "bloom_level": "understand",
      "verification": "Can explain the difference between Server and Client Components"
    },
    {
      "objective": "Build Server Components and understand when to use them",
      "bloom_level": "apply",
      "verification": "Creates Server Components that fetch data and render on server"
    },
    {
      "objective": "Implement API routes and Server Actions",
      "bloom_level": "apply",
      "verification": "Builds API endpoints and Server Actions for data mutations"
    },
    {
      "objective": "Apply authentication patterns in Next.js",
      "bloom_level": "apply",
      "verification": "Implements protected routes and user authentication"
    },
    {
      "objective": "Optimize Next.js applications with caching and ISR",
      "bloom_level": "analyze",
      "verification": "Configures appropriate caching strategies for different data types"
    }
  ],
  "knowledge_files": [
    "nextjs-patterns.json",
    "react-patterns.json"
  ],
  "phases": [
    {
      "phaseId": "concept",
      "name": "Next.js App Router Fundamentals",
      "type": "concept",
      "duration_minutes": 30,
      "description": "Understanding App Router, Server Components, and Next.js architecture",
      "content": {
        "topics": [
          "App Router vs Pages Router",
          "Server Components vs Client Components",
          "File-based routing and layouts",
          "Data fetching: Server Components, Server Actions, API Routes",
          "Caching strategies: request memoization, Data Cache, Full Route Cache",
          "Authentication patterns: middleware, server sessions"
        ],
        "diagrams": [
          "App Router file structure",
          "Server vs Client Component rendering flow",
          "Next.js request lifecycle",
          "Caching layer architecture"
        ],
        "key_points": [
          "Server Components render on server, reducing client bundle",
          "Use 'use client' directive only when needed",
          "Server Actions provide type-safe mutations",
          "Layouts enable shared UI across routes",
          "Caching improves performance but requires understanding"
        ]
      },
      "facilitator_notes": "Emphasize the mental model shift from Pages Router. Show when to use Server vs Client Components.",
      "common_questions": [
        "When should I use Server vs Client Components?",
        "How does caching work in Next.js?",
        "Can I use Server Actions with forms?"
      ]
    },
    {
      "phaseId": "demo",
      "name": "Building a Blog with Next.js",
      "type": "demo",
      "duration_minutes": 30,
      "description": "Live coding a fullstack blog application",
      "content": {
        "topics": [
          "Setting up Next.js project with TypeScript",
          "Creating Server Component for blog posts",
          "Implementing API route for comments",
          "Adding Server Action for comment submission",
          "Implementing authentication middleware",
          "Adding ISR for blog posts"
        ],
        "code_examples": [
          "Server Component with async data fetching",
          "API route handler",
          "Server Action with form",
          "Middleware for authentication",
          "generateStaticParams for dynamic routes"
        ],
        "key_points": [
          "Server Components can be async",
          "API routes use standard Request/Response",
          "Server Actions are type-safe and secure",
          "Middleware runs before request completes"
        ]
      },
      "facilitator_notes": "Show network tab to demonstrate server-side rendering. Explain the request flow."
    },
    {
      "phaseId": "exercise_1",
      "name": "Server Component Data Fetching",
      "type": "exercise",
      "duration_minutes": 20,
      "description": "Create Server Components that fetch and display data",
      "content": {
        "topics": [
          "Create async Server Component",
          "Fetch data from external API",
          "Handle loading and error states",
          "Use generateStaticParams for dynamic routes"
        ]
      }
    },
    {
      "phaseId": "exercise_2",
      "name": "Server Actions and Forms",
      "type": "exercise",
      "duration_minutes": 25,
      "description": "Build forms with Server Actions",
      "content": {
        "topics": [
          "Create Server Action",
          "Build form component",
          "Handle form validation",
          "Implement optimistic updates",
          "Add error handling"
        ]
      }
    },
    {
      "phaseId": "challenge",
      "name": "E-Commerce Product Page",
      "type": "challenge",
      "duration_minutes": 30,
      "description": "Build a product page with Server Components, API routes, and authentication",
      "content": {
        "topics": [
          "Create product detail page with Server Component",
          "Implement add to cart Server Action",
          "Add protected checkout route",
          "Implement ISR for product pages",
          "Add search functionality"
        ]
      }
    },
    {
      "phaseId": "reflection",
      "name": "Key Takeaways and Production Considerations",
      "type": "reflection",
      "duration_minutes": 15,
      "description": "Consolidate learning and discuss deployment",
      "content": {
        "topics": [
          "Server vs Client Component decision tree",
          "Caching strategy guidelines",
          "Authentication best practices",
          "Performance optimization",
          "Deployment considerations"
        ],
        "key_points": [
          "Default to Server Components",
          "Use Client Components for interactivity",
          "Understand caching to avoid stale data",
          "Server Actions simplify form handling",
          "Middleware is powerful for auth"
        ]
      }
    }
  ],
  "exercises": [
    {
      "exerciseId": "ex1_server_component",
      "name": "Server Component Data Fetching",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 20,
      "description": "Create a Server Component that fetches and displays data",
      "starter_code": "// app/posts/[id]/page.tsx\nimport { notFound } from 'next/navigation';\n\ninterface Post {\n  id: string;\n  title: string;\n  content: string;\n  author: string;\n}\n\n// TODO: Create async Server Component\n// TODO: Fetch post data\n// TODO: Handle not found case\n// TODO: Use generateStaticParams for SSG\n\nexport default function PostPage({ params }: { params: { id: string } }) {\n  return (\n    <div>\n      <h1>Post Title</h1>\n      <p>Post content...</p>\n    </div>\n  );\n}",
      "solution_code": "// app/posts/[id]/page.tsx\nimport { notFound } from 'next/navigation';\n\ninterface Post {\n  id: string;\n  title: string;\n  content: string;\n  author: string;\n}\n\nasync function getPost(id: string): Promise<Post | null> {\n  // Simulate API call\n  const res = await fetch(`https://api.example.com/posts/${id}`, {\n    next: { revalidate: 3600 } // ISR: revalidate every hour\n  });\n  \n  if (!res.ok) {\n    return null;\n  }\n  \n  return res.json();\n}\n\nexport async function generateStaticParams() {\n  // Pre-generate popular posts\n  const posts = await fetch('https://api.example.com/posts').then(res => res.json());\n  return posts.slice(0, 10).map((post: Post) => ({\n    id: post.id,\n  }));\n}\n\nexport default async function PostPage({ params }: { params: { id: string } }) {\n  const post = await getPost(params.id);\n  \n  if (!post) {\n    notFound();\n  }\n  \n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>By {post.author}</p>\n      <div>{post.content}</div>\n    </div>\n  );\n}",
      "hints": [
        "Server Components can be async functions",
        "Use fetch with Next.js caching options",
        "Call notFound() for missing resources",
        "generateStaticParams enables static generation"
      ],
      "verification": "Page renders post data, handles missing posts, and uses ISR",
      "common_mistakes": [
        "Forgetting 'use client' is not needed for Server Components",
        "Not handling loading/error states",
        "Missing generateStaticParams for dynamic routes",
        "Not using Next.js fetch caching options"
      ]
    },
    {
      "exerciseId": "ex2_server_action",
      "name": "Server Actions and Forms",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 25,
      "description": "Build a form with Server Actions for data mutation",
      "starter_code": "'use client';\n\nimport { useState } from 'react';\n\n// TODO: Create Server Action in separate file\n// app/actions.ts\n// 'use server'\n// export async function createComment(formData: FormData) { ... }\n\n// TODO: Create form component\n// app/components/CommentForm.tsx\nexport default function CommentForm({ postId }: { postId: string }) {\n  const [pending, setPending] = useState(false);\n  \n  // TODO: Handle form submission with Server Action\n  \n  return (\n    <form>\n      <textarea name=\"content\" required />\n      <button type=\"submit\" disabled={pending}>\n        {pending ? 'Submitting...' : 'Submit Comment'}\n      </button>\n    </form>\n  );\n}",
      "solution_code": "// app/actions.ts\n'use server';\n\nimport { revalidatePath } from 'next/cache';\nimport { redirect } from 'next/navigation';\n\nexport async function createComment(formData: FormData) {\n  const content = formData.get('content') as string;\n  const postId = formData.get('postId') as string;\n  \n  if (!content || !postId) {\n    return { error: 'Content and post ID are required' };\n  }\n  \n  try {\n    // Save to database\n    const response = await fetch('https://api.example.com/comments', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ content, postId }),\n    });\n    \n    if (!response.ok) {\n      throw new Error('Failed to create comment');\n    }\n    \n    // Revalidate the page to show new comment\n    revalidatePath(`/posts/${postId}`);\n    \n    return { success: true };\n  } catch (error) {\n    return { error: 'Failed to create comment' };\n  }\n}\n\n// app/components/CommentForm.tsx\n'use client';\n\nimport { useState } from 'react';\nimport { createComment } from '@/app/actions';\n\nexport default function CommentForm({ postId }: { postId: string }) {\n  const [pending, setPending] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  async function handleSubmit(formData: FormData) {\n    setPending(true);\n    setError(null);\n    \n    formData.append('postId', postId);\n    const result = await createComment(formData);\n    \n    if (result.error) {\n      setError(result.error);\n    } else {\n      // Reset form\n      const form = document.getElementById('comment-form') as HTMLFormElement;\n      form?.reset();\n    }\n    \n    setPending(false);\n  }\n  \n  return (\n    <form id=\"comment-form\" action={handleSubmit}>\n      {error && <div className=\"error\">{error}</div>}\n      <textarea name=\"content\" required disabled={pending} />\n      <button type=\"submit\" disabled={pending}>\n        {pending ? 'Submitting...' : 'Submit Comment'}\n      </button>\n    </form>\n  );\n}",
      "verification": "Form submits comment, shows loading state, handles errors, and revalidates page",
      "common_mistakes": [
        "Forgetting 'use server' directive",
        "Not handling form validation",
        "Missing error handling",
        "Not revalidating after mutation"
      ]
    }
  ],
  "challenges": [
    {
      "challengeId": "ecommerce",
      "name": "E-Commerce Product Page",
      "description": "Build a complete product page with Server Components, API routes, and authentication",
      "requirements": [
        "Product detail page using Server Component",
        "Add to cart Server Action",
        "Protected checkout route with middleware",
        "ISR for product pages",
        "Search functionality with API route",
        "User authentication flow"
      ],
      "evaluation_criteria": [
        "Product page renders server-side",
        "Add to cart works correctly",
        "Checkout requires authentication",
        "Products are statically generated with ISR",
        "Search returns relevant results",
        "Auth flow is secure"
      ],
      "stretch_goals": [
        "Add product reviews with Server Actions",
        "Implement wishlist functionality",
        "Add real-time inventory updates",
        "Create admin dashboard for products"
      ]
    }
  ],
  "resources": {
    "official_docs": [
      "https://nextjs.org/docs",
      "https://nextjs.org/docs/app",
      "https://nextjs.org/docs/app/api-reference/server-actions"
    ],
    "tutorials": [
      "https://nextjs.org/learn",
      "Next.js App Router Course - Vercel"
    ],
    "videos": [
      "Next.js 14 App Router - Vercel YouTube",
      "Server Components Explained - React Conf"
    ],
    "community": [
      "Next.js Discord",
      "r/nextjs",
      "GitHub Discussions"
    ]
  },
  "assessment": {
    "knowledge_check": [
      {
        "question": "What's the difference between Server and Client Components?",
        "type": "short_answer",
        "answer": "Server Components render on the server and send HTML to client, reducing bundle size. Client Components render on client and can use hooks and browser APIs. Use 'use client' directive for Client Components.",
        "explanation": "Server Components are the default in App Router and provide better performance"
      },
      {
        "question": "When should you use Server Actions vs API Routes?",
        "type": "short_answer",
        "answer": "Use Server Actions for form submissions and mutations from Client Components. Use API Routes when you need a REST endpoint for external services or need more control over the request/response.",
        "explanation": "Server Actions provide better type safety and simpler form handling"
      },
      {
        "question": "How does ISR (Incremental Static Regeneration) work?",
        "type": "short_answer",
        "answer": "ISR allows you to update static pages after build time. Use revalidate option in fetch or generateStaticParams. Pages are regenerated in the background when requested after the revalidate period.",
        "explanation": "ISR combines benefits of static and dynamic rendering"
      }
    ],
    "practical_assessment": "Build a fullstack Next.js application with Server Components, Server Actions, API routes, and authentication",
    "self_assessment": [
      "Can I decide when to use Server vs Client Components?",
      "Do I understand how to implement Server Actions?",
      "Can I set up authentication with middleware?",
      "Do I know how to configure caching strategies?"
    ]
  },
  "next_steps": {
    "next_workshop": "L11_fastapi_production",
    "practice_projects": [
      "Build a SaaS application with Next.js",
      "Create a content management system",
      "Implement a social media platform"
    ],
    "deeper_learning": [
      "Next.js middleware advanced patterns",
      "Edge runtime and edge functions",
      "Next.js deployment and optimization"
    ]
  },
  "axiom_zero_integration": {
    "love_moments": [
      "Celebrating first Server Component render",
      "Encouraging experimentation with different patterns",
      "Patient debugging of caching issues"
    ],
    "truth_moments": [
      "Honest discussion of Server Component limitations",
      "Clear explanation of caching behavior",
      "Acknowledging when Client Components are necessary"
    ],
    "beauty_moments": [
      "Elegant Server Action implementations",
      "Beautiful type-safe API routes",
      "Clean separation of Server and Client Components"
    ]
  }
}
