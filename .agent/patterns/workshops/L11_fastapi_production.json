{
  "$schema": "../learning-workshop-pattern.json",
  "workshopId": "L11_fastapi_production",
  "name": "FastAPI Production APIs",
  "technology": {
    "category": "web_fullstack",
    "stack": "FastAPI",
    "language": "Python",
    "version": "FastAPI 0.110+"
  },
  "level": "intermediate",
  "prerequisites": {
    "workshops": [],
    "knowledge": [
      "Python 3.10+ programming",
      "HTTP APIs and REST concepts",
      "Basic understanding of async/await",
      "JSON and data serialization"
    ],
    "tools": [
      "Python 3.10+",
      "pip or poetry",
      "VS Code or similar IDE",
      "Postman or similar API client"
    ]
  },
  "duration": {
    "total_hours": 2.5,
    "concept_minutes": 30,
    "demo_minutes": 30,
    "exercise_minutes": 45,
    "challenge_minutes": 30,
    "reflection_minutes": 15
  },
  "learning_objectives": [
    {
      "objective": "Build async endpoints with proper error handling",
      "bloom_level": "apply",
      "verification": "Creates async endpoints that handle errors gracefully"
    },
    {
      "objective": "Design Pydantic models for request/response validation",
      "bloom_level": "apply",
      "verification": "Creates models with validation and documentation"
    },
    {
      "objective": "Implement dependency injection for reusable logic",
      "bloom_level": "apply",
      "verification": "Uses dependencies for authentication, database, and shared logic"
    },
    {
      "objective": "Integrate SQLAlchemy for database operations",
      "bloom_level": "apply",
      "verification": "Sets up database models and CRUD operations"
    },
    {
      "objective": "Write comprehensive tests for FastAPI applications",
      "bloom_level": "apply",
      "verification": "Creates unit and integration tests with pytest"
    }
  ],
  "knowledge_files": [
    "fastapi-patterns.json"
  ],
  "phases": [
    {
      "phaseId": "concept",
      "name": "FastAPI Architecture and Patterns",
      "type": "concept",
      "duration_minutes": 30,
      "description": "Understanding FastAPI's async architecture and production patterns",
      "content": {
        "topics": [
          "Async/await in FastAPI",
          "Pydantic models: validation, serialization, documentation",
          "Dependency injection system",
          "SQLAlchemy integration patterns",
          "Error handling and HTTP exceptions",
          "Testing strategies: TestClient, fixtures, mocking"
        ],
        "diagrams": [
          "FastAPI request lifecycle",
          "Dependency injection flow",
          "SQLAlchemy session management",
          "Testing pyramid for APIs"
        ],
        "key_points": [
          "FastAPI leverages Python type hints for validation",
          "Dependencies enable reusable, testable code",
          "Async endpoints improve concurrency",
          "Pydantic provides automatic validation and docs",
          "Database sessions must be properly managed"
        ]
      },
      "facilitator_notes": "Emphasize the power of type hints and dependency injection. Show how FastAPI generates OpenAPI docs automatically.",
      "common_questions": [
        "When should I use async vs sync endpoints?",
        "How do I handle database sessions?",
        "What's the best way to structure a FastAPI app?"
      ]
    },
    {
      "phaseId": "demo",
      "name": "Building a Task Management API",
      "type": "demo",
      "duration_minutes": 30,
      "description": "Live coding a production-ready FastAPI application",
      "content": {
        "topics": [
          "Setting up FastAPI project structure",
          "Creating Pydantic models",
          "Implementing async endpoints",
          "Adding dependency injection for auth",
          "Integrating SQLAlchemy",
          "Writing tests with pytest"
        ],
        "code_examples": [
          "FastAPI app with routers",
          "Pydantic request/response models",
          "Dependency for authentication",
          "SQLAlchemy models and CRUD",
          "TestClient usage"
        ],
        "key_points": [
          "Use routers to organize endpoints",
          "Pydantic models provide validation",
          "Dependencies are reusable and testable",
          "Database sessions need proper lifecycle",
          "Tests should be isolated"
        ]
      },
      "facilitator_notes": "Show automatic API documentation. Demonstrate how type hints enable IDE autocomplete."
    },
    {
      "phaseId": "exercise_1",
      "name": "Async Endpoints with Validation",
      "type": "exercise",
      "duration_minutes": 20,
      "description": "Create async endpoints with Pydantic validation",
      "content": {
        "topics": [
          "Create FastAPI app",
          "Define Pydantic models",
          "Implement async endpoints",
          "Add error handling",
          "Test with TestClient"
        ]
      }
    },
    {
      "phaseId": "exercise_2",
      "name": "Dependency Injection and Database",
      "type": "exercise",
      "duration_minutes": 25,
      "description": "Implement dependencies and SQLAlchemy integration",
      "content": {
        "topics": [
          "Create database dependency",
          "Implement authentication dependency",
          "Set up SQLAlchemy models",
          "Create CRUD operations",
          "Write integration tests"
        ]
      }
    },
    {
      "phaseId": "challenge",
      "name": "User Management API",
      "type": "challenge",
      "duration_minutes": 30,
      "description": "Build a complete user management API",
      "content": {
        "topics": [
          "User registration and authentication",
          "JWT token generation",
          "Protected endpoints",
          "User CRUD operations",
          "Password hashing",
          "Comprehensive test suite"
        ]
      }
    },
    {
      "phaseId": "reflection",
      "name": "Key Takeaways and Production Best Practices",
      "type": "reflection",
      "duration_minutes": 15,
      "description": "Consolidate learning and discuss deployment",
      "content": {
        "topics": [
          "FastAPI best practices",
          "Error handling strategies",
          "Database session management",
          "Testing approaches",
          "Deployment considerations"
        ],
        "key_points": [
          "Use type hints everywhere",
          "Dependencies enable clean architecture",
          "Async improves performance",
          "Tests ensure reliability",
          "Documentation is automatic"
        ]
      }
    }
  ],
  "exercises": [
    {
      "exerciseId": "ex1_async_endpoints",
      "name": "Async Endpoints with Validation",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 20,
      "description": "Create async endpoints with Pydantic models",
      "starter_code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List\n\napp = FastAPI()\n\n# TODO: Define Pydantic models\n# class ItemCreate(BaseModel): ...\n# class ItemResponse(BaseModel): ...\n\nitems_db = []\n\n# TODO: Create POST endpoint to create item\n@app.post(\"/items\")\nasync def create_item(item: ItemCreate):\n    # TODO: Implement\n    pass\n\n# TODO: Create GET endpoint to list items\n@app.get(\"/items\", response_model=List[ItemResponse])\nasync def list_items():\n    # TODO: Implement\n    pass\n\n# TODO: Create GET endpoint with path parameter\n@app.get(\"/items/{item_id}\")\nasync def get_item(item_id: int):\n    # TODO: Implement with error handling\n    pass",
      "solution_code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field\nfrom typing import List\nfrom datetime import datetime\n\napp = FastAPI(title=\"Task API\", version=\"1.0.0\")\n\nclass ItemCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(default=\"\", max_length=500)\n    price: float = Field(..., gt=0)\n    \n    class Config:\n        json_schema_extra = {\n            \"example\": {\n                \"name\": \"Laptop\",\n                \"description\": \"High-performance laptop\",\n                \"price\": 999.99\n            }\n        }\n\nclass ItemResponse(BaseModel):\n    id: int\n    name: str\n    description: str\n    price: float\n    created_at: datetime\n    \n    class Config:\n        from_attributes = True\n\nitems_db = []\nnext_id = 1\n\n@app.post(\"/items\", response_model=ItemResponse, status_code=201)\nasync def create_item(item: ItemCreate):\n    global next_id\n    new_item = {\n        \"id\": next_id,\n        \"name\": item.name,\n        \"description\": item.description,\n        \"price\": item.price,\n        \"created_at\": datetime.now()\n    }\n    items_db.append(new_item)\n    next_id += 1\n    return new_item\n\n@app.get(\"/items\", response_model=List[ItemResponse])\nasync def list_items():\n    return items_db\n\n@app.get(\"/items/{item_id}\", response_model=ItemResponse)\nasync def get_item(item_id: int):\n    item = next((i for i in items_db if i[\"id\"] == item_id), None)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return item",
      "hints": [
        "Use Pydantic Field for validation",
        "response_model enables automatic serialization",
        "Raise HTTPException for errors",
        "Use status_code parameter for POST"
      ],
      "verification": "Endpoints work correctly, validation works, errors are handled properly",
      "common_mistakes": [
        "Forgetting async keyword",
        "Not using response_model",
        "Missing error handling",
        "Not validating input properly"
      ]
    },
    {
      "exerciseId": "ex2_dependencies",
      "name": "Dependency Injection and Database",
      "type": "guided",
      "difficulty": "hard",
      "duration_minutes": 25,
      "description": "Implement dependencies and SQLAlchemy integration",
      "starter_code": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# TODO: Define SQLAlchemy model\n# class User(Base): ...\n\n# TODO: Create database dependency\n# def get_db(): ...\n\n# TODO: Create Pydantic models\n# class UserCreate(BaseModel): ...\n# class UserResponse(BaseModel): ...\n\napp = FastAPI()\n\n# TODO: Create endpoints with dependencies\n@app.post(\"/users\")\nasync def create_user(user: UserCreate, db: Session = Depends(get_db)):\n    # TODO: Implement\n    pass\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, db: Session = Depends(get_db)):\n    # TODO: Implement\n    pass",
      "solution_code": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr\nfrom typing import Optional\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True, nullable=False)\n    name = Column(String, nullable=False)\n    \nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    name: str\n\nclass UserResponse(BaseModel):\n    id: int\n    email: str\n    name: str\n    \n    class Config:\n        from_attributes = True\n\napp = FastAPI()\n\n@app.post(\"/users\", response_model=UserResponse, status_code=201)\nasync def create_user(user: UserCreate, db: Session = Depends(get_db)):\n    # Check if user exists\n    db_user = db.query(User).filter(User.email == user.email).first()\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    \n    db_user = User(email=user.email, name=user.name)\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return db_user\n\n@app.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def get_user(user_id: int, db: Session = Depends(get_db)):\n    db_user = db.query(User).filter(User.id == user_id).first()\n    if not db_user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return db_user\n\n@app.get(\"/users\", response_model=list[UserResponse])\nasync def list_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    users = db.query(User).offset(skip).limit(limit).all()\n    return users",
      "verification": "Dependencies work correctly, database operations succeed, errors are handled",
      "common_mistakes": [
        "Not closing database session",
        "Forgetting to commit transactions",
        "Not handling database errors",
        "Missing from_attributes in Pydantic Config"
      ]
    }
  ],
  "challenges": [
    {
      "challengeId": "user_api",
      "name": "User Management API",
      "description": "Build a complete user management API with authentication",
      "requirements": [
        "User registration and login endpoints",
        "JWT token generation and validation",
        "Password hashing with bcrypt",
        "Protected endpoints with dependency",
        "User CRUD operations",
        "Comprehensive test suite with pytest"
      ],
      "evaluation_criteria": [
        "Registration and login work correctly",
        "JWT tokens are valid and secure",
        "Passwords are hashed",
        "Protected endpoints require authentication",
        "All CRUD operations work",
        "Tests cover all endpoints"
      ],
      "stretch_goals": [
        "Add refresh token mechanism",
        "Implement role-based access control",
        "Add rate limiting",
        "Create admin endpoints"
      ]
    }
  ],
  "resources": {
    "official_docs": [
      "https://fastapi.tiangolo.com/",
      "https://fastapi.tiangolo.com/tutorial/",
      "https://docs.pydantic.dev/"
    ],
    "tutorials": [
      "FastAPI Full Course - freeCodeCamp",
      "Building APIs with FastAPI - Real Python"
    ],
    "videos": [
      "FastAPI Tutorial - YouTube",
      "Async Python and FastAPI - PyCon"
    ],
    "community": [
      "FastAPI Discord",
      "GitHub Discussions",
      "Stack Overflow - fastapi tag"
    ]
  },
  "assessment": {
    "knowledge_check": [
      {
        "question": "What are the benefits of using async endpoints in FastAPI?",
        "type": "short_answer",
        "answer": "Async endpoints improve concurrency by allowing the server to handle other requests while waiting for I/O operations. This is especially beneficial for database queries, API calls, and file operations.",
        "explanation": "Async enables better resource utilization"
      },
      {
        "question": "How does dependency injection work in FastAPI?",
        "type": "short_answer",
        "answer": "Dependencies are functions that FastAPI calls automatically. Use Depends() to inject them into endpoints. Dependencies can depend on other dependencies, creating a dependency tree. They're useful for authentication, database sessions, and shared logic.",
        "explanation": "Dependencies enable clean, testable code"
      },
      {
        "question": "How do you handle database sessions in FastAPI?",
        "type": "short_answer",
        "answer": "Create a dependency function that yields a database session. Use try/finally to ensure the session is closed. FastAPI handles the dependency lifecycle automatically.",
        "explanation": "Proper session management prevents connection leaks"
      }
    ],
    "practical_assessment": "Build a production-ready FastAPI application with async endpoints, Pydantic validation, dependency injection, SQLAlchemy integration, and comprehensive tests",
    "self_assessment": [
      "Can I create async endpoints with proper error handling?",
      "Do I understand how to use Pydantic models effectively?",
      "Can I implement dependency injection?",
      "Do I know how to integrate SQLAlchemy?",
      "Can I write comprehensive tests?"
    ]
  },
  "next_steps": {
    "next_workshop": "L12_kubernetes_production",
    "practice_projects": [
      "Build a REST API for a SaaS application",
      "Create a microservices architecture",
      "Implement real-time features with WebSockets"
    ],
    "deeper_learning": [
      "Advanced FastAPI patterns",
      "Background tasks and Celery",
      "API versioning and documentation"
    ]
  },
  "axiom_zero_integration": {
    "love_moments": [
      "Celebrating first working API endpoint",
      "Encouraging clean, readable code",
      "Patient debugging of dependency issues"
    ],
    "truth_moments": [
      "Honest discussion of async complexity",
      "Clear explanation of database session management",
      "Acknowledging when sync is better than async"
    ],
    "beauty_moments": [
      "Elegant dependency injection patterns",
      "Beautiful type-safe API definitions",
      "Clean, well-tested code that's easy to maintain"
    ]
  }
}
