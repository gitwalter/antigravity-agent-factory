{
  "$schema": "../learning-workshop-pattern.json",
  "workshopId": "L2_bitcoin_lightning",
  "name": "Bitcoin and Lightning Network Fundamentals",
  "technology": {
    "category": "blockchain",
    "stack": "Bitcoin + Lightning",
    "language": "Script/TypeScript",
    "version": "Bitcoin Core"
  },
  "level": "fundamentals",
  "prerequisites": {
    "workshops": [],
    "knowledge": [
      "Basic understanding of blockchain concepts",
      "Cryptography basics (hash functions, digital signatures)",
      "JavaScript/TypeScript for Lightning development",
      "Command-line proficiency"
    ],
    "tools": [
      "Node.js 18+ installed",
      "Bitcoin Core (or testnet node access)",
      "Lightning node software (LND, CLN, or similar)",
      "Code editor (VS Code recommended)"
    ]
  },
  "duration": {
    "total_hours": 2.5,
    "concept_minutes": 30,
    "demo_minutes": 30,
    "exercise_minutes": 45,
    "challenge_minutes": 30,
    "reflection_minutes": 15
  },
  "learning_objectives": [
    {
      "objective": "Understand the UTXO (Unspent Transaction Output) model and how it differs from Ethereum's account model",
      "bloom_level": "understand",
      "verification": "Can explain UTXO lifecycle, transaction inputs/outputs, and why Bitcoin uses this model"
    },
    {
      "objective": "Learn Bitcoin Script basics and common script patterns (P2PKH, P2SH, multisig)",
      "bloom_level": "understand",
      "verification": "Can read and explain basic Bitcoin Script, understand locking/unlocking scripts"
    },
    {
      "objective": "Understand Bitcoin transaction structure: inputs, outputs, scripts, and signatures",
      "bloom_level": "understand",
      "verification": "Can explain transaction components and how they relate to UTXO spending"
    },
    {
      "objective": "Learn Lightning Network payment channels and how they enable instant, low-cost transactions",
      "bloom_level": "understand",
      "verification": "Can explain channel opening, payment routing, and channel closing"
    },
    {
      "objective": "Understand HTLC (Hashed Time Lock Contract) mechanics for Lightning payments",
      "bloom_level": "understand",
      "verification": "Can explain how HTLCs enable trustless payment routing across multiple nodes"
    }
  ],
  "knowledge_files": [
    "bitcoin-patterns.json"
  ],
  "phases": [
    {
      "phaseId": "concept",
      "name": "UTXO Model and Bitcoin Script",
      "type": "concept",
      "duration_minutes": 30,
      "description": "Deep dive into Bitcoin's unique transaction model",
      "content": {
        "topics": [
          "UTXO model vs Account model comparison",
          "Transaction structure: inputs, outputs, scripts, signatures",
          "Bitcoin Script: stack-based language, opcodes",
          "Common script patterns: P2PKH, P2SH, P2WPKH, multisig",
          "Transaction lifecycle: creation, signing, broadcasting, confirmation",
          "Fee calculation and transaction prioritization"
        ],
        "diagrams": [
          "UTXO lifecycle diagram",
          "Transaction structure visualization",
          "Script execution flow",
          "Multisig script pattern diagram"
        ],
        "key_points": [
          "Bitcoin uses UTXOs, not account balances",
          "Each UTXO can only be spent once (double-spend prevention)",
          "Scripts define spending conditions",
          "Transactions consume inputs and create outputs",
          "Fees are the difference between input and output values"
        ]
      },
      "facilitator_notes": "Use visual diagrams to show UTXO flow. Compare to Ethereum's account model for those familiar. Emphasize that Bitcoin Script is intentionally limited for security.",
      "common_questions": [
        "Why does Bitcoin use UTXOs instead of accounts?",
        "What happens if I try to spend a UTXO twice?",
        "How do multisig transactions work?",
        "What is the difference between P2PKH and P2SH?",
        "How are transaction fees calculated?"
      ]
    },
    {
      "phaseId": "demo",
      "name": "Building a Multisig Transaction",
      "type": "demo",
      "duration_minutes": 30,
      "description": "Live demonstration of creating and signing a multisig transaction",
      "content": {
        "topics": [
          "Setting up Bitcoin testnet environment",
          "Creating a 2-of-3 multisig address",
          "Building a transaction with multiple inputs",
          "Signing transaction with multiple keys",
          "Broadcasting and verifying transaction",
          "Using Bitcoin libraries (bitcoinjs-lib)"
        ],
        "code_examples": [
          "Creating multisig address",
          "Building transaction with bitcoinjs-lib",
          "Signing with multiple private keys",
          "Broadcasting to testnet",
          "Querying transaction status"
        ],
        "key_points": [
          "Multisig requires M-of-N signatures",
          "Redeem script defines the multisig conditions",
          "Each signer must provide their signature",
          "Transaction must be fully signed before broadcasting"
        ]
      },
      "facilitator_notes": "Use testnet for safety. Show step-by-step transaction building. Explain each signature's role. Demonstrate error handling for incomplete signatures."
    },
    {
      "phaseId": "exercise_1",
      "name": "Creating Bitcoin Transactions",
      "type": "exercise",
      "duration_minutes": 25,
      "description": "Practice building and signing Bitcoin transactions",
      "content": {
        "topics": [
          "Create a simple P2PKH transaction",
          "Calculate transaction fees",
          "Sign transaction with private key",
          "Verify transaction before broadcasting"
        ]
      }
    },
    {
      "phaseId": "exercise_2",
      "name": "Lightning Network Basics",
      "type": "exercise",
      "duration_minutes": 20,
      "description": "Work with Lightning Network APIs",
      "content": {
        "topics": [
          "Open a payment channel",
          "Create Lightning invoices",
          "Send payments through channels",
          "Query channel status"
        ]
      }
    },
    {
      "phaseId": "challenge",
      "name": "Lightning Invoice Flow",
      "type": "challenge",
      "duration_minutes": 30,
      "description": "Build a complete Lightning payment flow",
      "content": {
        "topics": [
          "Create Lightning invoice with proper metadata",
          "Implement payment sending with retry logic",
          "Handle payment status updates",
          "Verify payment completion",
          "Handle payment failures gracefully"
        ]
      }
    },
    {
      "phaseId": "reflection",
      "name": "Key Takeaways and Bitcoin Philosophy",
      "type": "reflection",
      "duration_minutes": 15,
      "description": "Consolidate learning and understand Bitcoin's design philosophy",
      "content": {
        "topics": [
          "Summary of UTXO model advantages",
          "Bitcoin Script's security through simplicity",
          "Lightning Network's role in scaling",
          "Bitcoin's emphasis on decentralization and security",
          "Resources for continued learning"
        ],
        "key_points": [
          "UTXO model provides strong privacy and parallel processing",
          "Bitcoin Script is intentionally limited for security",
          "Lightning enables instant, low-cost payments",
          "Always verify transactions before broadcasting",
          "Understand fees and confirmation requirements"
        ]
      }
    }
  ],
  "exercises": [
    {
      "exerciseId": "ex1_bitcoin_transaction",
      "name": "Create Bitcoin Transaction",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 25,
      "description": "Build and sign a Bitcoin transaction using bitcoinjs-lib",
      "starter_code": "const bitcoin = require('bitcoinjs-lib');\nconst { ECPairFactory } = require('ecpair');\nconst ecc = require('tiny-secp256k1');\n\n// TODO: Set up testnet network\nconst network = bitcoin.networks.testnet;\n\n// TODO: Create key pair from private key\n// const keyPair = ...\n\n// TODO: Get UTXO to spend (from testnet faucet)\n// const utxo = { txid: '...', vout: 0, value: 100000 };\n\n// TODO: Create transaction builder\n// const psbt = new bitcoin.Psbt({ network });\n\n// TODO: Add input (UTXO to spend)\n// psbt.addInput({ ... });\n\n// TODO: Add output (destination address and amount)\n// psbt.addOutput({ ... });\n\n// TODO: Sign the transaction\n// psbt.signInput(0, keyPair);\n\n// TODO: Finalize and extract transaction\n// const tx = psbt.finalizeAllInputs().extractTransaction();\n\n// TODO: Get transaction hex for broadcasting\n// console.log('Transaction hex:', tx.toHex());",
      "solution_code": "const bitcoin = require('bitcoinjs-lib');\nconst { ECPairFactory } = require('ecpair');\nconst ecc = require('tiny-secp256k1');\n\nconst ECPair = ECPairFactory(ecc);\nconst network = bitcoin.networks.testnet;\n\n// Create key pair from private key (WIF format)\nconst privateKey = 'YOUR_PRIVATE_KEY_WIF'; // Replace with actual testnet key\nconst keyPair = ECPair.fromWIF(privateKey, network);\n\n// UTXO to spend (obtained from testnet faucet)\nconst utxo = {\n  txid: 'PREVIOUS_TX_ID',\n  vout: 0,\n  value: 100000, // satoshis\n  scriptPubKey: bitcoin.payments.p2pkh({ pubkey: keyPair.publicKey, network }).output\n};\n\n// Create PSBT (Partially Signed Bitcoin Transaction)\nconst psbt = new bitcoin.Psbt({ network });\n\n// Add input\npsbt.addInput({\n  hash: utxo.txid,\n  index: utxo.vout,\n  witnessUtxo: {\n    script: utxo.scriptPubKey,\n    value: utxo.value\n  }\n});\n\n// Destination address and amount (leaving some for fee)\nconst destinationAddress = 'RECIPIENT_ADDRESS';\nconst sendAmount = 50000; // satoshis\nconst fee = 1000; // estimated fee\n\n// Add output\npsbt.addOutput({\n  address: destinationAddress,\n  value: sendAmount\n});\n\n// Add change output if needed\nconst change = utxo.value - sendAmount - fee;\nif (change > 0) {\n  const changeAddress = bitcoin.payments.p2pkh({ pubkey: keyPair.publicKey, network }).address;\n  psbt.addOutput({\n    address: changeAddress,\n    value: change\n  });\n}\n\n// Sign the transaction\npsbt.signInput(0, keyPair);\n\n// Verify signature\npsbt.validateSignaturesOfInput(0, ecc.validateSignature);\n\n// Finalize and extract transaction\nconst tx = psbt.finalizeAllInputs().extractTransaction();\n\n// Get transaction hex for broadcasting\nconsole.log('Transaction hex:', tx.toHex());\nconsole.log('Transaction ID:', tx.getId());",
      "hints": [
        "Use bitcoinjs-lib's PSBT (Partially Signed Bitcoin Transaction) for modern transaction building",
        "Remember to include a change output if your input value exceeds send amount + fee",
        "Testnet addresses start with 'm' or 'n' (P2PKH) or '2' (P2SH)",
        "Always verify signatures before finalizing",
        "Use testnet faucets to get testnet Bitcoin"
      ],
      "verification": "Transaction builds successfully and can be broadcast to testnet",
      "common_mistakes": [
        "Forgetting to include change output",
        "Incorrect fee calculation",
        "Using mainnet network instead of testnet",
        "Not verifying signatures before finalizing",
        "Incorrect UTXO scriptPubKey format"
      ]
    },
    {
      "exerciseId": "ex2_lightning_invoice",
      "name": "Lightning Invoice Creation",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 20,
      "description": "Create and work with Lightning Network invoices",
      "starter_code": "const lnService = require('ln-service');\n\n// TODO: Connect to Lightning node\n// const lnd = lnService.authenticatedLndGrpc({\n//   cert: 'path/to/tls.cert',\n//   macaroon: 'path/to/admin.macaroon',\n//   socket: 'localhost:10009'\n// });\n\n// TODO: Create invoice\n// const invoice = await lnService.createInvoice({\n//   lnd,\n//   description: 'Test payment',\n//   tokens: 1000 // satoshis\n// });\n\n// TODO: Get invoice details\n// console.log('Invoice:', invoice.request);\n// console.log('Payment hash:', invoice.id);\n\n// TODO: Check invoice status\n// const invoiceDetails = await lnService.getInvoice({\n//   lnd,\n//   id: invoice.id\n// });",
      "solution_code": "const lnService = require('ln-service');\n\n// Connect to Lightning node (LND example)\nconst lnd = lnService.authenticatedLndGrpc({\n  cert: 'path/to/tls.cert',\n  macaroon: 'path/to/admin.macaroon',\n  socket: 'localhost:10009'\n});\n\nasync function createAndCheckInvoice() {\n  try {\n    // Create invoice\n    const invoice = await lnService.createInvoice({\n      lnd,\n      description: 'Test payment for workshop',\n      tokens: 1000, // satoshis\n      expires_at: new Date(Date.now() + 3600000) // 1 hour expiry\n    });\n    \n    console.log('Invoice created:');\n    console.log('Payment request:', invoice.request);\n    console.log('Payment hash:', invoice.id);\n    console.log('Expires at:', invoice.expires_at);\n    \n    // Check invoice status\n    const invoiceDetails = await lnService.getInvoice({\n      lnd,\n      id: invoice.id\n    });\n    \n    console.log('Invoice status:', invoiceDetails.is_confirmed ? 'Paid' : 'Unpaid');\n    \n    // Wait for payment (in real app, use webhooks or polling)\n    console.log('Waiting for payment...');\n    \n  } catch (error) {\n    console.error('Error:', error.message);\n  }\n}\n\ncreateAndCheckInvoice();",
      "verification": "Invoice is created successfully and can be paid",
      "common_mistakes": [
        "Incorrect LND connection parameters",
        "Not handling async/await properly",
        "Forgetting to set invoice expiry",
        "Not checking invoice status after creation",
        "Using wrong invoice ID format"
      ]
    }
  ],
  "challenges": [
    {
      "challengeId": "lightning_payment_flow",
      "name": "Complete Lightning Payment Flow",
      "description": "Build a complete Lightning payment application",
      "requirements": [
        "Create Lightning invoice with proper metadata",
        "Implement payment sending with retry logic",
        "Handle payment status updates (pending, completed, failed)",
        "Verify payment completion",
        "Handle payment failures with proper error messages",
        "Add logging for debugging"
      ],
      "evaluation_criteria": [
        "Invoice creation works correctly",
        "Payment sending handles retries",
        "Status updates are accurate",
        "Error handling is comprehensive",
        "Code is well-structured and documented"
      ],
      "stretch_goals": [
        "Add webhook support for payment notifications",
        "Implement payment splitting across multiple channels",
        "Add payment analytics and reporting",
        "Create a simple web UI for the payment flow"
      ]
    }
  ],
  "resources": {
    "official_docs": [
      "https://bitcoin.org/en/developer-documentation",
      "https://lightning.network/",
      "https://github.com/lightningnetwork/lnd",
      "https://bitcoinjs.org/"
    ],
    "tutorials": [
      "Bitcoin Developer Guide",
      "Lightning Network Developer Resources",
      "Mastering Bitcoin by Andreas Antonopoulos"
    ],
    "videos": [
      "Bitcoin Core YouTube channel",
      "Lightning Network tutorials"
    ],
    "books": [
      "Mastering Bitcoin by Andreas Antonopoulos",
      "Programming Bitcoin by Jimmy Song"
    ],
    "community": [
      "Bitcoin Stack Exchange",
      "Lightning Network Discord",
      "r/BitcoinDev on Reddit"
    ]
  },
  "assessment": {
    "knowledge_check": [
      {
        "question": "What is the main difference between Bitcoin's UTXO model and Ethereum's account model?",
        "type": "short_answer",
        "answer": "UTXO model tracks unspent transaction outputs as discrete units that can be spent, while account model tracks balances in accounts. UTXOs are consumed entirely and create new outputs, while accounts have balances that are debited/credited.",
        "explanation": "This fundamental difference affects transaction structure, privacy, and scalability"
      },
      {
        "question": "What is Bitcoin Script and why is it intentionally limited?",
        "type": "short_answer",
        "answer": "Bitcoin Script is a stack-based programming language used to define spending conditions. It's intentionally limited (not Turing-complete) to prevent infinite loops and ensure predictable execution, enhancing security and preventing denial-of-service attacks.",
        "explanation": "This design choice prioritizes security and predictability over programmability"
      },
      {
        "question": "How does the Lightning Network enable instant payments?",
        "type": "short_answer",
        "answer": "Lightning Network uses payment channels - off-chain channels between two parties. Payments within channels are instant because they don't require on-chain confirmation. Payments can be routed across multiple channels.",
        "explanation": "This solves Bitcoin's scalability and speed limitations for small payments"
      },
      {
        "question": "What is an HTLC and how does it enable trustless payment routing?",
        "type": "short_answer",
        "answer": "HTLC (Hashed Time Lock Contract) is a script that requires either: 1) revealing a secret hash preimage before a timeout, or 2) waiting until timeout expires. This enables trustless routing because intermediate nodes can't steal funds - they either forward the payment or return it.",
        "explanation": "HTLCs are the cryptographic primitive that makes Lightning Network trustless"
      }
    ],
    "practical_assessment": "Create a working Lightning invoice and successfully send a payment through a testnet Lightning node",
    "self_assessment": [
      "Can I explain the UTXO model and how transactions work?",
      "Do I understand Bitcoin Script basics and common patterns?",
      "Can I build and sign a Bitcoin transaction?",
      "Do I understand how Lightning payment channels work?",
      "Can I explain HTLC mechanics for payment routing?"
    ]
  },
  "next_steps": {
    "next_workshop": "L3_bitcoin_advanced",
    "practice_projects": [
      "Bitcoin wallet with HD key derivation",
      "Lightning payment processor",
      "Multisig transaction builder",
      "Bitcoin transaction fee estimator"
    ],
    "deeper_learning": [
      "Advanced Bitcoin Script patterns",
      "Lightning Network protocol details",
      "Bitcoin privacy techniques (CoinJoin, etc.)",
      "Bitcoin Core development"
    ]
  },
  "axiom_zero_integration": {
    "love_moments": [
      "Patient explanation of complex cryptographic concepts",
      "Encouraging support when working with testnet transactions",
      "Celebrating successful Lightning payments",
      "Creating a safe learning environment for experimenting with Bitcoin"
    ],
    "truth_moments": [
      "Honest discussion of Bitcoin's scalability tradeoffs",
      "Clear explanation of transaction finality and confirmation times",
      "Accurate fee estimation guidance",
      "Verified code examples that work with testnet",
      "Transparent about security considerations (private key management, etc.)"
    ],
    "beauty_moments": [
      "Appreciation for Bitcoin's elegant UTXO model",
      "Clean, well-structured transaction building code",
      "The satisfaction of a properly signed transaction",
      "Beautiful Lightning Network payment flow",
      "Elegant simplicity of Bitcoin Script"
    ]
  }
}
