{
  "$schema": "../learning-workshop-pattern.json",
  "workshopId": "L9_react_modern",
  "name": "Modern React Patterns",
  "technology": {
    "category": "web_fullstack",
    "stack": "React 18+",
    "language": "TypeScript",
    "version": "React 18+"
  },
  "level": "intermediate",
  "prerequisites": {
    "workshops": [],
    "knowledge": [
      "JavaScript/TypeScript fundamentals",
      "Basic React concepts (components, props, JSX)",
      "ES6+ features (arrow functions, destructuring, modules)"
    ],
    "tools": [
      "Node.js 18+",
      "npm or yarn",
      "VS Code or similar IDE",
      "React DevTools browser extension"
    ]
  },
  "duration": {
    "total_hours": 2.5,
    "concept_minutes": 30,
    "demo_minutes": 30,
    "exercise_minutes": 45,
    "challenge_minutes": 30,
    "reflection_minutes": 15
  },
  "learning_objectives": [
    {
      "objective": "Master React Hooks: useState, useEffect, useCallback, and useMemo",
      "bloom_level": "apply",
      "verification": "Can implement hooks correctly to manage state and side effects"
    },
    {
      "objective": "Create custom hooks for reusable logic",
      "bloom_level": "create",
      "verification": "Builds custom hook that encapsulates complex logic"
    },
    {
      "objective": "Apply component composition patterns effectively",
      "bloom_level": "apply",
      "verification": "Uses composition to build flexible, reusable components"
    },
    {
      "objective": "Implement Context API for state management",
      "bloom_level": "apply",
      "verification": "Creates context provider and consumes it in components"
    },
    {
      "objective": "Optimize React performance using memoization and code splitting",
      "bloom_level": "analyze",
      "verification": "Identifies performance bottlenecks and applies appropriate optimizations"
    }
  ],
  "knowledge_files": [
    "applying-react-patterns.json"
  ],
  "phases": [
    {
      "phaseId": "concept",
      "name": "Modern React Patterns Overview",
      "type": "concept",
      "duration_minutes": 30,
      "description": "Understanding hooks, composition, and performance patterns",
      "content": {
        "topics": [
          "React Hooks: useState, useEffect, useCallback, useMemo",
          "Custom hooks: extracting and sharing logic",
          "Component composition: children, render props, compound components",
          "Context API: when and how to use it",
          "Performance optimization: React.memo, useMemo, useCallback",
          "Code splitting with React.lazy and Suspense"
        ],
        "diagrams": [
          "Hook lifecycle and dependencies",
          "Component composition hierarchy",
          "Context provider-consumer flow",
          "React rendering optimization strategies"
        ],
        "key_points": [
          "Hooks must be called at the top level, not conditionally",
          "useCallback and useMemo prevent unnecessary re-renders",
          "Composition over inheritance for React components",
          "Context should be used sparingly to avoid prop drilling",
          "Performance optimization requires measurement first"
        ]
      },
      "facilitator_notes": "Emphasize the rules of hooks and when to use each pattern. Show examples of common mistakes.",
      "common_questions": [
        "When should I use useCallback vs useMemo?",
        "How do I know if I need Context API?",
        "Should I memoize everything?"
      ]
    },
    {
      "phaseId": "demo",
      "name": "Building a Reusable Form Component",
      "type": "demo",
      "duration_minutes": 30,
      "description": "Live coding a form with custom hooks and composition",
      "content": {
        "topics": [
          "Creating custom useForm hook",
          "Building reusable Input component",
          "Using Context for form state",
          "Implementing validation with useMemo",
          "Optimizing with React.memo",
          "Adding error handling"
        ],
        "code_examples": [
          "Custom useForm hook implementation",
          "Composed form components",
          "Context provider for form state",
          "Memoized validation logic"
        ],
        "key_points": [
          "Custom hooks encapsulate complex logic",
          "Composition makes components flexible",
          "Memoization prevents unnecessary calculations",
          "Context reduces prop drilling"
        ]
      },
      "facilitator_notes": "Show React DevTools to visualize re-renders and demonstrate optimization impact."
    },
    {
      "phaseId": "exercise_1",
      "name": "Custom Hook: useFetch",
      "type": "exercise",
      "duration_minutes": 20,
      "description": "Create a reusable data fetching hook",
      "content": {
        "topics": [
          "Implement useFetch with useState and useEffect",
          "Handle loading and error states",
          "Add caching with useMemo",
          "Support refetch functionality"
        ]
      }
    },
    {
      "phaseId": "exercise_2",
      "name": "Composed Modal Component",
      "type": "exercise",
      "duration_minutes": 25,
      "description": "Build a flexible modal using composition",
      "content": {
        "topics": [
          "Create Modal compound component",
          "Use Context for modal state",
          "Implement portal for rendering",
          "Add keyboard and click-outside handlers"
        ]
      }
    },
    {
      "phaseId": "challenge",
      "name": "Performance-Optimized Dashboard",
      "type": "challenge",
      "duration_minutes": 30,
      "description": "Build a dashboard with performance optimizations",
      "content": {
        "topics": [
          "Create dashboard with multiple data sources",
          "Implement memoization for expensive calculations",
          "Use code splitting for routes",
          "Optimize list rendering",
          "Add loading states and error boundaries"
        ]
      }
    },
    {
      "phaseId": "reflection",
      "name": "Key Takeaways and Best Practices",
      "type": "reflection",
      "duration_minutes": 15,
      "description": "Consolidate learning and discuss production patterns",
      "content": {
        "topics": [
          "When to use each hook pattern",
          "Composition vs Context trade-offs",
          "Performance optimization guidelines",
          "Testing hooks and composed components",
          "Resources for continued learning"
        ],
        "key_points": [
          "Measure before optimizing",
          "Composition provides flexibility",
          "Custom hooks promote reusability",
          "Context is powerful but use sparingly",
          "Always follow rules of hooks"
        ]
      }
    }
  ],
  "exercises": [
    {
      "exerciseId": "ex1_usefetch",
      "name": "Custom useFetch Hook",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 20,
      "description": "Create a reusable hook for data fetching with loading and error states",
      "starter_code": "import { useState, useEffect, useMemo } from 'react';\n\ninterface UseFetchResult<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => void;\n}\n\nfunction useFetch<T>(url: string): UseFetchResult<T> {\n  // TODO: Implement useState for data, loading, error\n  \n  // TODO: Implement useEffect to fetch data\n  \n  // TODO: Implement refetch function\n  \n  return {\n    data: null,\n    loading: false,\n    error: null,\n    refetch: () => {}\n  };\n}\n\n// Usage example\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, loading, error } = useFetch<User>(`/api/users/${userId}`);\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!data) return null;\n  \n  return <div>{data.name}</div>;\n}",
      "solution_code": "import { useState, useEffect, useCallback } from 'react';\n\ninterface UseFetchResult<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => void;\n}\n\nfunction useFetch<T>(url: string): UseFetchResult<T> {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<Error | null>(null);\n  \n  const fetchData = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const json = await response.json();\n      setData(json);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Unknown error'));\n      setData(null);\n    } finally {\n      setLoading(false);\n    }\n  }, [url]);\n  \n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  \n  return {\n    data,\n    loading,\n    error,\n    refetch: fetchData\n  };\n}\n\n// Usage example\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, loading, error, refetch } = useFetch<User>(`/api/users/${userId}`);\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!data) return null;\n  \n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.email}</p>\n      <button onClick={refetch}>Refresh</button>\n    </div>\n  );\n}",
      "hints": [
        "Use useState for data, loading, and error states",
        "Create an async function inside useEffect",
        "Use useCallback for refetch to memoize the function",
        "Handle cleanup if component unmounts during fetch"
      ],
      "verification": "Hook returns data, loading, and error states correctly, and refetch works",
      "common_mistakes": [
        "Forgetting to set loading to false in error case",
        "Not handling component unmount during async operation",
        "Missing dependency array in useEffect",
        "Not memoizing refetch function"
      ]
    },
    {
      "exerciseId": "ex2_modal",
      "name": "Composed Modal Component",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 25,
      "description": "Build a flexible modal using composition and Context API",
      "starter_code": "import React, { createContext, useContext, useState, ReactNode } from 'react';\nimport { createPortal } from 'react-dom';\n\n// TODO: Create ModalContext\n\n// TODO: Create ModalProvider component\n\n// TODO: Create Modal compound components (Modal.Trigger, Modal.Content, Modal.Close)\n\n// Usage example\nfunction App() {\n  return (\n    <Modal>\n      <Modal.Trigger>Open Modal</Modal.Trigger>\n      <Modal.Content>\n        <h2>Modal Title</h2>\n        <p>Modal content goes here</p>\n        <Modal.Close>Close</Modal.Close>\n      </Modal.Content>\n    </Modal>\n  );\n}",
      "solution_code": "import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';\nimport { createPortal } from 'react-dom';\n\ninterface ModalContextType {\n  isOpen: boolean;\n  open: () => void;\n  close: () => void;\n}\n\nconst ModalContext = createContext<ModalContextType | undefined>(undefined);\n\nfunction useModal() {\n  const context = useContext(ModalContext);\n  if (!context) {\n    throw new Error('Modal components must be used within Modal');\n  }\n  return context;\n}\n\nfunction Modal({ children }: { children: ReactNode }) {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  const open = useCallback(() => setIsOpen(true), []);\n  const close = useCallback(() => setIsOpen(false), []);\n  \n  return (\n    <ModalContext.Provider value={{ isOpen, open, close }}>\n      {children}\n    </ModalContext.Provider>\n  );\n}\n\nfunction ModalTrigger({ children }: { children: ReactNode }) {\n  const { open } = useModal();\n  return <button onClick={open}>{children}</button>;\n}\n\nfunction ModalContent({ children }: { children: ReactNode }) {\n  const { isOpen, close } = useModal();\n  \n  if (!isOpen) return null;\n  \n  const handleBackdropClick = (e: React.MouseEvent) => {\n    if (e.target === e.currentTarget) {\n      close();\n    }\n  };\n  \n  const handleEscape = useCallback((e: KeyboardEvent) => {\n    if (e.key === 'Escape') close();\n  }, [close]);\n  \n  React.useEffect(() => {\n    document.addEventListener('keydown', handleEscape);\n    return () => document.removeEventListener('keydown', handleEscape);\n  }, [handleEscape]);\n  \n  return createPortal(\n    <div \n      className=\"modal-backdrop\" \n      onClick={handleBackdropClick}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        backgroundColor: 'rgba(0,0,0,0.5)',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center'\n      }}\n    >\n      <div className=\"modal-content\" style={{\n        backgroundColor: 'white',\n        padding: '2rem',\n        borderRadius: '8px',\n        maxWidth: '500px'\n      }}>\n        {children}\n      </div>\n    </div>,\n    document.body\n  );\n}\n\nfunction ModalClose({ children }: { children: ReactNode }) {\n  const { close } = useModal();\n  return <button onClick={close}>{children}</button>;\n}\n\nModal.Trigger = ModalTrigger;\nModal.Content = ModalContent;\nModal.Close = ModalClose;\n\n// Usage example\nfunction App() {\n  return (\n    <Modal>\n      <Modal.Trigger>Open Modal</Modal.Trigger>\n      <Modal.Content>\n        <h2>Modal Title</h2>\n        <p>Modal content goes here</p>\n        <Modal.Close>Close</Modal.Close>\n      </Modal.Content>\n    </Modal>\n  );\n}",
      "verification": "Modal opens/closes correctly, handles backdrop click and Escape key",
      "common_mistakes": [
        "Not using portal for modal rendering",
        "Forgetting to clean up event listeners",
        "Not preventing event bubbling on backdrop click",
        "Missing error handling for missing context"
      ]
    }
  ],
  "challenges": [
    {
      "challengeId": "dashboard",
      "name": "Performance-Optimized Dashboard",
      "description": "Build a dashboard component with multiple data sources and performance optimizations",
      "requirements": [
        "Display multiple data sources (users, posts, analytics)",
        "Use custom hooks for each data source",
        "Implement React.memo for expensive components",
        "Use useMemo for expensive calculations",
        "Add code splitting with React.lazy",
        "Implement error boundaries",
        "Add loading states and skeleton screens"
      ],
      "evaluation_criteria": [
        "All data sources load correctly",
        "No unnecessary re-renders (verify with React DevTools)",
        "Expensive calculations are memoized",
        "Code splitting works correctly",
        "Error boundaries catch errors gracefully",
        "Loading states provide good UX"
      ],
      "stretch_goals": [
        "Add virtual scrolling for long lists",
        "Implement optimistic updates",
        "Add real-time updates with WebSocket",
        "Create reusable skeleton components"
      ]
    }
  ],
  "resources": {
    "official_docs": [
      "https://react.dev/reference/react",
      "https://react.dev/learn/reusing-logic-with-custom-hooks",
      "https://react.dev/reference/react/useContext"
    ],
    "tutorials": [
      "https://react.dev/learn",
      "https://kentcdodds.com/blog/compound-components-with-react-hooks"
    ],
    "videos": [
      "React Hooks Deep Dive - React Conf",
      "Advanced React Patterns - Frontend Masters"
    ],
    "community": [
      "React Discord",
      "r/reactjs",
      "Stack Overflow - reactjs tag"
    ]
  },
  "assessment": {
    "knowledge_check": [
      {
        "question": "When should you use useCallback vs useMemo?",
        "type": "short_answer",
        "answer": "useCallback memoizes functions, useMemo memoizes values. Use useCallback when passing functions as props to memoized components. Use useMemo for expensive calculations.",
        "explanation": "Both prevent unnecessary re-renders but optimize different things"
      },
      {
        "question": "What are the rules of hooks?",
        "type": "short_answer",
        "answer": "Only call hooks at the top level (not in loops, conditions, or nested functions). Only call hooks from React function components or custom hooks.",
        "explanation": "These rules ensure hooks are called in the same order every render"
      },
      {
        "question": "When should you use Context API vs prop drilling?",
        "type": "short_answer",
        "answer": "Use Context when you need to pass data through many levels (3+). For shallow component trees, prop drilling is simpler and more explicit.",
        "explanation": "Context adds complexity, so use it when the benefit outweighs the cost"
      }
    ],
    "practical_assessment": "Build a reusable component library with custom hooks, composed components, and performance optimizations",
    "self_assessment": [
      "Can I create custom hooks for reusable logic?",
      "Do I understand when to use each optimization technique?",
      "Can I build flexible components using composition?",
      "Do I know when Context API is appropriate?"
    ]
  },
  "next_steps": {
    "next_workshop": "L10_nextjs_fullstack",
    "practice_projects": [
      "Build a component library with Storybook",
      "Create a data visualization dashboard",
      "Implement a complex form with validation"
    ],
    "deeper_learning": [
      "React Server Components",
      "Advanced state management (Zustand, Jotai)",
      "React performance profiling and optimization"
    ]
  },
  "axiom_zero_integration": {
    "love_moments": [
      "Celebrating elegant hook compositions",
      "Encouraging experimentation with different patterns",
      "Patient debugging of hook dependency issues"
    ],
    "truth_moments": [
      "Honest discussion of when NOT to optimize",
      "Clear explanation of hook rules and why they exist",
      "Acknowledging performance trade-offs"
    ],
    "beauty_moments": [
      "Elegant custom hooks that encapsulate complexity",
      "Beautiful composed components that are flexible and reusable",
      "Clean, performant code that's easy to understand"
    ]
  }
}
