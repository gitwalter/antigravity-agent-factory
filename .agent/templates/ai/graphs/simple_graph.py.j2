"""
{{ graph_name }} - Basic LangGraph Workflow

A simple linear workflow demonstrating basic LangGraph patterns:
- State definition
- Simple node chain
- Entry/exit points

Axiom Alignment:
- A1 (Verifiability): State transitions are logged
- A3 (Transparency): Graph structure makes workflow explicit
"""

from typing import TypedDict, Annotated, List, Optional
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langgraph.checkpoint.memory import MemorySaver
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# =============================================================================
# State Definition
# =============================================================================

class {{ state_class }}(TypedDict):
    """
    State for {{ graph_name }} workflow.

    This state is immutable - nodes return new state, not modify in place.

    Attributes:
        messages: Conversation messages
        input: Original user input
        output: Final output
        step: Current step name
    """
    messages: Annotated[List[BaseMessage], add_messages]
    input: str
    output: Optional[str]
    step: str


# =============================================================================
# Node Definitions
# =============================================================================

{% for node in nodes %}
def {{ node.name }}(state: {{ state_class }}) -> dict:
    """
    {{ node.description }}

    Args:
        state: Current workflow state

    Returns:
        Updated state fields
    """
    logger.info(f"Executing {{ node.name }}...")

    # Node implementation
    # TODO: Implement {{ node.name }} logic

    return {
        "step": "{{ node.name }}",
        {% if node.updates_output %}
        "output": "Result from {{ node.name }}",
        {% endif %}
    }

{% endfor %}


# =============================================================================
# Graph Construction
# =============================================================================

def create_{{ graph_name|lower|replace(' ', '_') }}_graph() -> StateGraph:
    """
    Create the {{ graph_name }} workflow graph.

    Returns:
        Compiled LangGraph workflow
    """
    # Create graph with state schema
    graph = StateGraph({{ state_class }})

    # Add nodes
    {% for node in nodes %}
    graph.add_node("{{ node.name }}", {{ node.name }})
    {% endfor %}

    # Add edges - simple linear chain
    graph.add_edge(START, "{{ nodes[0].name }}")

    {% for i in range(nodes|length - 1) %}
    graph.add_edge("{{ nodes[i].name }}", "{{ nodes[i+1].name }}")
    {% endfor %}

    graph.add_edge("{{ nodes[-1].name }}", END)

    return graph


def compile_{{ graph_name|lower|replace(' ', '_') }}(use_checkpointing: bool = True):
    """
    Compile the workflow with optional checkpointing.

    Args:
        use_checkpointing: Whether to enable checkpointing

    Returns:
        Compiled workflow
    """
    graph = create_{{ graph_name|lower|replace(' ', '_') }}_graph()

    if use_checkpointing:
        checkpointer = MemorySaver()
        return graph.compile(checkpointer=checkpointer)

    return graph.compile()


# =============================================================================
# Workflow Execution
# =============================================================================

class {{ graph_name|replace(' ', '') }}Workflow:
    """
    {{ graph_name }} workflow executor.

    Example:
        >>> workflow = {{ graph_name|replace(' ', '') }}Workflow()
        >>> result = workflow.run("Process this input")
        >>> print(result["output"])
    """

    def __init__(self, use_checkpointing: bool = True):
        """
        Initialize the workflow.

        Args:
            use_checkpointing: Whether to use checkpointing
        """
        self.app = compile_{{ graph_name|lower|replace(' ', '_') }}(use_checkpointing)
        logger.info(f"{{ graph_name }} workflow initialized")

    def run(
        self,
        input_text: str,
        thread_id: Optional[str] = None
    ) -> {{ state_class }}:
        """
        Run the workflow with given input.

        Args:
            input_text: User input to process
            thread_id: Optional thread ID for conversation tracking

        Returns:
            Final workflow state
        """
        initial_state: {{ state_class }} = {
            "messages": [HumanMessage(content=input_text)],
            "input": input_text,
            "output": None,
            "step": "start"
        }

        config = {}
        if thread_id:
            config = {"configurable": {"thread_id": thread_id} }

        logger.info(f"Starting workflow with input: {input_text[:100]}...")

        result = self.app.invoke(initial_state, config)

        logger.info(f"Workflow completed. Step: {result.get('step')}")

        return result

    def visualize(self) -> str:
        """
        Generate a Mermaid diagram of the workflow.

        Returns:
            Mermaid diagram string
        """
        return self.app.get_graph().draw_mermaid()


# =============================================================================
# Example Usage
# =============================================================================

if __name__ == "__main__":
    # Create workflow
    workflow = {{ graph_name|replace(' ', '') }}Workflow()

    # Visualize graph structure
    print("Workflow Graph:")
    print(workflow.visualize())
    print()

    # Run workflow
    result = workflow.run("{{ example_input|default('Example input') }}")

    print(f"Step: {result['step']}")
    print(f"Output: {result.get('output', 'No output')}")
