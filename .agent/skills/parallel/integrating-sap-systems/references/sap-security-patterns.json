{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "sap-security-patterns",
  "name": "SAP Security Patterns",
  "title": "SAP Security Patterns",
  "version": "1.0.0",
  "description": "Security patterns for SAP applications including XSUAA, OAuth, principal propagation, CDS access control, and API security",
  "category": "sap",
  "last_updated": "2026-02-09",
  "axiomAlignment": {
    "A1_verifiability": "Token validation and scope checks enable verifiable authorization",
    "A2_user_primacy": "XSUAA and DCL protect user data and enforce least privilege",
    "A3_transparency": "Audit logging and explicit security configs make access traceable",
    "A4_non_harm": "Input validation, credential storage, and HTTPS prevent harmful outcomes",
    "A5_consistency": "Unified patterns for OAuth, principal propagation, and API security"
  },
  "related_skills": [
    "securing-sap-systems",
    "integrating-sap-systems",
    "btp-deployment",
    "securing-ai-systems",
    "error-handling"
  ],
  "related_knowledge": [
    "sap-btp-patterns.json",
    "iflow-patterns.json",
    "sap-api-management.json",
    "sap-fiori-patterns.json"
  ],
  "patterns": {
    "security-xsuaa-scopes": {
      "id": "security-xsuaa-scopes",
      "name": "XSUAA Scopes Pattern",
      "description": "Define application scopes for authorization",
      "scenario": "All BTP applications",
      "code": {
        "xs_security": "{\n  \"scopes\": [\n    { \"name\": \"$XSAPPNAME.Display\", \"description\": \"Display data\" },\n    { \"name\": \"$XSAPPNAME.Edit\", \"description\": \"Edit data\" }\n  ]\n}"
      },
      "use_when": "When All BTP applications",
      "code_example": "{\n  \"scopes\": [\n    { \"name\": \"$XSAPPNAME.Display\", \"description\": \"Display data\" },\n    { \"name\": \"$XSAPPNAME.Edit\", \"description\": \"Edit data\" }\n  ]\n}",
      "best_practices": [
        "Define scopes granularly",
        "Use meaningful names",
        "Provide descriptions",
        "Follow naming conventions"
      ]
    },
    "security-role-templates": {
      "id": "security-role-templates",
      "name": "Role Templates Pattern",
      "description": "Create reusable role templates",
      "scenario": "Role-based access control",
      "code": {
        "xs_security": "{\n  \"role-templates\": [\n    {\n      \"name\": \"Viewer\",\n      \"scope-references\": [\"$XSAPPNAME.Display\"]\n    },\n    {\n      \"name\": \"Editor\",\n      \"scope-references\": [\"$XSAPPNAME.Display\", \"$XSAPPNAME.Edit\"]\n    }\n  ]\n}"
      },
      "use_when": "When Role-based access control",
      "code_example": "{\n  \"role-templates\": [\n    {\n      \"name\": \"Viewer\",\n      \"scope-references\": [\"$XSAPPNAME.Display\"]\n    },\n    {\n      \"name\": \"Editor\",\n      \"scope-references\": [\"$XSAPPNAME.Display\", \"$XSAPPNAME.Edit\"]\n    }\n  ]\n}",
      "best_practices": [
        "Create role templates",
        "Reference scopes properly",
        "Use meaningful names",
        "Document role purposes"
      ]
    },
    "security-role-collections": {
      "id": "security-role-collections",
      "name": "Role Collections Pattern",
      "description": "Group role templates into collections",
      "scenario": "User role assignment",
      "code": {
        "xs_security": "{\n  \"role-collections\": [\n    {\n      \"name\": \"Viewer\",\n      \"role-template-references\": [\"$XSAPPNAME.Viewer\"]\n    }\n  ]\n}"
      },
      "use_when": "When User role assignment",
      "code_example": "{\n  \"role-collections\": [\n    {\n      \"name\": \"Viewer\",\n      \"role-template-references\": [\"$XSAPPNAME.Viewer\"]\n    }\n  ]\n}",
      "best_practices": [
        "Create role collections",
        "Assign to users",
        "Use for user management",
        "Test role assignments"
      ]
    },
    "security-oauth-client-credentials": {
      "id": "security-oauth-client-credentials",
      "name": "OAuth 2.0 Client Credentials Flow",
      "description": "Server-to-server authentication",
      "scenario": "Service-to-service communication",
      "code": {
        "javascript": "const response = await axios.post(\n  `${xsuaaUrl}/oauth/token`,\n  new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: clientId,\n    client_secret: clientSecret\n  })\n);"
      },
      "use_when": "When Service-to-service communication",
      "code_example": "const response = await axios.post(\n  `${xsuaaUrl}/oauth/token`,\n  new URLSearchParams({\n    grant_type: 'client_credentials',\n    client_id: clientId,\n    client_secret: clientSecret\n  })\n);",
      "best_practices": [
        "Use for server-to-server",
        "Store credentials securely",
        "Cache access tokens",
        "Handle token refresh"
      ]
    },
    "security-oauth-authorization-code": {
      "id": "security-oauth-authorization-code",
      "name": "OAuth 2.0 Authorization Code Flow",
      "description": "User authentication with redirect",
      "scenario": "User-facing applications",
      "code": {
        "javascript": "// Step 1: Redirect to authorization\nconst authUrl = `${xsuaaUrl}/oauth/authorize?` +\n  `client_id=${clientId}&` +\n  `response_type=code&` +\n  `redirect_uri=${redirectUri}`;\n\n// Step 2: Exchange code for token\nconst response = await axios.post(\n  `${xsuaaUrl}/oauth/token`,\n  new URLSearchParams({\n    grant_type: 'authorization_code',\n    code: code,\n    redirect_uri: redirectUri\n  })\n);"
      },
      "use_when": "When User-facing applications",
      "code_example": "// Step 1: Redirect to authorization\nconst authUrl = `${xsuaaUrl}/oauth/authorize?` +\n  `client_id=${clientId}&` +\n  `response_type=code&` +\n  `redirect_uri=${redirectUri}`;\n\n// Step 2: Exchange code for token\nconst response = await axios.post(\n  `${xsuaaUrl}/oauth/token`,\n  new URLSearchParams({\n    grant_type: 'authorization_code',\n    code: code,\n    redirect_uri: redirectUri\n  })\n);",
      "best_practices": [
        "Use for user apps",
        "Handle redirect properly",
        "Store tokens securely",
        "Implement token refresh"
      ]
    },
    "security-principal-propagation": {
      "id": "security-principal-propagation",
      "name": "Principal Propagation Pattern",
      "description": "Propagate user identity to on-premise systems",
      "scenario": "Cloud-to-on-premise connectivity",
      "code": {
        "destination": "{\n  \"authentication\": \"PrincipalPropagation\",\n  \"proxyType\": \"OnPremise\"\n}",
        "headers": "{\n  \"SAP-Connectivity-Authentication\": \"PrincipalPropagation\"\n}"
      },
      "use_when": "When Cloud-to-on-premise connectivity",
      "code_example": "{\n  \"authentication\": \"PrincipalPropagation\",\n  \"proxyType\": \"OnPremise\"\n}",
      "best_practices": [
        "Use principal propagation",
        "Configure Cloud Connector",
        "Set proper headers",
        "Test connectivity"
      ]
    },
    "security-dcl-rules": {
      "id": "security-dcl-rules",
      "name": "CDS Access Control (DCL) Pattern",
      "description": "Field-level and instance-level access control",
      "scenario": "Data security",
      "code": {
        "dcl": "@EndUserText.label: 'Entity Access Control'\ndefine role ZC_Entity {\n  grant select on ZI_Entity\n    where ( CreatedBy ) = aspect user_filter( CreatedBy );\n}"
      },
      "use_when": "When Data security",
      "code_example": "@EndUserText.label: 'Entity Access Control'\ndefine role ZC_Entity {\n  grant select on ZI_Entity\n    where ( CreatedBy ) = aspect user_filter( CreatedBy );\n}",
      "best_practices": [
        "Use DCL for data security",
        "Implement field-level control",
        "Use instance-level checks",
        "Test access control"
      ]
    },
    "security-token-validation": {
      "id": "security-token-validation",
      "name": "Token Validation Pattern",
      "description": "Validate OAuth tokens",
      "scenario": "All API endpoints",
      "code": {
        "javascript": "const jwt = require('jsonwebtoken');\nconst publicKey = await getPublicKey();\nconst decoded = jwt.verify(token, publicKey, {\n  algorithms: ['RS256'],\n  issuer: xsuaaUrl,\n  audience: clientId\n});"
      },
      "use_when": "When All API endpoints",
      "code_example": "const jwt = require('jsonwebtoken');\nconst publicKey = await getPublicKey();\nconst decoded = jwt.verify(token, publicKey, {\n  algorithms: ['RS256'],\n  issuer: xsuaaUrl,\n  audience: clientId\n});",
      "best_practices": [
        "Validate tokens on every request",
        "Check issuer and audience",
        "Verify signature",
        "Handle expired tokens"
      ]
    },
    "security-scope-check": {
      "id": "security-scope-check",
      "name": "Scope Check Pattern",
      "description": "Verify user has required scopes",
      "scenario": "Authorization checks",
      "code": {
        "javascript": "if (!req.user.scopes.includes('$XSAPPNAME.Edit')) {\n  return res.status(403).json({ error: 'Insufficient permissions' });\n}"
      },
      "use_when": "When Authorization checks",
      "code_example": "if (!req.user.scopes.includes('$XSAPPNAME.Edit')) {\n  return res.status(403).json({ error: 'Insufficient permissions' });\n}",
      "best_practices": [
        "Check scopes for operations",
        "Return 403 for insufficient permissions",
        "Log authorization failures",
        "Provide clear error messages"
      ]
    },
    "security-api-authentication": {
      "id": "security-api-authentication",
      "name": "API Authentication Pattern",
      "description": "Secure API endpoints",
      "scenario": "All APIs",
      "code": {
        "middleware": "const authenticate = async (req, res, next) => {\n  const token = req.headers.authorization?.substring(7);\n  if (!token) {\n    return res.status(401).json({ error: 'Missing token' });\n  }\n  try {\n    req.user = await validateToken(token);\n    next();\n  } catch (error) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n};"
      },
      "use_when": "When implementing API Authentication Pattern or when Secure API endpoints",
      "code_example": "const authenticate = async (req, res, next) => {\n  const token = req.headers.authorization?.substring(7);\n  if (!token) {\n    return res.status(401).json({ error: 'Missing token' });\n  }\n  try {\n    req.user = await validateToken(token);\n    next();\n  } catch (error) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n};",
      "best_practices": [
        "Authenticate all API endpoints",
        "Use middleware for authentication",
        "Return 401 for missing/invalid tokens",
        "Extract user from token"
      ]
    },
    "security-credential-storage": {
      "id": "security-credential-storage",
      "name": "Credential Storage Pattern",
      "description": "Secure credential management",
      "scenario": "All applications",
      "code": {
        "environment": "process.env.CLIENT_SECRET",
        "vcap": "const vcap = JSON.parse(process.env.VCAP_SERVICES);\nconst credentials = vcap.xsuaa[0].credentials;"
      },
      "use_when": "When All applications",
      "code_example": "process.env.CLIENT_SECRET",
      "best_practices": [
        "Never hardcode credentials",
        "Use environment variables",
        "Use VCAP_SERVICES",
        "Rotate credentials regularly"
      ]
    },
    "security-audit-logging": {
      "id": "security-audit-logging",
      "name": "Audit Logging Pattern",
      "description": "Log security events This pattern supports SAP Audit Logging Pattern integration and implementation.",
      "scenario": "All applications",
      "code": {
        "logging": "log.info('User action', {\n  user: req.user.id,\n  action: 'CREATE',\n  resource: 'Entity',\n  timestamp: new Date()\n});"
      },
      "use_when": "When All applications",
      "code_example": "log.info('User action', {\n  user: req.user.id,\n  action: 'CREATE',\n  resource: 'Entity',\n  timestamp: new Date()\n});",
      "best_practices": [
        "Log all security events",
        "Include user context",
        "Log actions and resources",
        "Store logs securely"
      ]
    },
    "security-csrf-protection": {
      "id": "security-csrf-protection",
      "name": "CSRF Protection Pattern",
      "description": "Protect against CSRF attacks",
      "scenario": "Web applications",
      "code": {
        "middleware": "const csrf = require('csurf');\napp.use(csrf({ cookie: true }));"
      },
      "use_when": "When Web applications",
      "code_example": "const csrf = require('csurf');\napp.use(csrf({ cookie: true }));",
      "best_practices": [
        "Use CSRF tokens",
        "Validate on state-changing operations",
        "Set secure cookies",
        "Test CSRF protection"
      ]
    },
    "security-input-validation": {
      "id": "security-input-validation",
      "name": "Input Validation Pattern",
      "description": "Validate and sanitize input",
      "scenario": "All user input",
      "code": {
        "validation": "const { body, validationResult } = require('express-validator');\napp.post('/api/entity',\n  body('name').isLength({ min: 1, max: 255 }),\n  body('email').isEmail(),\n  (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n  }\n);"
      },
      "use_when": "When All user input",
      "code_example": "const { body, validationResult } = require('express-validator');\napp.post('/api/entity',\n  body('name').isLength({ min: 1, max: 255 }),\n  body('email').isEmail(),\n  (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n  }\n);",
      "best_practices": [
        "Validate all input",
        "Use validation libraries",
        "Sanitize input",
        "Return clear error messages"
      ]
    },
    "security-output-encoding": {
      "id": "security-output-encoding",
      "name": "Output Encoding Pattern",
      "description": "Encode output to prevent XSS",
      "scenario": "Web applications",
      "code": {
        "encoding": "const escapeHtml = (text) => {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};"
      },
      "use_when": "When Web applications",
      "code_example": "const escapeHtml = (text) => {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};",
      "best_practices": [
        "Encode all output",
        "Use encoding libraries",
        "Prevent XSS attacks",
        "Test output encoding"
      ]
    },
    "security-https-only": {
      "id": "security-https-only",
      "name": "HTTPS Only Pattern",
      "description": "Enforce HTTPS This pattern supports SAP HTTPS Only Pattern integration and implementation.",
      "scenario": "All applications",
      "code": {
        "middleware": "app.use((req, res, next) => {\n  if (req.header('x-forwarded-proto') !== 'https') {\n    return res.redirect(`https://${req.header('host')}${req.url}`);\n  }\n  next();\n});"
      },
      "use_when": "When All applications",
      "code_example": "app.use((req, res, next) => {\n  if (req.header('x-forwarded-proto') !== 'https') {\n    return res.redirect(`https://${req.header('host')}${req.url}`);\n  }\n  next();\n});",
      "best_practices": [
        "Enforce HTTPS",
        "Redirect HTTP to HTTPS",
        "Use secure cookies",
        "Configure SSL properly"
      ]
    },
    "security-rate-limiting": {
      "id": "security-rate-limiting",
      "name": "Rate Limiting Pattern",
      "description": "Limit request rate This pattern supports SAP Rate Limiting Pattern integration and implementation.",
      "scenario": "Public APIs",
      "code": {
        "middleware": "const rateLimit = require('express-rate-limit');\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100\n});\napp.use('/api/', limiter);"
      },
      "use_when": "When Public APIs",
      "code_example": "const rateLimit = require('express-rate-limit');\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100\n});\napp.use('/api/', limiter);",
      "best_practices": [
        "Implement rate limiting",
        "Set appropriate limits",
        "Return 429 for rate limit exceeded",
        "Monitor rate limit usage"
      ]
    },
    "security-sql-injection-prevention": {
      "id": "security-sql-injection-prevention",
      "name": "SQL Injection Prevention Pattern",
      "description": "Prevent SQL injection attacks",
      "scenario": "Database queries",
      "code": {
        "cds": "SELECT FROM zentity WHERE id = :id",
        "parameterized": "const query = 'SELECT * FROM table WHERE id = ?';\ndb.query(query, [id]);"
      },
      "use_when": "When Database queries",
      "code_example": "SELECT FROM zentity WHERE id = :id",
      "best_practices": [
        "Use parameterized queries",
        "Never concatenate SQL",
        "Use CDS views",
        "Validate input types"
      ]
    },
    "security-secrets-management": {
      "id": "security-secrets-management",
      "name": "Secrets Management Pattern",
      "description": "Manage application secrets",
      "scenario": "All applications",
      "code": {
        "vcap": "const vcap = JSON.parse(process.env.VCAP_SERVICES);\nconst secret = vcap.user-provided[0].credentials.secret;"
      },
      "use_when": "When All applications",
      "code_example": "const vcap = JSON.parse(process.env.VCAP_SERVICES);\nconst secret = vcap.user-provided[0].credentials.secret;",
      "best_practices": [
        "Use VCAP_SERVICES",
        "Use user-provided services",
        "Rotate secrets regularly",
        "Never commit secrets"
      ]
    },
    "security-token-refresh": {
      "id": "security-token-refresh",
      "name": "Token Refresh Pattern",
      "description": "Refresh expired tokens",
      "scenario": "Long-lived sessions",
      "code": {
        "refresh": "const response = await axios.post(\n  `${xsuaaUrl}/oauth/token`,\n  new URLSearchParams({\n    grant_type: 'refresh_token',\n    refresh_token: refreshToken\n  })\n);"
      },
      "use_when": "When Long-lived sessions",
      "code_example": "const response = await axios.post(\n  `${xsuaaUrl}/oauth/token`,\n  new URLSearchParams({\n    grant_type: 'refresh_token',\n    refresh_token: refreshToken\n  })\n);",
      "best_practices": [
        "Implement token refresh",
        "Store refresh tokens securely",
        "Handle refresh failures",
        "Refresh before expiry"
      ]
    },
    "security-multi-tenant": {
      "id": "security-multi-tenant",
      "name": "Multi-Tenant Security Pattern",
      "description": "Secure multi-tenant applications",
      "scenario": "SaaS applications",
      "code": {
        "tenant_isolation": "const tenantId = req.user.tenantId;\nconst data = await db.query(\n  'SELECT * FROM data WHERE tenant_id = ?',\n  [tenantId]\n);"
      },
      "use_when": "When SaaS applications",
      "code_example": "const tenantId = req.user.tenantId;\nconst data = await db.query(\n  'SELECT * FROM data WHERE tenant_id = ?',\n  [tenantId]\n);",
      "best_practices": [
        "Isolate tenant data",
        "Check tenant on every request",
        "Use tenant-aware queries",
        "Test tenant isolation"
      ]
    },
    "security-password-policy": {
      "id": "security-password-policy",
      "name": "Password Policy Pattern",
      "description": "Enforce password policies",
      "scenario": "User management",
      "code": {
        "validation": "const passwordPolicy = {\n  minLength: 8,\n  requireUppercase: true,\n  requireLowercase: true,\n  requireNumbers: true,\n  requireSpecialChars: true\n};"
      },
      "use_when": "When User management",
      "code_example": "const passwordPolicy = {\n  minLength: 8,\n  requireUppercase: true,\n  requireLowercase: true,\n  requireNumbers: true,\n  requireSpecialChars: true\n};",
      "best_practices": [
        "Enforce password policies",
        "Use strong requirements",
        "Hash passwords properly",
        "Never store plain passwords"
      ]
    },
    "security-session-management": {
      "id": "security-session-management",
      "name": "Session Management Pattern",
      "description": "Secure session handling",
      "scenario": "Web applications",
      "code": {
        "session": "app.use(session({\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n  cookie: {\n    secure: true,\n    httpOnly: true,\n    maxAge: 3600000\n  }\n}));"
      },
      "use_when": "When Web applications",
      "code_example": "app.use(session({\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n  cookie: {\n    secure: true,\n    httpOnly: true,\n    maxAge: 3600000\n  }\n}));",
      "best_practices": [
        "Use secure sessions",
        "Set secure cookies",
        "Use httpOnly flag",
        "Set appropriate expiry"
      ]
    },
    "security-cors-configuration": {
      "id": "security-cors-configuration",
      "name": "CORS Configuration Pattern",
      "description": "Configure CORS properly",
      "scenario": "Cross-origin requests",
      "code": {
        "cors": "const cors = require('cors');\napp.use(cors({\n  origin: ['https://allowed-domain.com'],\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE']\n}));"
      },
      "use_when": "When Cross-origin requests",
      "code_example": "const cors = require('cors');\napp.use(cors({\n  origin: ['https://allowed-domain.com'],\n  credentials: true,\n  methods: ['GET', 'POST', 'PUT', 'DELETE']\n}));",
      "best_practices": [
        "Configure CORS properly",
        "Whitelist allowed origins",
        "Use credentials carefully",
        "Test CORS configuration"
      ]
    },
    "security-error-handling": {
      "id": "security-error-handling",
      "name": "Security Error Handling Pattern",
      "description": "Handle security errors securely",
      "scenario": "All applications",
      "code": {
        "error": "try {\n  // Security operation\n} catch (error) {\n  log.error('Security error', { error: error.message });\n  return res.status(500).json({ error: 'Internal server error' });\n}"
      },
      "use_when": "When All applications",
      "code_example": "try {\n  // Security operation\n} catch (error) {\n  log.error('Security error', { error: error.message });\n  return res.status(500).json({ error: 'Internal server error' });\n}",
      "best_practices": [
        "Don't expose internal errors",
        "Log security errors",
        "Return generic messages",
        "Monitor security errors"
      ]
    },
    "security-dependency-scanning": {
      "id": "security-dependency-scanning",
      "name": "Dependency Scanning Pattern",
      "description": "Scan dependencies for vulnerabilities",
      "scenario": "All applications",
      "code": {
        "scan": "npm audit\nnpm audit fix"
      },
      "use_when": "When All applications",
      "code_example": "npm audit\nnpm audit fix",
      "best_practices": [
        "Scan dependencies regularly",
        "Fix vulnerabilities",
        "Update dependencies",
        "Use automated scanning"
      ]
    }
  },
  "best_practices": [
    "Use XSUAA for all BTP applications",
    "Implement proper scope-based authorization",
    "Use principal propagation for on-premise connectivity",
    "Implement CDS access control for data security",
    "Use OAuth 2.0 authorization code flow for user apps",
    "Use client credentials flow for server-to-server",
    "Never hardcode credentials (use secure stores)",
    "Implement token refresh mechanisms",
    "Validate tokens on every request",
    "Use HTTPS for all communications",
    "Implement proper error handling",
    "Log security events for auditing",
    "Use role-based access control (RBAC)",
    "Implement least privilege principle"
  ],
  "anti_patterns": [
    {
      "name": "Hardcoding credentials",
      "problem": "Security vulnerability",
      "fix": "Use environment variables and secure credential stores"
    },
    {
      "name": "Not validating tokens",
      "problem": "Security vulnerability",
      "fix": "Validate tokens on every request"
    },
    {
      "name": "Missing scope checks",
      "problem": "Unauthorized access",
      "fix": "Check scopes for all operations"
    },
    {
      "name": "Not using principal propagation",
      "problem": "Authentication failures",
      "fix": "Use principal propagation for on-premise connectivity"
    }
  ]
}
