{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "api-integration-patterns",
  "name": "API Integration Patterns",
  "title": "API Integration Patterns",
  "description": "Comprehensive patterns for REST, GraphQL, webhook integrations with retry logic and error handling",
  "version": "1.0.0",
  "category": "integration",
  "axiomAlignment": {
    "A1_verifiability": "Retry logic and circuit breakers enable reproducible behavior",
    "A2_user_primacy": "Rate limiting and error handling protect consumer experience",
    "A3_transparency": "Logging and correlation IDs enable request tracing",
    "A4_non_harm": "Validation and timeout patterns prevent cascade failures",
    "A5_consistency": "Unified patterns for REST, GraphQL, and webhook integrations"
  },
  "related_skills": [
    "error-handling",
    "developing-fastapi",
    "tool-usage"
  ],
  "related_knowledge": [
    "api-design-patterns.json",
    "error-handling-patterns.json",
    "langchain-patterns.json"
  ],
  "patterns": {
    "rest": {
      "description": "RESTful API integration patterns",
      "httpClient": {
        "recommended": "httpx",
        "alternative": "aiohttp",
        "sync": "requests",
        "installation": "pip install httpx[http2]"
      },
      "basicRequest": {
        "sync": "import httpx\n\nresponse = httpx.get(\n    'https://api.example.com/data',\n    headers={'Authorization': f'Bearer {api_key}'},\n    timeout=30.0\n)\nresponse.raise_for_status()\ndata = response.json()",
        "async": "import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(\n        'https://api.example.com/data',\n        headers={'Authorization': f'Bearer {api_key}'},\n        timeout=30.0\n    )\n    response.raise_for_status()\n    data = response.json()"
      },
      "clientConfiguration": {
        "description": "Reusable client with common settings",
        "example": "import httpx\n\nclass APIClient:\n    def __init__(self, base_url: str, api_key: str):\n        self.client = httpx.AsyncClient(\n            base_url=base_url,\n            headers={\n                'Authorization': f'Bearer {api_key}',\n                'Content-Type': 'application/json',\n                'User-Agent': 'LangChainAgentPlatform/1.0'\n            },\n            timeout=httpx.Timeout(30.0, connect=10.0),\n            limits=httpx.Limits(max_connections=100)\n        )\n    \n    async def get(self, path: str, **kwargs) -> dict:\n        response = await self.client.get(path, **kwargs)\n        response.raise_for_status()\n        return response.json()\n    \n    async def post(self, path: str, data: dict, **kwargs) -> dict:\n        response = await self.client.post(path, json=data, **kwargs)\n        response.raise_for_status()\n        return response.json()\n    \n    async def close(self):\n        await self.client.aclose()",
        "use_when": "Apply when implementing clientConfiguration in integration context",
        "code_example": "import httpx\n\nclass APIClient:\n    def __init__(self, base_url: str, api_key: str):\n        self.client = httpx.AsyncClient(\n            base_url=base_url,\n            headers={\n                'Authorization': f'Bearer {api_key}',\n                'Content-Type': 'application/json',\n                'User-Agent': 'LangChainAgentPlatform/1.0'\n            },\n            timeout=httpx.Timeout(30.0, connect=10.0),\n            limits=httpx.Limits(max_connections=100)\n        )\n    \n    async def get(self, path: str, **kwargs) -> dict:\n        response = await self.client.get(path, **kwargs)\n        response.raise_for_status()\n        return response.json()\n    \n    async def post(self, path: str, data: dict, **kwargs) -> dict:\n        response = await self.client.post(path, json=data, **kwargs)\n        response.raise_for_status()\n        return response.json()\n    \n    async def close(self):\n        await self.client.aclose()",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for clientConfiguration",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "pagination": {
        "cursor": "async def fetch_all_paginated(client: APIClient, endpoint: str) -> list:\n    results = []\n    cursor = None\n    \n    while True:\n        params = {'cursor': cursor} if cursor else {}\n        response = await client.get(endpoint, params=params)\n        results.extend(response['data'])\n        \n        cursor = response.get('next_cursor')\n        if not cursor:\n            break\n    \n    return results",
        "offset": "async def fetch_all_offset(client: APIClient, endpoint: str, limit: int = 100) -> list:\n    results = []\n    offset = 0\n    \n    while True:\n        response = await client.get(endpoint, params={'limit': limit, 'offset': offset})\n        data = response['data']\n        results.extend(data)\n        \n        if len(data) < limit:\n            break\n        offset += limit\n    \n    return results"
      },
      "authentication": {
        "bearer": "headers={'Authorization': f'Bearer {token}'}",
        "apiKey": "headers={'X-API-Key': api_key}",
        "basic": "import base64\ncreds = base64.b64encode(f'{username}:{password}'.encode()).decode()\nheaders={'Authorization': f'Basic {creds}'}",
        "oauth2": "from authlib.integrations.httpx_client import AsyncOAuth2Client\n\nclient = AsyncOAuth2Client(\n    client_id=client_id,\n    client_secret=client_secret,\n    token_endpoint=token_url\n)\nawait client.fetch_token()"
      },
      "use_when": "Apply when implementing rest in integration context",
      "code_example": "import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(url, timeout=30.0)\n    response.raise_for_status()\n    return response.json()",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for rest",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "graphql": {
      "description": "GraphQL API integration patterns",
      "client": {
        "recommended": "gql",
        "installation": "pip install gql[httpx]"
      },
      "basicQuery": "from gql import gql, Client\nfrom gql.transport.httpx import HTTPXAsyncTransport\n\ntransport = HTTPXAsyncTransport(\n    url='https://api.example.com/graphql',\n    headers={'Authorization': f'Bearer {api_key}'}\n)\n\nasync with Client(transport=transport) as client:\n    query = gql('''\n        query GetUser($id: ID!) {\n            user(id: $id) {\n                id\n                name\n                email\n            }\n        }\n    ''')\n    result = await client.execute(query, variable_values={'id': user_id})",
      "mutations": "mutation = gql('''\n    mutation CreateOrder($input: OrderInput!) {\n        createOrder(input: $input) {\n            id\n            status\n            createdAt\n        }\n    }\n''')\n\nresult = await client.execute(\n    mutation,\n    variable_values={'input': {'productId': '123', 'quantity': 2}}\n)",
      "subscriptions": "subscription = gql('''\n    subscription OnOrderUpdated($orderId: ID!) {\n        orderUpdated(orderId: $orderId) {\n            id\n            status\n        }\n    }\n''')\n\nasync for result in client.subscribe(subscription, variable_values={'orderId': order_id}):\n    print(result)",
      "use_when": "Apply when implementing graphql in integration context",
      "code_example": "import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(url, timeout=30.0)\n    response.raise_for_status()\n    return response.json()",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for graphql",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "retry": {
      "description": "Retry patterns for resilient API calls",
      "tenacity": {
        "installation": "pip install tenacity",
        "basic": "from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type\nimport httpx\n\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=1, max=10),\n    retry=retry_if_exception_type((httpx.TimeoutException, httpx.HTTPStatusError))\n)\nasync def fetch_with_retry(url: str) -> dict:\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        response.raise_for_status()\n        return response.json()",
        "withCallback": "from tenacity import before_sleep_log\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@retry(\n    stop=stop_after_attempt(5),\n    wait=wait_exponential(multiplier=1, min=2, max=60),\n    retry=retry_if_exception_type((httpx.TimeoutException, httpx.HTTPStatusError)),\n    before_sleep=before_sleep_log(logger, logging.WARNING)\n)\nasync def resilient_api_call(url: str, data: dict) -> dict:\n    ..."
      },
      "circuitBreaker": {
        "description": "Circuit breaker pattern for failing services",
        "example": "from circuitbreaker import circuit\n\n@circuit(failure_threshold=5, recovery_timeout=30)\nasync def call_external_service(endpoint: str) -> dict:\n    async with httpx.AsyncClient() as client:\n        response = await client.get(endpoint)\n        response.raise_for_status()\n        return response.json()",
        "use_when": "Apply when implementing circuitBreaker in integration context",
        "code_example": "from circuitbreaker import circuit\n\n@circuit(failure_threshold=5, recovery_timeout=30)\nasync def call_external_service(endpoint: str) -> dict:\n    async with httpx.AsyncClient() as client:\n        response = await client.get(endpoint)\n        response.raise_for_status()\n        return response.json()",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for circuitBreaker",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "use_when": "Apply when implementing retry in integration context",
      "code_example": "import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(url, timeout=30.0)\n    response.raise_for_status()\n    return response.json()",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for retry",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "webhooks": {
      "description": "Webhook handling patterns",
      "receiver": {
        "fastapi": "from fastapi import FastAPI, Request, HTTPException, Header\nimport hmac\nimport hashlib\n\napp = FastAPI()\n\n@app.post('/webhooks/{provider}')\nasync def handle_webhook(\n    provider: str,\n    request: Request,\n    x_signature: str = Header(None)\n):\n    body = await request.body()\n    \n    # Verify signature\n    expected_sig = hmac.new(\n        webhook_secret.encode(),\n        body,\n        hashlib.sha256\n    ).hexdigest()\n    \n    if not hmac.compare_digest(x_signature or '', f'sha256={expected_sig}'):\n        raise HTTPException(status_code=401, detail='Invalid signature')\n    \n    payload = await request.json()\n    \n    # Dispatch to handler\n    await dispatch_webhook(provider, payload)\n    \n    return {'status': 'received'}"
      },
      "dispatcher": "from typing import Callable, Dict\nimport asyncio\n\nclass WebhookDispatcher:\n    def __init__(self):\n        self.handlers: Dict[str, Callable] = {}\n    \n    def register(self, event_type: str, handler: Callable):\n        self.handlers[event_type] = handler\n    \n    async def dispatch(self, event_type: str, payload: dict):\n        handler = self.handlers.get(event_type)\n        if handler:\n            await handler(payload)\n        else:\n            logger.warning(f'No handler for event: {event_type}')\n\ndispatcher = WebhookDispatcher()\n\n@dispatcher.register('order.created')\nasync def handle_order_created(payload: dict):\n    order_id = payload['order_id']\n    # Process order...",
      "idempotency": "from functools import wraps\nimport redis.asyncio as redis\n\nredis_client = redis.from_url('redis://localhost')\n\ndef idempotent(key_func):\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            key = f'webhook:{key_func(*args, **kwargs)}'\n            \n            # Check if already processed\n            if await redis_client.exists(key):\n                return {'status': 'already_processed'}\n            \n            # Process and mark as done\n            result = await func(*args, **kwargs)\n            await redis_client.setex(key, 86400, 'processed')  # 24h TTL\n            \n            return result\n        return wrapper\n    return decorator\n\n@idempotent(lambda payload: payload['event_id'])\nasync def process_webhook(payload: dict):\n    ...",
      "use_when": "Apply when implementing webhooks in integration context",
      "code_example": "import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(url, timeout=30.0)\n    response.raise_for_status()\n    return response.json()",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for webhooks",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "rateLimit": {
      "description": "Rate limiting patterns for API calls",
      "tokenBucket": "import asyncio\nfrom collections import deque\nimport time\n\nclass RateLimiter:\n    def __init__(self, calls_per_second: float):\n        self.calls_per_second = calls_per_second\n        self.min_interval = 1.0 / calls_per_second\n        self.last_call = 0.0\n        self._lock = asyncio.Lock()\n    \n    async def acquire(self):\n        async with self._lock:\n            now = time.monotonic()\n            wait_time = self.last_call + self.min_interval - now\n            if wait_time > 0:\n                await asyncio.sleep(wait_time)\n            self.last_call = time.monotonic()\n\nrate_limiter = RateLimiter(calls_per_second=10)\n\nasync def rate_limited_call(url: str):\n    await rate_limiter.acquire()\n    return await fetch_data(url)",
      "adaptiveBackoff": "class AdaptiveRateLimiter:\n    def __init__(self, initial_rate: float = 10.0):\n        self.rate = initial_rate\n        self.min_rate = 1.0\n        self.max_rate = 100.0\n    \n    async def on_success(self):\n        self.rate = min(self.rate * 1.1, self.max_rate)\n    \n    async def on_rate_limit(self):\n        self.rate = max(self.rate * 0.5, self.min_rate)\n        await asyncio.sleep(60)  # Wait before retrying",
      "use_when": "Apply when implementing rateLimit in integration context",
      "code_example": "import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(url, timeout=30.0)\n    response.raise_for_status()\n    return response.json()",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for rateLimit",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "errorHandling": {
      "description": "Error handling patterns",
      "httpErrors": "from enum import Enum\n\nclass APIError(Exception):\n    def __init__(self, message: str, status_code: int, response: dict = None):\n        super().__init__(message)\n        self.status_code = status_code\n        self.response = response\n\nclass RateLimitError(APIError):\n    pass\n\nclass AuthenticationError(APIError):\n    pass\n\nasync def handle_response(response: httpx.Response) -> dict:\n    if response.status_code == 429:\n        retry_after = int(response.headers.get('Retry-After', 60))\n        raise RateLimitError(\n            f'Rate limited, retry after {retry_after}s',\n            429,\n            {'retry_after': retry_after}\n        )\n    elif response.status_code == 401:\n        raise AuthenticationError('Invalid credentials', 401)\n    elif response.status_code >= 400:\n        raise APIError(\n            f'API error: {response.text}',\n            response.status_code,\n            response.json() if response.text else None\n        )\n    return response.json()",
      "use_when": "Apply when implementing errorHandling in integration context",
      "code_example": "import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(url, timeout=30.0)\n    response.raise_for_status()\n    return response.json()",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for errorHandling",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "caching": {
      "description": "Response caching patterns",
      "redis": "import redis.asyncio as redis\nimport json\nfrom typing import Optional\n\nclass APICache:\n    def __init__(self, redis_url: str, default_ttl: int = 300):\n        self.redis = redis.from_url(redis_url)\n        self.default_ttl = default_ttl\n    \n    async def get(self, key: str) -> Optional[dict]:\n        data = await self.redis.get(f'api:{key}')\n        return json.loads(data) if data else None\n    \n    async def set(self, key: str, value: dict, ttl: int = None):\n        await self.redis.setex(\n            f'api:{key}',\n            ttl or self.default_ttl,\n            json.dumps(value)\n        )\n    \n    async def invalidate(self, pattern: str):\n        keys = await self.redis.keys(f'api:{pattern}')\n        if keys:\n            await self.redis.delete(*keys)",
      "use_when": "Apply when implementing caching in integration context",
      "code_example": "import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(url, timeout=30.0)\n    response.raise_for_status()\n    return response.json()",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for caching",
        "Validate implementation against domain requirements before deployment"
      ]
    }
  },
  "langchainIntegration": {
    "description": "LangChain tool integration for API calling",
    "httpTool": "from langchain_core.tools import tool\nfrom pydantic import BaseModel, Field\nimport httpx\n\nclass APICallInput(BaseModel):\n    url: str = Field(description='The URL to call')\n    method: str = Field(default='GET', description='HTTP method')\n    headers: dict = Field(default_factory=dict, description='Request headers')\n    body: dict = Field(default=None, description='Request body for POST/PUT')\n\n@tool\nasync def call_api(url: str, method: str = 'GET', headers: dict = None, body: dict = None) -> str:\n    \"\"\"Make an HTTP API call and return the response.\n    \n    Args:\n        url: The API endpoint URL\n        method: HTTP method (GET, POST, PUT, DELETE)\n        headers: Optional request headers\n        body: Optional request body for POST/PUT\n    \n    Returns:\n        JSON response as string\n    \"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.request(\n            method=method,\n            url=url,\n            headers=headers or {},\n            json=body\n        )\n        response.raise_for_status()\n        return response.text",
    "structuredTool": "from langchain_core.tools import StructuredTool\n\napi_tool = StructuredTool.from_function(\n    coroutine=call_api,\n    name='api_call',\n    description='Make HTTP API calls',\n    args_schema=APICallInput\n)",
    "use_when": "Apply when implementing langchainIntegration in integration context",
    "code_example": "import httpx\n\nasync with httpx.AsyncClient() as client:\n    response = await client.get(url, timeout=30.0)\n    response.raise_for_status()\n    return response.json()",
    "best_practices": [
      "Document the pattern usage and rationale in code comments for langchainIntegration",
      "Validate implementation against domain requirements before deployment"
    ]
  },
  "documentation": {
    "httpx": "https://www.python-httpx.org/",
    "gql": "https://gql.readthedocs.io/",
    "tenacity": "https://tenacity.readthedocs.io/",
    "circuitbreaker": "https://pypi.org/project/circuitbreaker/"
  },
  "best_practices": [
    "Always use async clients for I/O-bound API operations to avoid blocking",
    "Implement exponential backoff with jitter for retries to prevent thundering herd",
    "Use circuit breakers for external service calls to prevent cascade failures",
    "Cache responses when appropriate to reduce API calls and improve performance",
    "Validate webhook signatures before processing to ensure authenticity",
    "Implement idempotency for webhook handlers to handle duplicate deliveries",
    "Use rate limiters to respect API quotas and avoid being throttled",
    "Log all API calls with correlation IDs for debugging and tracing",
    "Handle pagination for large data sets to avoid memory issues",
    "Set appropriate timeouts for all requests (connection and read timeouts)",
    "Use structured error handling with custom exception types for different error scenarios",
    "Implement request/response logging with sanitization of sensitive data"
  ],
  "anti_patterns": [
    {
      "name": "No retry logic",
      "problem": "Transient failures cause complete failure",
      "fix": "Use tenacity with exponential backoff"
    },
    {
      "name": "Synchronous calls in async context",
      "problem": "Blocks event loop",
      "fix": "Use httpx.AsyncClient"
    },
    {
      "name": "No timeout",
      "problem": "Calls can hang indefinitely",
      "fix": "Always set connect and read timeouts"
    },
    {
      "name": "Hardcoded credentials",
      "problem": "Security risk",
      "fix": "Use environment variables"
    },
    {
      "name": "No rate limiting",
      "problem": "Can get blocked by APIs",
      "fix": "Implement token bucket rate limiter"
    }
  ]
}
