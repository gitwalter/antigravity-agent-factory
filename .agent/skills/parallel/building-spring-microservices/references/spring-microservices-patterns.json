{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "spring-microservices-patterns",
  "name": "Spring Microservices Patterns",
  "title": "Spring Microservices Architecture Patterns",
  "description": "Best practices and patterns for building microservices architectures with Spring Boot and Spring Cloud",
  "version": "1.0.0",
  "category": "java",
  "axiomAlignment": {
    "A1_verifiability": "Patterns include health checks, metrics, and distributed tracing for verification",
    "A2_user_primacy": "API gateway and service boundaries prioritize user-facing capabilities",
    "A3_transparency": "All patterns emphasize observability, logging, and distributed tracing",
    "A4_non_harm": "Circuit breaker and resilience patterns prevent cascading failures",
    "A5_consistency": "Unified Spring Cloud microservices architecture patterns"
  },
  "related_skills": [
    "building-spring-microservices",
    "developing-spring-boot",
    "observing-spring-apps",
    "docker-deployment",
    "kubernetes-deployment",
    "error-handling"
  ],
  "related_knowledge": [
    "spring-patterns.json",
    "spring-observability-patterns.json",
    "spring-kotlin-patterns.json",
    "docker-patterns.json",
    "kubernetes-deployment-patterns.json"
  ],
  "patterns": {
    "service_decomposition": {
      "description": "Breaking down monoliths into microservices",
      "strategies": {
        "business_capability": "Organize services by business function (e.g., Product Service, Order Service, Payment Service)",
        "domain_driven_design": "Use DDD bounded contexts to identify service boundaries",
        "data_ownership": "Each service owns its data - no shared databases",
        "team_structure": "Align service boundaries with team boundaries (Conway's Law)"
      },
      "principles": [
        "Single Responsibility Principle per service",
        "High cohesion within service, low coupling between services",
        "Independent deployment and scaling",
        "Technology diversity allowed per service",
        "API-first design",
        "Fail fast and degrade gracefully"
      ],
      "best_practices": [
        "Start with larger services, split as needed (don't over-microservice)",
        "Identify clear service boundaries using domain modeling",
        "Avoid shared databases - each service has its own",
        "Define clear API contracts with OpenAPI/Swagger",
        "Document service responsibilities and SLAs",
        "Use event-driven communication for loose coupling",
        "Implement idempotency for distributed operations"
      ],
      "use_when": "When building Java/Spring applications and need service decomposition",
      "code_example": "# Service Decomposition - implement per Java/Spring conventions"
    },
    "api_gateway": {
      "description": "Single entry point for client requests",
      "implementations": {
        "spring_cloud_gateway": {
          "description": "Spring Cloud Gateway - reactive API gateway",
          "features": [
            "Reactive routing",
            "Load balancing",
            "Circuit breaker integration",
            "Rate limiting",
            "Request/response transformation",
            "Health checks"
          ],
          "use_when": "Need reactive, Spring-native gateway",
          "example": "spring.cloud.gateway.routes with predicates and filters",
          "code_example": "# Spring Cloud Gateway\nspring.cloud.gateway.routes with predicates and filters",
          "best_practices": [
            "Follow spring cloud gateway best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "zuul": {
          "description": "Netflix Zuul (legacy, use Gateway instead)",
          "features": [
            "Routing",
            "Filtering",
            "Load balancing"
          ],
          "use_when": "Legacy systems only",
          "deprecated": true,
          "code_example": "# Zuul - implement per Java/Spring conventions",
          "best_practices": [
            "Follow zuul best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "kong": {
          "description": "Kong API Gateway. This pattern applies to Java/Spring and provides production-ready implementation guidance.",
          "features": [
            "Plugin ecosystem",
            "Rate limiting",
            "Authentication",
            "Analytics"
          ],
          "use_when": "Need advanced gateway features outside Spring ecosystem",
          "code_example": "# Kong - implement per Java/Spring conventions",
          "best_practices": [
            "Follow kong best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        }
      },
      "patterns": {
        "routing": "Route requests to appropriate backend services using predicates",
        "aggregation": "Combine multiple service responses into single response",
        "transformation": "Transform requests/responses (headers, body)",
        "authentication": "Centralized authentication and authorization",
        "rate_limiting": "Control request rate per client/service",
        "caching": "Cache responses to reduce backend load",
        "circuit_breaker": "Protect against downstream service failures",
        "retry": "Retry failed requests with exponential backoff"
      },
      "best_practices": [
        "Use Spring Cloud Gateway for Spring Boot applications",
        "Implement health checks for routing decisions",
        "Add correlation IDs for request tracing",
        "Implement request/response logging",
        "Use circuit breaker for downstream services",
        "Cache static responses",
        "Implement rate limiting per client",
        "Use load balancing for service instances"
      ],
      "use_when": "When building Java/Spring applications and need api gateway",
      "code_example": "# Api Gateway - implement per Java/Spring conventions"
    },
    "service_discovery": {
      "description": "Dynamic service location and registration",
      "implementations": {
        "eureka": {
          "description": "Netflix Eureka - service registry",
          "features": [
            "Service registration",
            "Service discovery",
            "Health checks",
            "Load balancing"
          ],
          "use_when": "Spring Cloud Netflix ecosystem",
          "configuration": "eureka.client.service-url.defaultZone",
          "code_example": "# Eureka - implement per Java/Spring conventions",
          "best_practices": [
            "Follow eureka best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "consul": {
          "description": "HashiCorp Consul - service mesh and discovery",
          "features": [
            "Service discovery",
            "Health checking",
            "Key-value store",
            "Multi-datacenter"
          ],
          "use_when": "Need service mesh features or multi-datacenter",
          "configuration": "spring.cloud.consul.host",
          "code_example": "# Consul - implement per Java/Spring conventions",
          "best_practices": [
            "Follow consul best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "kubernetes": {
          "description": "Kubernetes native service discovery",
          "features": [
            "DNS-based discovery",
            "Service labels",
            "Native K8s integration"
          ],
          "use_when": "Deploying to Kubernetes",
          "configuration": "Use K8s Service objects",
          "code_example": "# Kubernetes - implement per Java/Spring conventions",
          "best_practices": [
            "Follow kubernetes best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "zookeeper": {
          "description": "Apache Zookeeper for service discovery",
          "features": [
            "Distributed coordination",
            "Service registration"
          ],
          "use_when": "Existing Zookeeper infrastructure",
          "code_example": "# Zookeeper - implement per Java/Spring conventions",
          "best_practices": [
            "Follow zookeeper best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        }
      },
      "patterns": {
        "client_side_discovery": "Client queries service registry to find service instances",
        "server_side_discovery": "Load balancer queries registry and routes requests",
        "self_registration": "Service registers itself with registry",
        "third_party_registration": "Service registrar handles registration"
      },
      "best_practices": [
        "Use Eureka for Spring Cloud applications",
        "Implement health checks for service status",
        "Configure proper lease renewal intervals",
        "Use service names instead of hardcoded URLs",
        "Implement retry logic for service discovery",
        "Monitor service registry health",
        "Use Kubernetes Service discovery when on K8s"
      ],
      "use_when": "When building Java/Spring applications and need service discovery",
      "code_example": "# Service Discovery - implement per Java/Spring conventions"
    },
    "config_management": {
      "description": "Centralized configuration management",
      "implementations": {
        "spring_cloud_config": {
          "description": "Spring Cloud Config Server",
          "features": [
            "Centralized config",
            "Version control integration",
            "Environment-specific configs",
            "Refresh mechanism"
          ],
          "use_when": "Need centralized configuration",
          "configuration": "spring.cloud.config.uri",
          "code_example": "# Spring Cloud Config - implement per Java/Spring conventions",
          "best_practices": [
            "Follow spring cloud config best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "kubernetes_configmap": {
          "description": "Kubernetes ConfigMaps",
          "features": [
            "K8s native",
            "Environment variables",
            "Volume mounts"
          ],
          "use_when": "Deploying to Kubernetes",
          "configuration": "configMapRef in deployment",
          "code_example": "# Kubernetes Configmap - implement per Java/Spring conventions",
          "best_practices": [
            "Follow kubernetes configmap best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "vault": {
          "description": "HashiCorp Vault for secrets",
          "features": [
            "Secret management",
            "Dynamic secrets",
            "Encryption"
          ],
          "use_when": "Need advanced secret management",
          "configuration": "spring.cloud.vault.*",
          "code_example": "# Vault - implement per Java/Spring conventions",
          "best_practices": [
            "Follow vault best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        }
      },
      "patterns": {
        "centralized_config": "Single source of truth for configuration",
        "environment_specific": "Different configs per environment (dev, prod)",
        "refresh_mechanism": "@RefreshScope for dynamic config updates",
        "secret_management": "Secure storage of sensitive configuration",
        "version_control": "Config stored in Git repository"
      },
      "best_practices": [
        "Use Spring Cloud Config for centralized config",
        "Store config in version control (Git)",
        "Use @RefreshScope for dynamic updates",
        "Separate secrets from regular config",
        "Use environment-specific profiles",
        "Implement config encryption for sensitive data",
        "Monitor config server health",
        "Use Kubernetes ConfigMaps when on K8s"
      ],
      "use_when": "When building Java/Spring applications and need config management",
      "code_example": "# Config Management - implement per Java/Spring conventions"
    },
    "circuit_breaker": {
      "description": "Prevent cascading failures",
      "implementations": {
        "resilience4j": {
          "description": "Resilience4j - lightweight fault tolerance library",
          "features": [
            "Circuit breaker",
            "Retry",
            "Rate limiter",
            "Bulkhead",
            "Time limiter"
          ],
          "use_when": "Spring Boot 3+ applications",
          "configuration": "resilience4j.circuitbreaker.instances.*",
          "code_example": "# Resilience4J - implement per Java/Spring conventions",
          "best_practices": [
            "Follow resilience4j best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "spring_cloud_circuit_breaker": {
          "description": "Spring Cloud Circuit Breaker abstraction",
          "features": [
            "Multiple implementations",
            "Spring integration"
          ],
          "use_when": "Need abstraction over implementations",
          "providers": [
            "Resilience4j",
            "Sentinel"
          ],
          "code_example": "# Spring Cloud Circuit Breaker - implement per Java/Spring conventions",
          "best_practices": [
            "Follow spring cloud circuit breaker best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "hystrix": {
          "description": "Netflix Hystrix (deprecated)",
          "deprecated": true,
          "replacement": "Resilience4j",
          "use_when": "When building Java/Spring applications and need hystrix",
          "code_example": "# Hystrix - implement per Java/Spring conventions",
          "best_practices": [
            "Follow hystrix best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        }
      },
      "patterns": {
        "circuit_breaker": "Open circuit when failure threshold reached",
        "fallback": "Return default response when circuit is open",
        "retry": "Retry failed requests with exponential backoff",
        "timeout": "Fail fast when service doesn't respond",
        "bulkhead": "Isolate resources to prevent resource exhaustion"
      },
      "states": {
        "closed": "Normal operation, requests pass through",
        "open": "Circuit open, requests fail fast",
        "half_open": "Testing if service recovered, limited requests allowed"
      },
      "best_practices": [
        "Use Resilience4j for Spring Boot 3+",
        "Configure appropriate failure thresholds",
        "Implement fallback mechanisms",
        "Monitor circuit breaker metrics",
        "Use retry with circuit breaker",
        "Set proper timeout values",
        "Implement bulkhead pattern for resource isolation",
        "Log circuit state changes"
      ],
      "use_when": "When building Java/Spring applications and need circuit breaker",
      "code_example": "# Circuit Breaker - implement per Java/Spring conventions"
    },
    "distributed_tracing": {
      "description": "Track requests across service boundaries",
      "implementations": {
        "micrometer_tracing": {
          "description": "Micrometer Tracing - Spring-native tracing",
          "features": [
            "Multiple tracer support",
            "Spring integration",
            "Automatic instrumentation"
          ],
          "use_when": "Spring Boot 3+ applications",
          "configuration": "management.tracing.*",
          "code_example": "# Micrometer Tracing - implement per Java/Spring conventions",
          "best_practices": [
            "Follow micrometer tracing best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "zipkin": {
          "description": "Zipkin distributed tracing system",
          "features": [
            "Request tracing",
            "Dependency graph",
            "Timing analysis"
          ],
          "use_when": "Need distributed tracing visualization",
          "configuration": "management.zipkin.tracing.endpoint",
          "code_example": "# Zipkin - implement per Java/Spring conventions",
          "best_practices": [
            "Follow zipkin best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "jaeger": {
          "description": "Jaeger distributed tracing",
          "features": [
            "High performance",
            "OpenTelemetry support",
            "UI"
          ],
          "use_when": "Need high-performance tracing",
          "configuration": "management.tracing.export.jaeger.*",
          "code_example": "# Jaeger - implement per Java/Spring conventions",
          "best_practices": [
            "Follow jaeger best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "opentelemetry": {
          "description": "OpenTelemetry standard",
          "features": [
            "Vendor-neutral",
            "Multiple languages",
            "Standard APIs"
          ],
          "use_when": "Multi-language microservices",
          "configuration": "OpenTelemetry SDK",
          "code_example": "# Opentelemetry - implement per Java/Spring conventions",
          "best_practices": [
            "Follow opentelemetry best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        }
      },
      "patterns": {
        "trace": "Complete request path across services",
        "span": "Individual operation within a trace",
        "correlation_id": "Unique ID propagated across services",
        "baggage": "Context data propagated with trace",
        "sampling": "Reduce trace volume in high-throughput systems"
      },
      "best_practices": [
        "Use Micrometer Tracing with Spring Boot",
        "Propagate trace context across service calls",
        "Add custom spans for business operations",
        "Use correlation IDs in logs",
        "Configure appropriate sampling rates",
        "Monitor trace volume and performance",
        "Use Zipkin or Jaeger for visualization",
        "Add trace context to error messages"
      ],
      "use_when": "When building Java/Spring applications and need distributed tracing",
      "code_example": "# Distributed Tracing - implement per Java/Spring conventions"
    },
    "event_driven_architecture": {
      "description": "Loose coupling through events",
      "implementations": {
        "spring_cloud_stream": {
          "description": "Spring Cloud Stream - event-driven microservices",
          "features": [
            "Multiple binder support",
            "Declarative programming",
            "Consumer groups"
          ],
          "use_when": "Need event-driven communication",
          "binders": [
            "Kafka",
            "RabbitMQ",
            "Amazon Kinesis",
            "Google Pub/Sub"
          ],
          "code_example": "# Spring Cloud Stream - implement per Java/Spring conventions",
          "best_practices": [
            "Follow spring cloud stream best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "apache_kafka": {
          "description": "Apache Kafka - distributed event streaming",
          "features": [
            "High throughput",
            "Fault tolerance",
            "Replay capability",
            "Partitioning"
          ],
          "use_when": "Need high-throughput event streaming",
          "configuration": "spring.kafka.*",
          "code_example": "# Apache Kafka - implement per Java/Spring conventions",
          "best_practices": [
            "Follow apache kafka best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "rabbitmq": {
          "description": "RabbitMQ message broker",
          "features": [
            "Multiple exchange types",
            "Routing",
            "Reliability"
          ],
          "use_when": "Need flexible routing patterns",
          "configuration": "spring.rabbitmq.*",
          "code_example": "# Rabbitmq - implement per Java/Spring conventions",
          "best_practices": [
            "Follow rabbitmq best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        }
      },
      "patterns": {
        "event_sourcing": "Store state as sequence of events",
        "cqr": "Separate read and write models",
        "saga": "Distributed transaction pattern using events",
        "publish_subscribe": "One-to-many event distribution",
        "event_replay": "Replay events to rebuild state",
        "idempotency": "Handle duplicate events safely"
      },
      "best_practices": [
        "Use Spring Cloud Stream for abstraction",
        "Use Kafka for high-throughput scenarios",
        "Implement idempotent event handlers",
        "Use consumer groups for load balancing",
        "Implement event versioning",
        "Handle event ordering when needed",
        "Monitor event processing lag",
        "Implement dead letter queues for failed events",
        "Use schema registry for event schemas"
      ],
      "use_when": "When building Java/Spring applications and need event driven architecture",
      "code_example": "# Event Driven Architecture - implement per Java/Spring conventions"
    },
    "saga_pattern": {
      "description": "Manage distributed transactions",
      "implementations": {
        "orchestration": {
          "description": "Central orchestrator coordinates saga",
          "use_when": "Complex workflows, need centralized control",
          "example": "Saga orchestrator service coordinates all steps",
          "code_example": "# Orchestration\nSaga orchestrator service coordinates all steps",
          "best_practices": [
            "Follow orchestration best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "choreography": {
          "description": "Services coordinate through events",
          "use_when": "Simple workflows, prefer loose coupling",
          "example": "Each service publishes events, others react",
          "code_example": "# Choreography\nEach service publishes events, others react",
          "best_practices": [
            "Follow choreography best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        }
      },
      "patterns": {
        "compensating_transaction": "Undo previous operations on failure",
        "saga_step": "Individual operation in saga",
        "saga_coordinator": "Orchestrates saga execution",
        "compensation": "Rollback operation for each step"
      },
      "best_practices": [
        "Use orchestration for complex workflows",
        "Use choreography for simple workflows",
        "Implement idempotent compensation",
        "Log all saga steps for debugging",
        "Handle partial failures gracefully",
        "Set timeouts for saga steps",
        "Monitor saga completion rates"
      ],
      "use_when": "When building Java/Spring applications and need saga pattern",
      "code_example": "# Saga Pattern - implement per Java/Spring conventions"
    },
    "cqrs": {
      "description": "Command Query Responsibility Segregation",
      "patterns": {
        "command_side": "Write operations, optimized for writes",
        "query_side": "Read operations, optimized for reads",
        "event_store": "Store events for command side",
        "read_model": "Denormalized views for query side",
        "eventual_consistency": "Read model eventually syncs with write model"
      },
      "use_cases": [
        "High read/write ratio",
        "Different read and write requirements",
        "Need to scale reads independently",
        "Complex query requirements"
      ],
      "best_practices": [
        "Use CQRS when read/write patterns differ significantly",
        "Keep command and query models separate",
        "Use events to sync read models",
        "Accept eventual consistency",
        "Monitor read model lag",
        "Implement read model rebuild capability"
      ],
      "use_when": "High read/write ratio",
      "code_example": "# Cqrs - implement per Java/Spring conventions"
    },
    "api_versioning": {
      "description": "Manage API changes over time",
      "strategies": {
        "url_versioning": "Version in URL path (/api/v1/products)",
        "header_versioning": "Version in HTTP header (Accept: application/vnd.api.v1+json)",
        "query_parameter": "Version as query parameter (?version=1)",
        "content_negotiation": "Version via Accept header"
      },
      "best_practices": [
        "Use URL versioning for REST APIs",
        "Maintain backward compatibility when possible",
        "Deprecate old versions gradually",
        "Document versioning strategy",
        "Monitor version usage",
        "Plan version lifecycle"
      ],
      "use_when": "When building Java/Spring applications and need api versioning",
      "code_example": "# Api Versioning - implement per Java/Spring conventions"
    },
    "distributed_caching": {
      "description": "Cache data across service instances",
      "implementations": {
        "redis": {
          "description": "Redis distributed cache",
          "features": [
            "In-memory",
            "Pub/sub",
            "Data structures"
          ],
          "use_when": "Need distributed cache",
          "configuration": "spring.data.redis.*",
          "code_example": "# Redis - implement per Java/Spring conventions",
          "best_practices": [
            "Follow redis best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "hazelcast": {
          "description": "Hazelcast in-memory data grid",
          "features": [
            "Distributed",
            "In-memory",
            "Compute"
          ],
          "use_when": "Need in-memory data grid",
          "code_example": "# Hazelcast - implement per Java/Spring conventions",
          "best_practices": [
            "Follow hazelcast best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "caffeine": {
          "description": "Caffeine local cache",
          "features": [
            "High performance",
            "Local only"
          ],
          "use_when": "Single instance caching",
          "code_example": "# Caffeine - implement per Java/Spring conventions",
          "best_practices": [
            "Follow caffeine best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        }
      },
      "patterns": {
        "cache_aside": "Application manages cache",
        "write_through": "Write to cache and database",
        "write_behind": "Write to cache, async to database",
        "cache_invalidation": "Invalidate cache on updates"
      },
      "best_practices": [
        "Use Redis for distributed caching",
        "Implement cache invalidation strategy",
        "Set appropriate TTL values",
        "Monitor cache hit rates",
        "Use cache keys with service prefix",
        "Handle cache failures gracefully",
        "Consider cache warming on startup"
      ],
      "use_when": "When building Java/Spring applications and need distributed caching",
      "code_example": "# Distributed Caching - implement per Java/Spring conventions"
    },
    "service_mesh": {
      "description": "Infrastructure layer for service communication",
      "implementations": {
        "istio": {
          "description": "Istio service mesh. This pattern applies to Java/Spring and provides production-ready implementation guidance.",
          "features": [
            "Traffic management",
            "Security",
            "Observability"
          ],
          "use_when": "Kubernetes deployment, need advanced features",
          "code_example": "# Istio - implement per Java/Spring conventions",
          "best_practices": [
            "Follow istio best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        },
        "linkerd": {
          "description": "Linkerd service mesh",
          "features": [
            "Lightweight",
            "Easy setup",
            "Performance"
          ],
          "use_when": "Need simple, lightweight mesh",
          "code_example": "# Linkerd - implement per Java/Spring conventions",
          "best_practices": [
            "Follow linkerd best practices for your stack",
            "Validate and test the implementation before production use"
          ]
        }
      },
      "benefits": [
        "Traffic management without code changes",
        "Automatic mTLS",
        "Observability out of the box",
        "Policy enforcement"
      ],
      "best_practices": [
        "Consider service mesh for complex deployments",
        "Use Istio for Kubernetes",
        "Start with basic features",
        "Monitor mesh performance",
        "Use for cross-cutting concerns"
      ],
      "use_when": "When building Java/Spring applications and need service mesh",
      "code_example": "# Service Mesh - implement per Java/Spring conventions"
    }
  },
  "best_practices": [],
  "anti_patterns": []
}
