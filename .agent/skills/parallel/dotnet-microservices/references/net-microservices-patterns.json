{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "net-microservices-patterns",
  "name": ".NET Microservices Patterns",
  "title": ".NET Microservices Architecture Patterns",
  "description": "Best practices and patterns for building microservices architectures with .NET including API Gateway, service communication, and resilience",
  "version": "1.0.0",
  "category": "dotnet",
  "axiomAlignment": {
    "A1_verifiability": "Patterns include health checks and monitoring for verification",
    "A2_user_primacy": "Service decomposition and API design serve user capabilities",
    "A3_transparency": "All patterns emphasize observability and distributed tracing",
    "A4_non_harm": "Resilience patterns and circuit breakers prevent cascading failures",
    "A5_consistency": "Unified patterns across microservices ecosystem"
  },
  "related_skills": [
    "dotnet-microservices",
    "dotnet-backend",
    "azure-integration",
    "kubernetes-deployment"
  ],
  "related_knowledge": [
    "dotnet-patterns.json",
    "dotnet-auth-patterns.json",
    "azure-patterns.json"
  ],
  "patterns": {
    "service_decomposition": {
      "description": "Breaking down monoliths into microservices",
      "strategies": {
        "business_capability": "Organize by business function",
        "domain_driven_design": "Use DDD bounded contexts",
        "data_ownership": "Each service owns its data",
        "team_structure": "Align with team boundaries"
      },
      "principles": [
        "Single Responsibility Principle",
        "High cohesion, low coupling",
        "Independent deployment",
        "Technology diversity allowed"
      ],
      "best_practices": [
        "Start with larger services, split as needed",
        "Identify clear service boundaries",
        "Avoid shared databases",
        "Define clear API contracts",
        "Document service responsibilities"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "api_gateway": {
      "description": "Single entry point for client requests",
      "implementations": {
        "yarp": {
          "description": "Yet Another Reverse Proxy - Microsoft's reverse proxy",
          "features": [
            "Routing",
            "Load balancing",
            "Request/response transformation",
            "Health checks"
          ],
          "use_when": "Need lightweight, configurable gateway",
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);",
          "best_practices": [
            "Validate inputs and handle errors appropriately",
            "Document the pattern and when to use it"
          ]
        },
        "ocelot": {
          "description": "API Gateway for .NET",
          "features": [
            "Routing",
            "Authentication",
            "Rate limiting",
            "Caching"
          ],
          "use_when": "Need feature-rich gateway",
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);",
          "best_practices": [
            "Validate inputs and handle errors appropriately",
            "Document the pattern and when to use it"
          ]
        },
        "azure_api_management": {
          "description": "Managed API Gateway service",
          "features": [
            "Full API management",
            "Developer portal",
            "Analytics",
            "Policies"
          ],
          "use_when": "Need managed solution with enterprise features",
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);",
          "best_practices": [
            "Validate inputs and handle errors appropriately",
            "Document the pattern and when to use it"
          ]
        }
      },
      "patterns": {
        "routing": "Route requests to appropriate services",
        "aggregation": "Combine multiple service responses",
        "transformation": "Transform requests/responses",
        "authentication": "Centralized authentication",
        "rate_limiting": "Control request rate",
        "caching": "Cache responses"
      },
      "best_practices": [
        "Use YARP for simple routing needs",
        "Implement health checks for routing decisions",
        "Add correlation IDs for tracing",
        "Implement request/response logging",
        "Use circuit breaker for downstream services",
        "Cache static responses"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "service_communication_synchronous": {
      "description": "Request-response communication",
      "protocols": {
        "rest": {
          "description": "HTTP/REST APIs for synchronous request-response communication between services using standard HTTP methods and JSON.",
          "use_when": "Simple CRUD operations, web-friendly",
          "best_practices": [
            "Use HTTP/2 for better performance",
            "Implement proper HTTP status codes",
            "Use idempotent operations",
            "Version APIs properly"
          ],
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
        },
        "grpc": {
          "description": "High-performance RPC framework",
          "use_when": "High throughput, low latency needed",
          "benefits": [
            "HTTP/2",
            "Protocol Buffers",
            "Streaming",
            "Strong typing"
          ],
          "best_practices": [
            "Use for internal service communication",
            "Define clear service contracts",
            "Handle errors properly",
            "Use streaming for large data"
          ],
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
        }
      },
      "best_practices": [
        "Use gRPC for internal communication",
        "Use REST for external APIs",
        "Implement timeout policies",
        "Use circuit breaker pattern",
        "Add retry policies"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "service_communication_asynchronous": {
      "description": "Event-driven communication",
      "patterns": {
        "message_bus": {
          "description": "Central message broker",
          "implementations": [
            "Azure Service Bus",
            "RabbitMQ",
            "Apache Kafka"
          ],
          "use_when": "Loose coupling, high throughput",
          "best_practices": [
            "Use topics for pub/sub",
            "Use queues for point-to-point",
            "Implement idempotency",
            "Handle dead letter queues",
            "Use message versioning"
          ],
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
        },
        "event_sourcing": {
          "description": "Store events instead of state",
          "use_when": "Audit trail important, complex domain",
          "benefits": [
            "Complete audit trail",
            "Time travel",
            "Event replay"
          ],
          "challenges": [
            "Complexity",
            "Eventual consistency"
          ],
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);",
          "best_practices": [
            "Validate inputs and handle errors appropriately",
            "Document the pattern and when to use it"
          ]
        },
        "saga_pattern": {
          "description": "Manage distributed transactions",
          "types": [
            "Choreography",
            "Orchestration"
          ],
          "use_when": "Multi-step transactions across services",
          "best_practices": [
            "Use orchestration for complex flows",
            "Implement compensation actions",
            "Handle failures gracefully",
            "Use idempotent operations"
          ],
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
        }
      },
      "best_practices": [
        "Prefer async messaging for loose coupling",
        "Use events for state changes",
        "Implement idempotency",
        "Handle message ordering when needed",
        "Use correlation IDs for tracing"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "data_management_database_per_service": {
      "description": "Each service has its own database",
      "benefits": [
        "Independence",
        "Technology choice",
        "Scalability"
      ],
      "challenges": [
        "Data consistency",
        "Transactions"
      ],
      "best_practices": [
        "Never share databases",
        "Use appropriate database type",
        "Implement data synchronization patterns",
        "Handle eventual consistency"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "data_management_distributed_transactions": {
      "description": "Transactions across multiple services",
      "patterns": {
        "saga": "Distributed transaction pattern",
        "two_phase_commit": "Avoid in microservices",
        "eventual_consistency": "Accept temporary inconsistency"
      },
      "best_practices": [
        "Avoid distributed transactions",
        "Use saga pattern when needed",
        "Design for eventual consistency",
        "Implement compensation logic"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "data_management_data_synchronization": {
      "description": "Keep data synchronized across services",
      "patterns": {
        "event_driven": "Publish events on data changes",
        "api_composition": "Aggregate data from multiple services",
        "cqrs": "Separate read and write models"
      },
      "best_practices": [
        "Use events for data synchronization",
        "Implement CQRS for complex queries",
        "Use read models for queries",
        "Handle synchronization failures"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "resilience_patterns_circuit_breaker": {
      "description": "Prevent cascading failures",
      "implementation": "Polly library",
      "states": [
        "Closed",
        "Open",
        "Half-Open"
      ],
      "best_practices": [
        "Configure appropriate thresholds",
        "Monitor circuit state",
        "Implement fallback mechanisms",
        "Log state changes"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "resilience_patterns_retry": {
      "description": "Retry failed operations",
      "strategies": [
        "Exponential backoff",
        "Jitter",
        "Max retries"
      ],
      "best_practices": [
        "Use exponential backoff",
        "Distinguish transient vs permanent failures",
        "Set maximum retry count",
        "Log retry attempts"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "resilience_patterns_bulkhead": {
      "description": "Isolate resources Th",
      "implementation": "Separate thread pools, connection pools",
      "use_when": "Need to isolate critical operations",
      "best_practices": [
        "Separate critical and non-critical",
        "Use dedicated resources",
        "Monitor resource usage"
      ],
      "code_example": "Separate thread pools, connection pools"
    },
    "resilience_patterns_timeout": {
      "description": "Set timeouts for operations",
      "best_practices": [
        "Set appropriate timeouts",
        "Use cancellation tokens",
        "Handle timeout errors gracefully",
        "Log timeout occurrences"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "distributed_caching": {
      "description": "Cache data across services",
      "implementations": {
        "redis": {
          "description": "In-memory data store",
          "use_when": "Need distributed cache",
          "features": [
            "High performance",
            "Persistence options",
            "Pub/sub"
          ],
          "best_practices": [
            "Use for frequently accessed data",
            "Set appropriate expiration",
            "Handle cache failures",
            "Monitor cache hit ratio"
          ],
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
        },
        "in_memory": {
          "description": "Application-level cache",
          "use_when": "Single instance, non-distributed",
          "limitations": "Not shared across instances",
          "code_example": "set_llm_cache(SQLiteCache(database_path='.langchain.db'))\nllm = ChatOpenAI(model='gpt-4o')\nresponse = llm.invoke('query')  # Cached",
          "best_practices": [
            "Validate inputs and handle errors appropriately",
            "Document the pattern and when to use it"
          ]
        }
      },
      "patterns": {
        "cache_aside": "Application manages cache",
        "write_through": "Write to cache and database",
        "write_behind": "Write to cache, async to database"
      },
      "best_practices": [
        "Use Redis for distributed caching",
        "Implement cache invalidation",
        "Handle cache failures gracefully",
        "Set appropriate expiration times",
        "Monitor cache performance"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "set_llm_cache(SQLiteCache(database_path='.langchain.db'))\nllm = ChatOpenAI(model='gpt-4o')\nresponse = llm.invoke('query')  # Cached"
    },
    "service_discovery": {
      "description": "Discover service instances",
      "patterns": {
        "client_side": "Client queries registry",
        "server_side": "Load balancer queries registry",
        "service_registry": "Central registry (Consul, Eureka)"
      },
      "implementations": {
        "azure_service_fabric": "Built-in service discovery",
        "kubernetes": "DNS-based discovery",
        "consul": "Service registry and discovery",
        "eureka": "Netflix service discovery"
      },
      "best_practices": [
        "Use DNS for simple scenarios",
        "Implement health checks",
        "Handle service unavailability",
        "Cache service locations"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "observability_distributed_tracing": {
      "description": "Track requests across services",
      "implementations": [
        "OpenTelemetry",
        "Application Insights",
        "Jaeger"
      ],
      "best_practices": [
        "Use correlation IDs",
        "Propagate trace context",
        "Instrument all services",
        "Use structured logging"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "observability_logging": {
      "description": "Centralized logging for distributed tracing, correlation IDs, and structured log aggregation across microservices.",
      "tools": [
        "Application Insights",
        "ELK Stack",
        "Seq",
        "Serilog"
      ],
      "best_practices": [
        "Use structured logging",
        "Include correlation IDs",
        "Log at appropriate levels",
        "Centralize logs"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "observability_metrics": {
      "description": "Collect and monitor metrics",
      "types": [
        "Performance",
        "Business",
        "Infrastructure"
      ],
      "tools": [
        "Application Insights",
        "Prometheus",
        "Grafana"
      ],
      "best_practices": [
        "Define key metrics",
        "Monitor service health",
        "Set up alerts",
        "Track business metrics"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "observability_health_checks": {
      "description": "Monitor service health",
      "checks": [
        "Self",
        "Dependencies",
        "Database",
        "External APIs"
      ],
      "best_practices": [
        "Implement comprehensive health checks",
        "Use different endpoints for readiness/liveness",
        "Check all dependencies",
        "Return detailed health status"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "security_authentication": {
      "description": "Verify service identity",
      "methods": [
        "JWT tokens",
        "API keys",
        "mTLS",
        "OAuth 2.0"
      ],
      "best_practices": [
        "Use JWT for service-to-service",
        "Validate tokens on every request",
        "Use short-lived tokens",
        "Implement token refresh"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "dotnet ef migrations add AddUserTable\ndotnet ef database update\nvar users = await context.Users.Where(u => u.IsActive).ToListAsync();"
    },
    "security_authorization": {
      "description": "Control access to resources",
      "patterns": [
        "Role-based",
        "Policy-based",
        "Resource-based"
      ],
      "best_practices": [
        "Implement at API Gateway",
        "Use policies for complex rules",
        "Validate permissions",
        "Log authorization decisions"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "security_network_security": {
      "description": "Secure network communication",
      "patterns": [
        "mTLS",
        "Private networks",
        "VPN",
        "Service mesh"
      ],
      "best_practices": [
        "Use mTLS for service-to-service",
        "Isolate services in private networks",
        "Implement network policies",
        "Monitor network traffic"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "deployment_containerization": {
      "description": "Package services in containers",
      "best_practices": [
        "Use multi-stage builds",
        "Optimize image size",
        "Scan for vulnerabilities",
        "Use specific tags"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "FROM node:18-alpine\nWORKDIR /app\nCOPY . .\nRUN npm ci\nCMD [\"node\", \"dist/index.js\"]"
    },
    "deployment_orchestration": {
      "description": "Manage containerized services",
      "platforms": [
        "Kubernetes",
        "Azure Container Apps",
        "Docker Swarm"
      ],
      "best_practices": [
        "Use container orchestrator",
        "Configure health checks",
        "Implement rolling updates",
        "Set resource limits"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "FROM node:18-alpine\nWORKDIR /app\nCOPY . .\nRUN npm ci\nCMD [\"node\", \"dist/index.js\"]"
    },
    "deployment_ci_cd": {
      "description": "Automated deployment",
      "best_practices": [
        "Automate builds and tests",
        "Deploy independently",
        "Use blue-green deployments",
        "Implement rollback procedures"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: app\n        image: myapp:latest"
    }
  },
  "best_practices": [
    "Keep services small and focused on single business capability",
    "Use API Gateway (YARP) for routing and cross-cutting concerns",
    "Prefer async messaging for loose coupling",
    "Use gRPC for high-performance synchronous communication",
    "Implement circuit breakers to prevent cascading failures",
    "Use distributed caching (Redis) to reduce database load",
    "Implement health checks for all services",
    "Use correlation IDs for distributed tracing",
    "Implement idempotency for message processing",
    "Never share databases across services",
    "Design for eventual consistency",
    "Use saga pattern for distributed transactions",
    "Implement comprehensive observability (logging, tracing, metrics)",
    "Use managed identity for service-to-service authentication",
    "Deploy services independently",
    "Monitor service dependencies and health"
  ],
  "anti_patterns": [],
  "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
  "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
}
