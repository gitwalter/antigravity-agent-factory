{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "kotlin-idioms",
  "name": "Kotlin Idioms",
  "title": "Kotlin Idioms",
  "description": "Idiomatic Kotlin patterns including data classes, sealed classes, coroutines, extension functions, DSL builders, and null safety",
  "version": "1.0.0",
  "last_updated": "2026-02-10",
  "category": "java",
  "axiomAlignment": {
    "A1_verifiability": "Null safety and sealed classes enable compile-time verification",
    "A2_user_primacy": "Idiomatic patterns prioritize developer ergonomics and clarity",
    "A3_transparency": "Explicit null handling and exhaustive when provide transparent control flow",
    "A4_non_harm": "Immutable data classes and safe coroutine scope prevent unintended side effects",
    "A5_consistency": "Unified Kotlin idioms across application layers"
  },
  "related_skills": [
    "developing-spring-boot",
    "bdd",
    "test-translation"
  ],
  "related_knowledge": [
    "spring-kotlin-patterns.json",
    "coroutines-patterns.json",
    "kotest-patterns.json"
  ],
  "patterns": {
    "data_classes_description": {
      "description": "Immutable value objects with auto-generated equals, hashCode, toString, copy",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# data_classes_description pattern for kotlin-idioms\n# Implement based on description: Immutable value objects with auto-generated equals...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "data_classes_idiom": {
      "description": "data class User(val id: Long, val name: String, val email: String)",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# data_classes_idiom pattern for kotlin-idioms\n# Implement based on description: data class User(val id: Long, val name: String, va...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "data_classes_when_to_use": {
      "description": "DTOs, domain models, configuration, API responses",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# data_classes_when_to_use pattern for kotlin-idioms\n# Implement based on description: DTOs, domain models, configuration, API responses...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "data_classes_best_practices": {
      "description": "['Prefer val over var', 'Use for immutable data', 'Leverage copy() for updates', 'Avoid logic in data classes']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "sealed_classes_description": {
      "description": "Restricted class hierarchies; exhaustive when expressions",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# sealed_classes_description pattern for kotlin-idioms\n# Implement based on description: Restricted class hierarchies; exhaustive when expr...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "sealed_classes_idiom": {
      "description": "sealed class Result<out T> { data class Success<T>(val data: T) : Result<T>(); data class Error(val message: String) : Result<Nothing>() }",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# sealed_classes_idiom pattern for kotlin-idioms\n# Implement based on description: sealed class Result<out T> { data class Success<T>...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "sealed_classes_when_to_use": {
      "description": "State machines, expression types, API responses, command/event hierarchies",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# sealed_classes_when_to_use pattern for kotlin-idioms\n# Implement based on description: State machines, expression types, API responses, c...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "sealed_classes_best_practices": {
      "description": "['Use when for exhaustive handling', 'Prefer sealed interfaces in Kotlin 1.5+', 'Keep sealed hierarchy in same file']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "coroutines_description": {
      "description": "Lightweight concurrency with suspend functions and structured concurrency",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# coroutines_description pattern for kotlin-idioms\n# Implement based on description: Lightweight concurrency with suspend functions and...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "coroutines_idiom": {
      "description": "suspend fun fetchUser(): User = withContext(Dispatchers.IO) { api.getUser() }",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# coroutines_idiom pattern for kotlin-idioms\n# Implement based on description: suspend fun fetchUser(): User = withContext(Dispat...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "coroutines_when_to_use": {
      "description": "Async I/O, background work, reactive streams",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# coroutines_when_to_use pattern for kotlin-idioms\n# Implement based on description: Async I/O, background work, reactive streams...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "coroutines_best_practices": {
      "description": "['Use suspend functions for async', 'Prefer coroutineScope over GlobalScope', 'Inject Dispatchers for testing']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "extension_functions_description": {
      "description": "Add functions to existing classes without inheritance",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# extension_functions_description pattern for kotlin-idioms\n# Implement based on description: Add functions to existing classes without inherita...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "extension_functions_idiom": {
      "description": "fun String.isValidEmail(): Boolean = this.contains(\"@\") && this.contains(\".\")",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# extension_functions_idiom pattern for kotlin-idioms\n# Implement based on description: fun String.isValidEmail(): Boolean = this.contains...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "extension_functions_when_to_use": {
      "description": "Utility functions, DSL building, API enhancement",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# extension_functions_when_to_use pattern for kotlin-idioms\n# Implement based on description: Utility functions, DSL building, API enhancement...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "extension_functions_best_practices": {
      "description": "['Keep extensions focused', 'Use receiver for context', 'Prefer extension over wrapper when possible']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "dsl_builders_description": {
      "description": "Type-safe builder patterns with lambda receivers",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# dsl_builders_description pattern for kotlin-idioms\n# Implement based on description: Type-safe builder patterns with lambda receivers...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "dsl_builders_idiom": {
      "description": "fun html(block: HTML.() -> Unit): HTML { val html = HTML(); html.block(); return html }",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# dsl_builders_idiom pattern for kotlin-idioms\n# Implement based on description: fun html(block: HTML.() -> Unit): HTML { val html ...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "dsl_builders_when_to_use": {
      "description": "Configuration, HTML/XML builders, test setup, Gradle DSL",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# dsl_builders_when_to_use pattern for kotlin-idioms\n# Implement based on description: Configuration, HTML/XML builders, test setup, Grad...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "dsl_builders_best_practices": {
      "description": "['Use @DslMarker for scope control', 'Provide sensible defaults', 'Support nesting for hierarchy']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "null_safety_description": {
      "description": "Nullable types and safe calls; elvis operator and null coalescing",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# null_safety_description pattern for kotlin-idioms\n# Implement based on description: Nullable types and safe calls; elvis operator and ...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "null_safety_idiom": {
      "description": "val name = user?.profile?.name ?: \"Unknown\"",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# null_safety_idiom pattern for kotlin-idioms\n# Implement based on description: val name = user?.profile?.name ?: \"Unknown\"...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "null_safety_when_to_use": {
      "description": "All optional values, API boundaries, external data",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# null_safety_when_to_use pattern for kotlin-idioms\n# Implement based on description: All optional values, API boundaries, external data...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "null_safety_best_practices": {
      "description": "['Avoid !! unless necessary', 'Use elvis for defaults', 'Prefer requireNotNull/lazy for late init', 'Use let for null checks']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "scope_functions_description": {
      "description": "let, run, with, apply, also: execute block in context of object",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# scope_functions_description pattern for kotlin-idioms\n# Implement based on description: let, run, with, apply, also: execute block in cont...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "scope_functions_idiom": {
      "description": "user?.let { sendEmail(it.email) }; config.apply { timeout = 5000 }.connect()",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# scope_functions_idiom pattern for kotlin-idioms\n# Implement based on description: user?.let { sendEmail(it.email) }; config.apply { ...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "scope_functions_when_to_use": {
      "description": "Null-safe chains, object configuration, side effects",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# scope_functions_when_to_use pattern for kotlin-idioms\n# Implement based on description: Null-safe chains, object configuration, side effec...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "scope_functions_best_practices": {
      "description": "['let for null-safe chains', 'apply for builder-style config', 'avoid nesting scope functions deeply']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "destructuring_description": {
      "description": "Unpack data class or Pair into variables",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# destructuring_description pattern for kotlin-idioms\n# Implement based on description: Unpack data class or Pair into variables...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "destructuring_idiom": {
      "description": "val (name, age) = user; for ((key, value) in map) { }",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# destructuring_idiom pattern for kotlin-idioms\n# Implement based on description: val (name, age) = user; for ((key, value) in map) ...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "destructuring_when_to_use": {
      "description": "Returning multiple values, iterations, component extraction",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# destructuring_when_to_use pattern for kotlin-idioms\n# Implement based on description: Returning multiple values, iterations, component e...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "destructuring_best_practices": {
      "description": "['Use for data classes and Pairs', 'componentN for custom types', 'Avoid destructuring nullable types']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    }
  },
  "best_practices": [
    "Prefer val over var",
    "Use for immutable data",
    "Leverage copy() for updates",
    "Avoid logic in data classes",
    "Use when for exhaustive handling",
    "Prefer sealed interfaces in Kotlin 1.5+",
    "Keep sealed hierarchy in same file",
    "Use suspend functions for async"
  ],
  "anti_patterns": [
    "Applying patterns without understanding the underlying concepts",
    "Copy-pasting solutions without adapting to specific context",
    "Over-engineering simple problems with complex patterns"
  ]
}
