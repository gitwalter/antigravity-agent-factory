{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "net-microservices-patterns",
  "name": ".NET Microservices Patterns",
  "title": ".NET Microservices Architecture Patterns",
  "description": "Best practices and patterns for building microservices architectures with .NET",
  "version": "1.0.0",
  "category": "patterns",
  "axiomAlignment": {
    "A1_verifiability": "Patterns include health checks and monitoring for verification",
    "A3_transparency": "All patterns emphasize observability and distributed tracing"
  },
  "patterns": {
    "service_decomposition": {
      "description": "Breaking down monoliths into microservices",
      "strategies": {
        "business_capability": "Organize by business function",
        "domain_driven_design": "Use DDD bounded contexts",
        "data_ownership": "Each service owns its data",
        "team_structure": "Align with team boundaries"
      },
      "principles": [
        "Single Responsibility Principle",
        "High cohesion, low coupling",
        "Independent deployment",
        "Technology diversity allowed"
      ],
      "best_practices": [
        "Start with larger services, split as needed",
        "Identify clear service boundaries",
        "Avoid shared databases",
        "Define clear API contracts",
        "Document service responsibilities"
      ]
    },
    "api_gateway": {
      "description": "Single entry point for client requests",
      "implementations": {
        "yarp": {
          "description": "Yet Another Reverse Proxy - Microsoft's reverse proxy",
          "features": [
            "Routing",
            "Load balancing",
            "Request/response transformation",
            "Health checks"
          ],
          "use_when": "Need lightweight, configurable gateway"
        },
        "ocelot": {
          "description": "API Gateway for .NET",
          "features": [
            "Routing",
            "Authentication",
            "Rate limiting",
            "Caching"
          ],
          "use_when": "Need feature-rich gateway"
        },
        "azure_api_management": {
          "description": "Managed API Gateway service",
          "features": [
            "Full API management",
            "Developer portal",
            "Analytics",
            "Policies"
          ],
          "use_when": "Need managed solution with enterprise features"
        }
      },
      "patterns": {
        "routing": "Route requests to appropriate services",
        "aggregation": "Combine multiple service responses",
        "transformation": "Transform requests/responses",
        "authentication": "Centralized authentication",
        "rate_limiting": "Control request rate",
        "caching": "Cache responses"
      },
      "best_practices": [
        "Use YARP for simple routing needs",
        "Implement health checks for routing decisions",
        "Add correlation IDs for tracing",
        "Implement request/response logging",
        "Use circuit breaker for downstream services",
        "Cache static responses"
      ]
    },
    "service_communication": {
      "synchronous": {
        "description": "Request-response communication",
        "protocols": {
          "rest": {
            "description": "HTTP/REST APIs",
            "use_when": "Simple CRUD operations, web-friendly",
            "best_practices": [
              "Use HTTP/2 for better performance",
              "Implement proper HTTP status codes",
              "Use idempotent operations",
              "Version APIs properly"
            ]
          },
          "grpc": {
            "description": "High-performance RPC framework",
            "use_when": "High throughput, low latency needed",
            "benefits": [
              "HTTP/2",
              "Protocol Buffers",
              "Streaming",
              "Strong typing"
            ],
            "best_practices": [
              "Use for internal service communication",
              "Define clear service contracts",
              "Handle errors properly",
              "Use streaming for large data"
            ]
          }
        },
        "best_practices": [
          "Use gRPC for internal communication",
          "Use REST for external APIs",
          "Implement timeout policies",
          "Use circuit breaker pattern",
          "Add retry policies"
        ]
      },
      "asynchronous": {
        "description": "Event-driven communication",
        "patterns": {
          "message_bus": {
            "description": "Central message broker",
            "implementations": [
              "Azure Service Bus",
              "RabbitMQ",
              "Apache Kafka"
            ],
            "use_when": "Loose coupling, high throughput",
            "best_practices": [
              "Use topics for pub/sub",
              "Use queues for point-to-point",
              "Implement idempotency",
              "Handle dead letter queues",
              "Use message versioning"
            ]
          },
          "event_sourcing": {
            "description": "Store events instead of state",
            "use_when": "Audit trail important, complex domain",
            "benefits": [
              "Complete audit trail",
              "Time travel",
              "Event replay"
            ],
            "challenges": [
              "Complexity",
              "Eventual consistency"
            ]
          },
          "saga_pattern": {
            "description": "Manage distributed transactions",
            "types": [
              "Choreography",
              "Orchestration"
            ],
            "use_when": "Multi-step transactions across services",
            "best_practices": [
              "Use orchestration for complex flows",
              "Implement compensation actions",
              "Handle failures gracefully",
              "Use idempotent operations"
            ]
          }
        },
        "best_practices": [
          "Prefer async messaging for loose coupling",
          "Use events for state changes",
          "Implement idempotency",
          "Handle message ordering when needed",
          "Use correlation IDs for tracing"
        ]
      }
    },
    "data_management": {
      "database_per_service": {
        "description": "Each service has its own database",
        "benefits": [
          "Independence",
          "Technology choice",
          "Scalability"
        ],
        "challenges": [
          "Data consistency",
          "Transactions"
        ],
        "best_practices": [
          "Never share databases",
          "Use appropriate database type",
          "Implement data synchronization patterns",
          "Handle eventual consistency"
        ]
      },
      "distributed_transactions": {
        "description": "Transactions across multiple services",
        "patterns": {
          "saga": "Distributed transaction pattern",
          "two_phase_commit": "Avoid in microservices",
          "eventual_consistency": "Accept temporary inconsistency"
        },
        "best_practices": [
          "Avoid distributed transactions",
          "Use saga pattern when needed",
          "Design for eventual consistency",
          "Implement compensation logic"
        ]
      },
      "data_synchronization": {
        "description": "Keep data synchronized across services",
        "patterns": {
          "event_driven": "Publish events on data changes",
          "api_composition": "Aggregate data from multiple services",
          "cqrs": "Separate read and write models"
        },
        "best_practices": [
          "Use events for data synchronization",
          "Implement CQRS for complex queries",
          "Use read models for queries",
          "Handle synchronization failures"
        ]
      }
    },
    "resilience_patterns": {
      "circuit_breaker": {
        "description": "Prevent cascading failures",
        "implementation": "Polly library",
        "states": [
          "Closed",
          "Open",
          "Half-Open"
        ],
        "best_practices": [
          "Configure appropriate thresholds",
          "Monitor circuit state",
          "Implement fallback mechanisms",
          "Log state changes"
        ]
      },
      "retry": {
        "description": "Retry failed operations",
        "strategies": [
          "Exponential backoff",
          "Jitter",
          "Max retries"
        ],
        "best_practices": [
          "Use exponential backoff",
          "Distinguish transient vs permanent failures",
          "Set maximum retry count",
          "Log retry attempts"
        ]
      },
      "bulkhead": {
        "description": "Isolate resources",
        "implementation": "Separate thread pools, connection pools",
        "use_when": "Need to isolate critical operations",
        "best_practices": [
          "Separate critical and non-critical",
          "Use dedicated resources",
          "Monitor resource usage"
        ]
      },
      "timeout": {
        "description": "Set timeouts for operations",
        "best_practices": [
          "Set appropriate timeouts",
          "Use cancellation tokens",
          "Handle timeout errors gracefully",
          "Log timeout occurrences"
        ]
      }
    },
    "distributed_caching": {
      "description": "Cache data across services",
      "implementations": {
        "redis": {
          "description": "In-memory data store",
          "use_when": "Need distributed cache",
          "features": [
            "High performance",
            "Persistence options",
            "Pub/sub"
          ],
          "best_practices": [
            "Use for frequently accessed data",
            "Set appropriate expiration",
            "Handle cache failures",
            "Monitor cache hit ratio"
          ]
        },
        "in_memory": {
          "description": "Application-level cache",
          "use_when": "Single instance, non-distributed",
          "limitations": "Not shared across instances"
        }
      },
      "patterns": {
        "cache_aside": "Application manages cache",
        "write_through": "Write to cache and database",
        "write_behind": "Write to cache, async to database"
      },
      "best_practices": [
        "Use Redis for distributed caching",
        "Implement cache invalidation",
        "Handle cache failures gracefully",
        "Set appropriate expiration times",
        "Monitor cache performance"
      ]
    },
    "service_discovery": {
      "description": "Discover service instances",
      "patterns": {
        "client_side": "Client queries registry",
        "server_side": "Load balancer queries registry",
        "service_registry": "Central registry (Consul, Eureka)"
      },
      "implementations": {
        "azure_service_fabric": "Built-in service discovery",
        "kubernetes": "DNS-based discovery",
        "consul": "Service registry and discovery",
        "eureka": "Netflix service discovery"
      },
      "best_practices": [
        "Use DNS for simple scenarios",
        "Implement health checks",
        "Handle service unavailability",
        "Cache service locations"
      ]
    },
    "observability": {
      "distributed_tracing": {
        "description": "Track requests across services",
        "implementations": [
          "OpenTelemetry",
          "Application Insights",
          "Jaeger"
        ],
        "best_practices": [
          "Use correlation IDs",
          "Propagate trace context",
          "Instrument all services",
          "Use structured logging"
        ]
      },
      "logging": {
        "description": "Centralized logging",
        "tools": [
          "Application Insights",
          "ELK Stack",
          "Seq",
          "Serilog"
        ],
        "best_practices": [
          "Use structured logging",
          "Include correlation IDs",
          "Log at appropriate levels",
          "Centralize logs"
        ]
      },
      "metrics": {
        "description": "Collect and monitor metrics",
        "types": [
          "Performance",
          "Business",
          "Infrastructure"
        ],
        "tools": [
          "Application Insights",
          "Prometheus",
          "Grafana"
        ],
        "best_practices": [
          "Define key metrics",
          "Monitor service health",
          "Set up alerts",
          "Track business metrics"
        ]
      },
      "health_checks": {
        "description": "Monitor service health",
        "checks": [
          "Self",
          "Dependencies",
          "Database",
          "External APIs"
        ],
        "best_practices": [
          "Implement comprehensive health checks",
          "Use different endpoints for readiness/liveness",
          "Check all dependencies",
          "Return detailed health status"
        ]
      }
    },
    "security": {
      "authentication": {
        "description": "Verify service identity",
        "methods": [
          "JWT tokens",
          "API keys",
          "mTLS",
          "OAuth 2.0"
        ],
        "best_practices": [
          "Use JWT for service-to-service",
          "Validate tokens on every request",
          "Use short-lived tokens",
          "Implement token refresh"
        ]
      },
      "authorization": {
        "description": "Control access to resources",
        "patterns": [
          "Role-based",
          "Policy-based",
          "Resource-based"
        ],
        "best_practices": [
          "Implement at API Gateway",
          "Use policies for complex rules",
          "Validate permissions",
          "Log authorization decisions"
        ]
      },
      "network_security": {
        "description": "Secure network communication",
        "patterns": [
          "mTLS",
          "Private networks",
          "VPN",
          "Service mesh"
        ],
        "best_practices": [
          "Use mTLS for service-to-service",
          "Isolate services in private networks",
          "Implement network policies",
          "Monitor network traffic"
        ]
      }
    },
    "deployment": {
      "containerization": {
        "description": "Package services in containers",
        "best_practices": [
          "Use multi-stage builds",
          "Optimize image size",
          "Scan for vulnerabilities",
          "Use specific tags"
        ]
      },
      "orchestration": {
        "description": "Manage containerized services",
        "platforms": [
          "Kubernetes",
          "Azure Container Apps",
          "Docker Swarm"
        ],
        "best_practices": [
          "Use container orchestrator",
          "Configure health checks",
          "Implement rolling updates",
          "Set resource limits"
        ]
      },
      "ci_cd": {
        "description": "Automated deployment",
        "best_practices": [
          "Automate builds and tests",
          "Deploy independently",
          "Use blue-green deployments",
          "Implement rollback procedures"
        ]
      }
    }
  },
  "best_practices": [
    "Keep services small and focused on single business capability",
    "Use API Gateway (YARP) for routing and cross-cutting concerns",
    "Prefer async messaging for loose coupling",
    "Use gRPC for high-performance synchronous communication",
    "Implement circuit breakers to prevent cascading failures",
    "Use distributed caching (Redis) to reduce database load",
    "Implement health checks for all services",
    "Use correlation IDs for distributed tracing",
    "Implement idempotency for message processing",
    "Never share databases across services",
    "Design for eventual consistency",
    "Use saga pattern for distributed transactions",
    "Implement comprehensive observability (logging, tracing, metrics)",
    "Use managed identity for service-to-service authentication",
    "Deploy services independently",
    "Monitor service dependencies and health"
  ],
  "anti_patterns": []
}