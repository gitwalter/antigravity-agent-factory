{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "react-component-patterns",
  "name": "React Component Patterns",
  "description": "Comprehensive patterns for building reusable, composable React components including compound components, render props, higher-order components, custom hooks, composition patterns, controlled/uncontrolled components, context patterns, error boundaries, and suspense patterns",
  "version": "1.0.0",
  "category": "patterns",
  "axiomAlignment": {
    "love": "Components designed with care for developer experience and user needs",
    "truth": "Patterns grounded in React best practices and proven solutions",
    "beauty": "Elegant, composable component architectures"
  },
  "patterns": {
    "compound-components": {
      "name": "Compound Components",
      "description": "Components that work together to form a complete UI, sharing implicit state through context",
      "useCase": "Building complex UI components like Accordion, Tabs, Modal, Select",
      "example": "Accordion with AccordionItem children sharing open/close state",
      "benefits": [
        "Flexible API",
        "Implicit state sharing",
        "Better composition"
      ],
      "tradeoffs": [
        "More complex setup",
        "Requires context"
      ]
    },
    "render-props": {
      "name": "Render Props",
      "description": "Pattern where a component accepts a function as children that receives state/data",
      "useCase": "Sharing logic between components before hooks existed",
      "example": "DataFetcher component with children as function",
      "benefits": [
        "Flexible",
        "Reusable logic"
      ],
      "tradeoffs": [
        "Less readable than hooks",
        "Nested callbacks"
      ]
    },
    "custom-hooks": {
      "name": "Custom Hooks",
      "description": "Extract and reuse stateful logic in custom hooks",
      "useCase": "Reusable logic like data fetching, form handling, localStorage",
      "example": "useLocalStorage, useDebounce, useFetch",
      "benefits": [
        "Clean API",
        "Reusable",
        "Testable"
      ],
      "tradeoffs": [
        "Requires hooks knowledge"
      ]
    },
    "higher-order-components": {
      "name": "Higher-Order Components",
      "description": "Functions that take a component and return a new component with enhanced functionality",
      "useCase": "Cross-cutting concerns like authentication, logging, error handling",
      "example": "withAuth, withErrorBoundary",
      "benefits": [
        "Reusable enhancement logic"
      ],
      "tradeoffs": [
        "Less intuitive than hooks",
        "Wrapper hell"
      ]
    },
    "controlled-components": {
      "name": "Controlled Components",
      "description": "Components where React controls the value via props",
      "useCase": "Forms, inputs where you need full control",
      "example": "Input with value and onChange props",
      "benefits": [
        "Full control",
        "Predictable",
        "Easy to validate"
      ],
      "tradeoffs": [
        "More boilerplate"
      ]
    },
    "uncontrolled-components": {
      "name": "Uncontrolled Components",
      "description": "Components that manage their own state internally using refs",
      "useCase": "Simple forms, file inputs, when you don't need to control value",
      "example": "Input with defaultValue and ref",
      "benefits": [
        "Less boilerplate",
        "Better performance"
      ],
      "tradeoffs": [
        "Less control",
        "Harder to validate"
      ]
    },
    "context-pattern": {
      "name": "Context Pattern",
      "description": "Share data across component tree without prop drilling",
      "useCase": "Theme, authentication, language, global state",
      "example": "ThemeContext, AuthContext",
      "benefits": [
        "Avoids prop drilling",
        "Global access"
      ],
      "tradeoffs": [
        "Can cause unnecessary re-renders",
        "Harder to trace"
      ]
    },
    "error-boundaries": {
      "name": "Error Boundaries",
      "description": "Components that catch JavaScript errors in child component tree",
      "useCase": "Graceful error handling, fallback UI",
      "example": "ErrorBoundary component with componentDidCatch",
      "benefits": [
        "Prevents app crashes",
        "Better UX"
      ],
      "tradeoffs": [
        "Only catches render errors",
        "Class components only"
      ]
    },
    "suspense-pattern": {
      "name": "Suspense Pattern",
      "description": "Declarative way to handle loading states and async operations",
      "useCase": "Data fetching, code splitting, lazy loading",
      "example": "Suspense with fallback for async components",
      "benefits": [
        "Declarative",
        "Better UX",
        "Streaming support"
      ],
      "tradeoffs": [
        "Requires React 18+",
        "Async component support"
      ]
    },
    "composition-pattern": {
      "name": "Composition Pattern",
      "description": "Building complex UIs by composing smaller components",
      "useCase": "All component design",
      "example": "Card component with title, content, footer slots",
      "benefits": [
        "Flexible",
        "Reusable",
        "Maintainable"
      ],
      "tradeoffs": [
        "Requires good design"
      ]
    },
    "polymorphic-components": {
      "name": "Polymorphic Components",
      "description": "Components that can render as different HTML elements",
      "useCase": "Design system components, flexible UI primitives",
      "example": "Button that can render as button, a, or div",
      "benefits": [
        "Flexible",
        "Type-safe"
      ],
      "tradeoffs": [
        "More complex types"
      ]
    },
    "slot-pattern": {
      "name": "Slot Pattern",
      "description": "Components that accept multiple named children/slots",
      "useCase": "Layout components, cards, modals",
      "example": "Layout with header, sidebar, main, footer slots",
      "benefits": [
        "Flexible API",
        "Clear structure"
      ],
      "tradeoffs": [
        "More props to manage"
      ]
    },
    "provider-pattern": {
      "name": "Provider Pattern",
      "description": "Components that provide context/value to children",
      "useCase": "Theme providers, state management, configuration",
      "example": "ThemeProvider, QueryClientProvider",
      "benefits": [
        "Centralized configuration",
        "Easy to use"
      ],
      "tradeoffs": [
        "Can cause re-renders"
      ]
    },
    "containerpresentational-pattern": {
      "name": "Container/Presentational Pattern",
      "description": "Separate components into containers (logic) and presentational (UI)",
      "useCase": "Separation of concerns, testability",
      "example": "UserListContainer fetches data, UserList renders UI",
      "benefits": [
        "Separation of concerns",
        "Testable",
        "Reusable UI"
      ],
      "tradeoffs": [
        "More files",
        "Can be overkill"
      ]
    },
    "headless-components": {
      "name": "Headless Components",
      "description": "Components that provide logic without UI, letting you style them",
      "useCase": "Reusable logic with custom styling",
      "example": "useCombobox hook from Headless UI",
      "benefits": [
        "Flexible styling",
        "Reusable logic"
      ],
      "tradeoffs": [
        "Requires styling"
      ]
    },
    "render-optimization-pattern": {
      "name": "Render Optimization Pattern",
      "description": "Using React.memo, useMemo, useCallback to prevent unnecessary re-renders",
      "useCase": "Performance optimization, expensive components",
      "example": "Memoized ProductCard component",
      "benefits": [
        "Better performance",
        "Fewer re-renders"
      ],
      "tradeoffs": [
        "Can be premature optimization",
        "More complexity"
      ]
    }
  },
  "best_practices": [
    "Prefer composition over inheritance",
    "Use custom hooks for reusable logic",
    "Keep components small and focused",
    "Use TypeScript for type safety",
    "Test components in isolation",
    "Document component APIs",
    "Follow accessibility guidelines",
    "Optimize renders when needed"
  ],
  "anti_patterns": [
    "Prop drilling through many levels",
    "Overusing context for local state",
    "Creating god components",
    "Premature optimization",
    "Ignoring accessibility",
    "Not handling loading/error states"
  ]
}