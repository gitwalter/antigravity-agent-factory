{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "frontend-performance-patterns",
  "name": "Frontend Performance Patterns",
  "description": "Performance optimization patterns including Core Web Vitals (LCP, FID, CLS), code splitting, tree shaking, lazy loading, image/font optimization, caching strategies (ISR, SWR), bundle analysis, React profiler, and Lighthouse automation",
  "version": "1.0.0",
  "category": "patterns",
  "axiomAlignment": {
    "love": "Fast, responsive experiences that delight users",
    "truth": "Patterns based on web performance best practices and Core Web Vitals",
    "beauty": "Elegant optimization techniques that maintain code quality"
  },
  "patterns": {
    "largest-contentful-paint-lcp-optimization": {
      "name": "Largest Contentful Paint (LCP) Optimization",
      "description": "Optimize the largest content element to load quickly",
      "useCase": "Hero images, main content, above-the-fold content",
      "example": "Priority images, preload critical resources, optimize server response",
      "benefits": [
        "Better perceived performance",
        "Improved SEO"
      ],
      "tradeoffs": [
        "Requires optimization effort"
      ]
    },
    "first-input-delay-fid-optimization": {
      "name": "First Input Delay (FID) Optimization",
      "description": "Minimize delay before user interaction is processed",
      "useCase": "Interactive elements, forms, buttons",
      "example": "Code splitting, defer non-critical JS, use React.startTransition",
      "benefits": [
        "Responsive UI",
        "Better UX"
      ],
      "tradeoffs": [
        "Requires careful code organization"
      ]
    },
    "cumulative-layout-shift-cls-prevention": {
      "name": "Cumulative Layout Shift (CLS) Prevention",
      "description": "Prevent unexpected layout shifts",
      "useCase": "Images, dynamic content, fonts",
      "example": "Reserve space for images, use aspect-ratio, preload fonts",
      "benefits": [
        "Stable layout",
        "Better UX"
      ],
      "tradeoffs": [
        "Requires planning"
      ]
    },
    "code-splitting": {
      "name": "Code Splitting",
      "description": "Split code into smaller chunks loaded on demand",
      "useCase": "Route-based splitting, component lazy loading",
      "example": "dynamic() imports, React.lazy, route-based chunks",
      "benefits": [
        "Smaller initial bundle",
        "Faster initial load"
      ],
      "tradeoffs": [
        "More HTTP requests",
        "Loading states needed"
      ]
    },
    "tree-shaking": {
      "name": "Tree Shaking",
      "description": "Remove unused code from bundle",
      "useCase": "All production builds",
      "example": "ES modules, proper imports, library configuration",
      "benefits": [
        "Smaller bundles",
        "Better performance"
      ],
      "tradeoffs": [
        "Requires proper module setup"
      ]
    },
    "lazy-loading": {
      "name": "Lazy Loading",
      "description": "Load resources only when needed",
      "useCase": "Images, components, routes",
      "example": "Intersection Observer, dynamic imports, loading='lazy'",
      "benefits": [
        "Faster initial load",
        "Reduced bandwidth"
      ],
      "tradeoffs": [
        "Loading delay when needed"
      ]
    },
    "image-optimization": {
      "name": "Image Optimization",
      "description": "Optimize images for web delivery",
      "useCase": "All images",
      "example": "Next.js Image component, WebP/AVIF, responsive images",
      "benefits": [
        "Smaller file sizes",
        "Better performance",
        "Better UX"
      ],
      "tradeoffs": [
        "Requires setup"
      ]
    },
    "font-optimization": {
      "name": "Font Optimization",
      "description": "Optimize web fonts for performance",
      "useCase": "Custom fonts",
      "example": "next/font, font-display: swap, preload critical fonts",
      "benefits": [
        "Faster font loading",
        "No layout shift"
      ],
      "tradeoffs": [
        "Requires configuration"
      ]
    },
    "incremental-static-regeneration-isr": {
      "name": "Incremental Static Regeneration (ISR)",
      "description": "Update static pages incrementally",
      "useCase": "Content that changes periodically",
      "example": "revalidate: 3600 for hourly updates",
      "benefits": [
        "Fast static pages",
        "Fresh content"
      ],
      "tradeoffs": [
        "Stale data during revalidation"
      ]
    },
    "stale-while-revalidate-swr": {
      "name": "Stale-While-Revalidate (SWR)",
      "description": "Show stale data while fetching fresh data",
      "useCase": "Data that can be stale briefly",
      "example": "SWR library, React Query staleTime",
      "benefits": [
        "Instant UI updates",
        "Fresh data in background"
      ],
      "tradeoffs": [
        "Can show stale data"
      ]
    },
    "bundle-analysis": {
      "name": "Bundle Analysis",
      "description": "Analyze bundle size and composition",
      "useCase": "Performance optimization, identifying large dependencies",
      "example": "@next/bundle-analyzer, webpack-bundle-analyzer",
      "benefits": [
        "Identify optimization opportunities",
        "Track bundle size"
      ],
      "tradeoffs": [
        "Requires analysis time"
      ]
    },
    "react-profiler": {
      "name": "React Profiler",
      "description": "Profile React component performance",
      "useCase": "Identifying slow components",
      "example": "React DevTools Profiler, useProfiler hook",
      "benefits": [
        "Identify bottlenecks",
        "Optimize renders"
      ],
      "tradeoffs": [
        "Development tool only"
      ]
    },
    "memoization": {
      "name": "Memoization",
      "description": "Cache expensive computations and prevent re-renders",
      "useCase": "Expensive calculations, frequently re-rendering components",
      "example": "React.memo, useMemo, useCallback",
      "benefits": [
        "Fewer re-renders",
        "Better performance"
      ],
      "tradeoffs": [
        "Memory overhead",
        "Can be premature optimization"
      ]
    },
    "server-component-streaming": {
      "name": "Server Component Streaming",
      "description": "Stream Server Components as they render",
      "useCase": "Slow data fetching, multiple data sources",
      "example": "Suspense boundaries, streaming SSR",
      "benefits": [
        "Faster perceived load",
        "Progressive rendering"
      ],
      "tradeoffs": [
        "Requires Suspense setup"
      ]
    },
    "lighthouse-automation": {
      "name": "Lighthouse Automation",
      "description": "Automate performance testing with Lighthouse",
      "useCase": "CI/CD performance checks",
      "example": "Lighthouse CI, GitHub Actions",
      "benefits": [
        "Continuous monitoring",
        "Prevent regressions"
      ],
      "tradeoffs": [
        "Requires CI setup"
      ]
    }
  },
  "best_practices": [
    "Measure before optimizing",
    "Optimize images and fonts",
    "Code split routes and components",
    "Use caching strategies appropriately",
    "Monitor Core Web Vitals",
    "Lazy load below-the-fold content",
    "Use React.memo strategically",
    "Stream content with Suspense"
  ],
  "anti_patterns": [
    "Optimizing without measuring",
    "Not optimizing images",
    "Loading all code upfront",
    "Ignoring Core Web Vitals",
    "Premature memoization",
    "Not using code splitting",
    "Ignoring bundle size",
    "Not monitoring performance"
  ]
}