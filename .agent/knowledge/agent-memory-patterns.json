{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "agent-memory-patterns",
  "name": "Agent Memory Patterns",
  "title": "Agent Memory Patterns",
  "description": "Patterns for implementing memory systems in agents including conversation, long-term semantic, and user profile storage",
  "version": "1.0.0",
  "category": "agent-patterns",
  "axiomAlignment": {
    "A1_verifiability": "Memory compression and TTL enable verifiable session lifecycle and retrieval",
    "A2_user_primacy": "Memory isolation and forgetting mechanisms preserve user privacy and control",
    "A3_transparency": "Explicit memory types and storage backends make data flow traceable",
    "A4_non_harm": "Privacy deletion and TTL prevent harmful data retention",
    "A5_consistency": "Unified memory patterns across conversation, long-term, and hybrid storage"
  },
  "related_skills": [
    "memory-management",
    "state-management",
    "rag-patterns"
  ],
  "related_knowledge": [
    "state-patterns.json",
    "rag-patterns.json",
    "langchain-patterns.json"
  ],
  "memory_types": {
    "conversation": {
      "description": "Short-term message history",
      "implementations": {
        "in_memory": {
          "class": "InMemoryChatMessageHistory",
          "use_case": "Development, single session",
          "persistence": false
        },
        "redis": {
          "backend": "Redis",
          "use_case": "Production, distributed",
          "persistence": true,
          "ttl_support": true
        },
        "postgres": {
          "backend": "PostgreSQL",
          "use_case": "Production, queryable history",
          "persistence": true
        }
      }
    },
    "long_term": {
      "description": "Semantic knowledge storage",
      "implementations": {
        "vector_store": {
          "backends": [
            "ChromaDB",
            "Pinecone",
            "Weaviate",
            "Qdrant"
          ],
          "use_case": "Semantic retrieval of past interactions"
        },
        "knowledge_graph": {
          "backends": [
            "Neo4j",
            "NetworkX"
          ],
          "use_case": "Entity relationships and facts"
        }
      }
    },
    "user_profile": {
      "description": "Structured user preferences and facts",
      "storage": [
        "Redis hash",
        "PostgreSQL JSON",
        "Document DB"
      ],
      "schema": [
        "name",
        "preferences",
        "facts",
        "history_summary"
      ]
    },
    "working": {
      "description": "Current task context",
      "implementation": "LangGraph state",
      "scope": "Single workflow execution"
    }
  },
  "patterns": {
    "session_management_description": {
      "description": "Manage memory per user session",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# session_management_description pattern for memory-patterns\n# Implement based on description: Manage memory per user session...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "session_management_pattern": {
      "description": "Use session_id in config.configurable",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# session_management_pattern pattern for memory-patterns\n# Implement based on description: Use session_id in config.configurable...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "session_management_example": {
      "description": "RunnableWithMessageHistory with get_session_history function",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# session_management_example pattern for memory-patterns\n# Implement based on description: RunnableWithMessageHistory with get_session_histor...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "memory_compression_description": {
      "description": "Summarize old messages to fit context",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# memory_compression_description pattern for memory-patterns\n# Implement based on description: Summarize old messages to fit context...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "memory_compression_trigger": {
      "description": "When messages exceed threshold",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# memory_compression_trigger pattern for memory-patterns\n# Implement based on description: When messages exceed threshold...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "memory_compression_method": {
      "description": "LLM summarization of old messages",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# memory_compression_method pattern for memory-patterns\n# Implement based on description: LLM summarization of old messages...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "hybrid_memory_description": {
      "description": "Combine short and long-term memory",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# hybrid_memory_description pattern for memory-patterns\n# Implement based on description: Combine short and long-term memory...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "hybrid_memory_pattern": {
      "description": "Recent messages + relevant retrieved memories",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# hybrid_memory_pattern pattern for memory-patterns\n# Implement based on description: Recent messages + relevant retrieved memories...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "entity_extraction_description": {
      "description": "Extract and store entities from conversations",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# entity_extraction_description pattern for memory-patterns\n# Implement based on description: Extract and store entities from conversations...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "entity_extraction_entities": {
      "description": "['names', 'preferences', 'facts', 'relationships']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    }
  },
  "best_practices": [
    "Use token-based summarization to prevent memory overflow when messages exceed context window thresholds",
    "Implement TTL (Time-To-Live) for conversation memory to automatically expire old sessions and reduce storage costs",
    "Separate short-term conversation memory from long-term semantic memory using different storage backends optimized for each use case",
    "Index memories with embeddings for semantic retrieval, enabling agents to find relevant past interactions even with different wording",
    "Implement memory forgetting mechanisms for privacy compliance, allowing users to delete specific memories or entire conversation histories",
    "Use session-based memory isolation with unique session IDs to prevent memory leakage between different users or conversations",
    "Extract and store structured entities (names, preferences, facts) separately from raw conversation history for efficient querying",
    "Implement hybrid memory retrieval combining recent messages with semantically similar long-term memories for context-aware responses"
  ],
  "anti_patterns": [
    {
      "name": "Unbounded history",
      "problem": "Conversation history grows indefinitely, exceeding context window limits and causing API failures or degraded performance",
      "fix": "Set maximum message limits (e.g., last 50 messages) and implement token-based summarization when thresholds are exceeded"
    },
    {
      "name": "No persistence",
      "problem": "Memory lost on application restart, requiring users to repeat context and breaking continuity",
      "fix": "Use persistent backends like Redis or PostgreSQL for conversation memory, ensuring state survives restarts"
    },
    {
      "name": "Mixing memory types",
      "problem": "Storing short-term conversation history and long-term semantic knowledge in the same storage system leads to inefficient queries and poor performance",
      "fix": "Use separate storage systems: Redis/PostgreSQL for conversation history, vector databases for semantic memory"
    },
    {
      "name": "No memory compression",
      "problem": "Raw conversation history accumulates tokens quickly, hitting context limits and increasing API costs",
      "fix": "Implement LLM-based summarization to compress old messages while preserving key information and context"
    },
    {
      "name": "Ignoring privacy requirements",
      "problem": "Storing user data indefinitely without deletion mechanisms violates privacy regulations and user trust",
      "fix": "Implement memory deletion APIs, TTL-based expiration, and user-initiated memory clearing capabilities"
    }
  ]
}
