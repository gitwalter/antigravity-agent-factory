{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "kubernetes-patterns",
  "name": "Kubernetes Patterns",
  "title": "Kubernetes Patterns",
  "description": "Best practices and patterns for Kubernetes deployment, operations, and cloud-native development",
  "version": "1.0.0",
  "category": "integration",
  "sources": [
    "https://kubernetes.io/docs/",
    "https://kubernetes.io/docs/concepts/"
  ],
  "axiomAlignment": {
    "A1_verifiability": "Patterns include health checks and monitoring",
    "A2_user_primacy": "Workload patterns serve application reliability and user-facing SLAs",
    "A3_transparency": "Resource definitions and probes make infrastructure explicit",
    "A4_non_harm": "Security patterns protect workloads and data",
    "A5_consistency": "Unified Kubernetes patterns across deployment, config, and observability"
  },
  "related_skills": [
    "kubernetes-deployment",
    "docker-deployment",
    "ml-deployment",
    "logging-monitoring"
  ],
  "related_knowledge": [
    "docker-patterns.json",
    "kubernetes-deployment-patterns.json",
    "kubernetes-ml-patterns.json",
    "cicd-patterns.json"
  ],
  "core_concepts": {
    "pods": {
      "description": "Smallest deployable unit, one or more containers",
      "best_practices": [
        "One main container per pod (with sidecars if needed)",
        "Use resource requests and limits",
        "Define liveness and readiness probes",
        "Use labels for organization and selection"
      ],
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "FROM node:18-alpine\nWORKDIR /app\nCOPY . .\nRUN npm ci\nCMD [\"node\", \"dist/index.js\"]"
    },
    "workload_resources": {
      "deployment": {
        "use_case": "Stateless applications",
        "features": [
          "Rolling updates",
          "Rollback",
          "Scaling"
        ]
      },
      "statefulset": {
        "use_case": "Stateful applications (databases, queues)",
        "features": [
          "Stable network identity",
          "Ordered deployment",
          "Persistent storage"
        ]
      },
      "daemonset": {
        "use_case": "Run on every node (monitoring, logging)",
        "features": [
          "Node-level operations",
          "Automatic scheduling"
        ]
      },
      "job_cronjob": {
        "use_case": "Batch processing, scheduled tasks",
        "features": [
          "Run to completion",
          "Retry on failure"
        ]
      }
    },
    "services": {
      "types": {
        "ClusterIP": "Internal cluster communication",
        "NodePort": "Expose on each node's IP",
        "LoadBalancer": "External load balancer (cloud)",
        "ExternalName": "CNAME to external service"
      }
    }
  },
  "deployment_patterns": {
    "rolling_update": {
      "description": "Gradually replace old pods with new ones",
      "code_example": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: my-app\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n      - name: my-app\n        image: my-app:v2\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 10\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n          initialDelaySeconds: 15\n          periodSeconds: 20",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "blue_green": {
      "description": "Run two environments, switch traffic instantly",
      "implementation": "Use service selector to switch between blue/green deployments",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "Use service selector to switch between blue/green deployments",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "canary": {
      "description": "Route small percentage of traffic to new version",
      "implementation": "Use multiple deployments with weighted service mesh routing",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "Use multiple deployments with weighted service mesh routing",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    }
  },
  "configuration_patterns": {
    "configmaps": {
      "description": "Store non-sensitive configuration",
      "code_example": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  database_url: \"postgres://db:5432/myapp\"\n  log_level: \"info\"\n  config.yaml: |\n    server:\n      port: 8080\n      timeout: 30s",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "secrets": {
      "description": "Store sensitive data (base64 encoded)",
      "code_example": "apiVersion: v1\nkind: Secret\nmetadata:\n  name: app-secrets\ntype: Opaque\ndata:\n  api-key: YXBpLWtleS12YWx1ZQ==\n  db-password: cGFzc3dvcmQ=",
      "best_practices": [
        "Use external secret managers (Vault, AWS SM)",
        "Enable encryption at rest",
        "Use RBAC to limit access",
        "Rotate secrets regularly"
      ],
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation"
    },
    "env_injection": {
      "description": "Inject config as environment variables",
      "code_example": "env:\n- name: DATABASE_URL\n  valueFrom:\n    configMapKeyRef:\n      name: app-config\n      key: database_url\n- name: API_KEY\n  valueFrom:\n    secretKeyRef:\n      name: app-secrets\n      key: api-key",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    }
  },
  "storage_patterns": {
    "persistent_volumes": {
      "description": "Persistent storage that survives pod restarts",
      "code_example": "apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: data-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: standard\n  resources:\n    requests:\n      storage: 10Gi",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "volume_types": {
      "emptyDir": "Temporary storage, lost when pod dies",
      "hostPath": "Mount host filesystem (use cautiously)",
      "persistentVolumeClaim": "Persistent network storage",
      "configMap_secret": "Inject config/secrets as files"
    }
  },
  "networking_patterns": {
    "ingress": {
      "description": "HTTP routing and load balancing",
      "code_example": "apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - myapp.example.com\n    secretName: tls-secret\n  rules:\n  - host: myapp.example.com\n    http:\n      paths:\n      - path: /api\n        pathType: Prefix\n        backend:\n          service:\n            name: api-service\n            port:\n              number: 80",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "network_policies": {
      "description": "Control pod-to-pod traffic",
      "code_example": "apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: api-policy\nspec:\n  podSelector:\n    matchLabels:\n      app: api\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: frontend\n    ports:\n    - protocol: TCP\n      port: 8080",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    }
  },
  "scaling_patterns": {
    "horizontal_pod_autoscaler": {
      "description": "Scale pods based on metrics",
      "code_example": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: my-app-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: my-app\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "vertical_pod_autoscaler": {
      "description": "Automatically adjust resource requests/limits",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  key: value",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "pod_disruption_budget": {
      "description": "Ensure minimum availability during disruptions",
      "code_example": "apiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: my-app-pdb\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app: my-app",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    }
  },
  "observability_patterns": {
    "health_probes": {
      "liveness": "Is the container running? Restart if fails",
      "readiness": "Is the container ready to serve? Remove from load balancer if fails",
      "startup": "Is the container started? For slow-starting apps"
    },
    "logging": {
      "pattern": "Log to stdout/stderr, collect with fluentd/fluentbit"
    },
    "metrics": {
      "pattern": "Expose /metrics endpoint, scrape with Prometheus"
    }
  },
  "security_patterns": {
    "pod_security": {
      "description": "Restrict pod capabilities",
      "code_example": "securityContext:\n  runAsNonRoot: true\n  runAsUser: 1000\n  readOnlyRootFilesystem: true\n  allowPrivilegeEscalation: false\n  capabilities:\n    drop:\n      - ALL",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "rbac": {
      "description": "Role-Based Access Control",
      "components": [
        "ServiceAccount",
        "Role/ClusterRole",
        "RoleBinding/ClusterRoleBinding"
      ],
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  key: value",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "resource_quotas": {
      "description": "Limit resources per namespace",
      "code_example": "apiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: compute-quota\nspec:\n  hard:\n    requests.cpu: \"4\"\n    requests.memory: 8Gi\n    limits.cpu: \"8\"\n    limits.memory: 16Gi",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    }
  },
  "helm_patterns": {
    "description": "Package manager for Kubernetes",
    "best_practices": [
      "Use values.yaml for configuration",
      "Template common patterns",
      "Use dependencies for shared charts",
      "Version charts semantically"
    ],
    "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
    "code_example": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: app\n        image: myapp:latest"
  },
  "best_practices": [
    "Always set resource requests and limits",
    "Use namespaces for isolation",
    "Implement health probes for all containers",
    "Use labels consistently for selection and organization",
    "Enable RBAC and principle of least privilege",
    "Use network policies for defense in depth",
    "Store configuration in ConfigMaps, secrets in Secrets",
    "Use GitOps for declarative deployments",
    "Monitor resource usage and set up alerts",
    "Plan for pod disruption with PDBs"
  ],
  "anti_patterns": [
    {
      "name": "Missing Resource Requests and Limits",
      "description": "Not setting resource requests and limits on pods",
      "problem": "Pods can consume all node resources, causing other pods to be evicted",
      "solution": "Always set requests and limits: resources: { requests: { cpu: '100m', memory: '128Mi' }, limits: { cpu: '500m', memory: '512Mi' } }",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  key: value",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    {
      "name": "Using 'latest' Image Tag",
      "description": "Using 'latest' tag for container images",
      "problem": "Unpredictable deployments, can't rollback, breaks reproducibility",
      "solution": "Use specific image tags or digests: image: myapp:v1.2.3 or image: myapp@sha256:abc123...",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "FROM node:18-alpine\nWORKDIR /app\nCOPY . .\nRUN npm ci\nCMD [\"node\", \"dist/index.js\"]",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    {
      "name": "Missing Health Probes",
      "description": "Not implementing liveness and readiness probes",
      "problem": "Traffic sent to unhealthy pods, no automatic recovery, poor user experience",
      "solution": "Implement liveness and readiness probes: livenessProbe: { httpGet: { path: /health, port: 8080 } }",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  key: value",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    {
      "name": "Hardcoded Replica Count",
      "description": "Setting fixed replica count without autoscaling",
      "problem": "Can't handle traffic spikes, wastes resources during low traffic",
      "solution": "Use HorizontalPodAutoscaler for dynamic scaling based on CPU/memory/custom metrics",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  key: value",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    {
      "name": "Missing Security Context",
      "description": "Not setting security context on pods",
      "problem": "Containers run as root, privilege escalation possible, security vulnerability",
      "solution": "Set securityContext: { runAsNonRoot: true, runAsUser: 1000, readOnlyRootFilesystem: true }",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  key: value",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    {
      "name": "Storing Secrets in ConfigMaps",
      "description": "Putting sensitive data in ConfigMaps instead of Secrets",
      "problem": "Secrets stored in plain text, visible to anyone with ConfigMap access",
      "solution": "Use Secrets for sensitive data, enable encryption at rest, use external secret managers",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: app-config\ndata:\n  key: value",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    }
  ],
  "patterns": {
    "general": {
      "description": "Best practices and patterns for Kubernetes deployment, operations, and cloud-native development",
      "usage": "See detailed sections below",
      "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
      "code_example": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: app\n        image: myapp:latest",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    }
  },
  "use_when": "CI/CD pipelines, container orchestration, or deployment automation",
  "code_example": "apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app\nspec:\n  replicas: 3\n  template:\n    spec:\n      containers:\n      - name: app\n        image: myapp:latest"
}