{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "bdd-patterns-and-best-practices",
  "name": "BDD Patterns and Best Practices",
  "title": "BDD Patterns and Best Practices",
  "description": "Knowledge file containing Behavior-Driven Development patterns, Gherkin syntax, and framework guidance",
  "version": "1.0.0",
  "category": "testing",
  "axiomAlignment": {
    "A1_verifiability": "Gherkin scenarios provide executable specifications for verification",
    "A2_user_primacy": "BDD scenarios express stakeholder requirements in domain language",
    "A3_transparency": "Living documentation makes behavior explicit and accessible",
    "A4_non_harm": "Example-based specs prevent misinterpretation and unintended behavior",
    "A5_consistency": "Ubiquitous language ensures consistent understanding across teams"
  },
  "related_skills": [
    "bdd",
    "agent-testing",
    "test-translation"
  ],
  "related_knowledge": [
    "test-patterns.json",
    "tdd-patterns.json"
  ],
  "gherkinSyntax": {
    "keywords": {
      "feature": {
        "description": "Describes the business feature being specified",
        "example": "Feature: User Registration\n  As a new user\n  I want to create an account\n  So that I can access the application",
        "use_when": "Apply when implementing feature in testing context",
        "code_example": "Feature: User Registration\n  As a new user\n  I want to create an account\n  So that I can access the application",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for feature",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "background": {
        "description": "Common setup steps shared by all scenarios in a feature",
        "example": "Background:\n  Given the registration page is displayed\n  And the database is empty",
        "use_when": "Apply when implementing background in testing context",
        "code_example": "Background:\n  Given the registration page is displayed\n  And the database is empty",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for background",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "scenario": {
        "description": "A concrete example of a business rule",
        "example": "Scenario: Successful registration with valid email\n  Given I am on the registration page\n  When I submit valid registration details\n  Then my account should be created",
        "use_when": "Apply when implementing scenario in testing context",
        "code_example": "Scenario: Successful registration with valid email\n  Given I am on the registration page\n  When I submit valid registration details\n  Then my account should be created",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for scenario",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "scenarioOutline": {
        "description": "Template for data-driven scenarios",
        "example": "Scenario Outline: Email validation\n  Given I enter email \"<email>\"\n  When I submit the form\n  Then I should see \"<message>\"\n\n  Examples:\n    | email           | message         |\n    | valid@email.com | Success         |\n    | invalid         | Invalid email   |",
        "use_when": "Apply when implementing scenarioOutline in testing context",
        "code_example": "Scenario Outline: Email validation\n  Given I enter email \"<email>\"\n  When I submit the form\n  Then I should see \"<message>\"\n\n  Examples:\n    | email           | message         |\n    | valid@email.com | Success         |\n    | invalid         | Invalid email   |",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for scenarioOutline",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "given": {
        "description": "Establishes the initial context or preconditions",
        "purpose": "Setup the system state before the action",
        "use_when": "Apply when implementing given in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for given",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "when": {
        "description": "Describes the action or event",
        "purpose": "Trigger the behavior being tested",
        "use_when": "Apply when implementing when in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for when",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "then": {
        "description": "Describes the expected outcome",
        "purpose": "Assert the expected results",
        "use_when": "Apply when implementing then in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for then",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "and": {
        "description": "Continues the previous step type",
        "purpose": "Chain multiple steps of same type for readability",
        "use_when": "Apply when implementing and in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for and",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "but": {
        "description": "Negative continuation",
        "purpose": "Express exception or negative condition",
        "use_when": "Apply when implementing but in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for but",
          "Validate implementation against domain requirements before deployment"
        ]
      }
    },
    "dataTables": {
      "description": "Tabular data passed to steps",
      "example": "Given the following users exist:\n  | name  | email           | role  |\n  | Alice | alice@test.com  | admin |\n  | Bob   | bob@test.com    | user  |",
      "use_when": "Apply when implementing dataTables in testing context",
      "code_example": "Given the following users exist:\n  | name  | email           | role  |\n  | Alice | alice@test.com  | admin |\n  | Bob   | bob@test.com    | user  |",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for dataTables",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "docStrings": {
      "description": "Multi-line text passed to steps",
      "example": "Given the following JSON payload:\n  \"\"\"\n  {\n    \"name\": \"Test User\",\n    \"email\": \"test@example.com\"\n  }\n  \"\"\"",
      "use_when": "Apply when implementing docStrings in testing context",
      "code_example": "Given the following JSON payload:\n  \"\"\"\n  {\n    \"name\": \"Test User\",\n    \"email\": \"test@example.com\"\n  }\n  \"\"\"",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for docStrings",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "tags": {
      "description": "Metadata for organizing and filtering scenarios",
      "examples": [
        "@smoke",
        "@regression",
        "@wip",
        "@skip",
        "@critical"
      ],
      "usage": "@smoke @critical\nScenario: Critical user flow",
      "use_when": "Apply when implementing tags in testing context",
      "code_example": "@smoke @critical\nScenario: Critical user flow",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for tags",
        "Validate implementation against domain requirements before deployment"
      ]
    }
  },
  "exampleMapping": {
    "description": "Collaborative technique for discovering scenarios",
    "participants": [
      "Product Owner",
      "Developer",
      "Tester"
    ],
    "artifacts": {
      "story": "User story being discussed (yellow card)",
      "rules": "Business rules discovered (blue cards)",
      "examples": "Concrete examples of rules (green cards)",
      "questions": "Open questions needing answers (red cards)"
    },
    "process": [
      "Start with the user story",
      "Identify business rules",
      "For each rule, create concrete examples",
      "Capture questions for follow-up",
      "Convert examples to Gherkin scenarios"
    ],
    "use_when": "Apply when implementing exampleMapping in testing context",
    "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
    "best_practices": [
      "Document the pattern usage and rationale in code comments for exampleMapping",
      "Validate implementation against domain requirements before deployment"
    ]
  },
  "threeAmigos": {
    "description": "Collaborative session with three perspectives",
    "roles": {
      "business": "Defines WHAT the feature should do (Product Owner)",
      "development": "Defines HOW to implement (Developer)",
      "testing": "Defines edge cases and validation (Tester/QA)"
    },
    "timing": "Before sprint or iteration planning",
    "duration": "30-60 minutes per story",
    "outcomes": [
      "Shared understanding of requirements",
      "Identified acceptance criteria",
      "Discovered edge cases",
      "Draft Gherkin scenarios"
    ],
    "use_when": "Apply when implementing threeAmigos in testing context",
    "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
    "best_practices": [
      "Document the pattern usage and rationale in code comments for threeAmigos",
      "Validate implementation against domain requirements before deployment"
    ]
  },
  "frameworks": {
    "python": {
      "behave": {
        "description": "Most popular Python BDD framework",
        "installation": "pip install behave",
        "structure": {
          "features": "features/*.feature",
          "steps": "features/steps/*.py",
          "environment": "features/environment.py"
        },
        "stepDecorators": [
          "@given",
          "@when",
          "@then",
          "@step"
        ],
        "hooks": [
          "before_all",
          "after_all",
          "before_feature",
          "after_feature",
          "before_scenario",
          "after_scenario",
          "before_step",
          "after_step"
        ],
        "runCommand": "behave",
        "use_when": "Apply when implementing behave in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for behave",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "pytestBdd": {
        "description": "BDD plugin for pytest",
        "installation": "pip install pytest-bdd",
        "structure": {
          "features": "{directories.tests}/features/*.feature",
          "steps": "{directories.tests}/step_defs/*.py"
        },
        "advantages": [
          "Integrates with pytest fixtures",
          "Uses pytest's assertion introspection"
        ],
        "runCommand": "pytest --bdd",
        "use_when": "Apply when implementing pytestBdd in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for pytestBdd",
          "Validate implementation against domain requirements before deployment"
        ]
      }
    },
    "typescript": {
      "cucumberJs": {
        "description": "Official Cucumber implementation for JavaScript/TypeScript",
        "installation": "npm install @cucumber/cucumber",
        "structure": {
          "features": "features/*.feature",
          "steps": "features/step_definitions/*.ts",
          "support": "features/support/*.ts"
        },
        "stepDecorators": [
          "Given",
          "When",
          "Then",
          "And",
          "But"
        ],
        "hooks": [
          "Before",
          "After",
          "BeforeAll",
          "AfterAll",
          "BeforeStep",
          "AfterStep"
        ],
        "runCommand": "npx cucumber-js",
        "use_when": "Apply when implementing cucumberJs in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for cucumberJs",
          "Validate implementation against domain requirements before deployment"
        ]
      }
    },
    "java": {
      "cucumberJvm": {
        "description": "Official Cucumber implementation for Java",
        "installation": "io.cucumber:cucumber-java",
        "structure": {
          "features": "src/test/resources/features/*.feature",
          "steps": "src/test/java/steps/*.java",
          "runner": "src/test/java/runner/TestRunner.java"
        },
        "annotations": [
          "@Given",
          "@When",
          "@Then",
          "@And",
          "@But"
        ],
        "hooks": [
          "@Before",
          "@After",
          "@BeforeAll",
          "@AfterAll"
        ],
        "runCommand": "mvn test -Dcucumber",
        "use_when": "Apply when implementing cucumberJvm in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for cucumberJvm",
          "Validate implementation against domain requirements before deployment"
        ]
      }
    },
    "csharp": {
      "specflow": {
        "description": "BDD framework for .NET",
        "installation": "SpecFlow.NUnit or SpecFlow.xUnit",
        "structure": {
          "features": "Features/*.feature",
          "steps": "Features/Steps/*.cs",
          "hooks": "Features/Hooks/*.cs"
        },
        "attributes": [
          "[Given]",
          "[When]",
          "[Then]",
          "[And]",
          "[But]"
        ],
        "hooks": [
          "[BeforeScenario]",
          "[AfterScenario]",
          "[BeforeFeature]",
          "[AfterFeature]"
        ],
        "runCommand": "dotnet test",
        "use_when": "Apply when implementing specflow in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for specflow",
          "Validate implementation against domain requirements before deployment"
        ]
      }
    },
    "kotlin": {
      "cucumberJvm": {
        "description": "Cucumber with Kotlin DSL",
        "installation": "io.cucumber:cucumber-java + kotlin stdlib",
        "structure": {
          "features": "src/test/resources/features/*.feature",
          "steps": "src/test/kotlin/steps/*.kt"
        },
        "dslStyle": "Given/When/Then as infix functions",
        "runCommand": "gradle test",
        "use_when": "Apply when implementing cucumberJvm in testing context",
        "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments for cucumberJvm",
          "Validate implementation against domain requirements before deployment"
        ]
      }
    }
  },
  "projectStructure": {
    "recommended": {
      "features": "Feature files organized by domain",
      "steps": "Step definitions organized by domain or shared",
      "support": "Hooks, world/context, utilities",
      "fixtures": "Test data and factories"
    },
    "example": {
      "python": [
        "features/",
        "  user/",
        "    registration.feature",
        "    login.feature",
        "  product/",
        "    catalog.feature",
        "  steps/",
        "    user_steps.py",
        "    product_steps.py",
        "    common_steps.py",
        "  environment.py"
      ],
      "typescript": [
        "features/",
        "  user/",
        "    registration.feature",
        "  step_definitions/",
        "    user.steps.ts",
        "    common.steps.ts",
        "  support/",
        "    world.ts",
        "    hooks.ts"
      ]
    },
    "description": "Implements projectStructure for reliable, maintainable code. Use when the scenario requires this pattern.",
    "use_when": "Apply when implementing projectStructure in testing context",
    "code_example": "{'python': ['features/', '  user/', '    registration.feature', '    login.feature', '  product/', '    catalog.feature', '  steps/', '    user_steps.py', '    product_steps.py', '    common_steps.py', '  environment.py'], 'typescript': ['features/', '  user/', '    registration.feature', '  step_definitions/', '    user.steps.ts', '    common.steps.ts', '  support/', '    world.ts', '    hooks.ts']}",
    "best_practices": [
      "Document the pattern usage and rationale in code comments for projectStructure",
      "Validate implementation against domain requirements before deployment"
    ]
  },
  "integrationWithTdd": {
    "description": "BDD and TDD serve complementary purposes",
    "layers": {
      "bdd": "Acceptance tests - stakeholder-visible behavior",
      "tdd": "Unit tests - developer-focused implementation details"
    },
    "testPyramid": {
      "top": "BDD/E2E (few, slow, high-level)",
      "middle": "Integration tests (some, medium speed)",
      "bottom": "Unit tests via TDD (many, fast, low-level)"
    },
    "workflow": [
      "Write BDD scenario (failing acceptance test)",
      "Use TDD to implement (red-green-refactor cycle)",
      "BDD scenario passes when implementation complete",
      "Both test suites maintained going forward"
    ],
    "use_when": "Apply when implementing integrationWithTdd in testing context",
    "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
    "best_practices": [
      "Document the pattern usage and rationale in code comments for integrationWithTdd",
      "Validate implementation against domain requirements before deployment"
    ]
  },
  "livingDocumentation": {
    "description": "Feature files as always-up-to-date documentation",
    "tools": {
      "python": "behave --format html --outfile report.html",
      "cucumber": "cucumber-js --format html:report.html",
      "specflow": "SpecFlow.Plus.LivingDocPlugin"
    },
    "benefits": [
      "Documentation that cannot become stale",
      "Stakeholders can review current behavior",
      "Onboarding material for new team members",
      "Audit trail for compliance"
    ],
    "use_when": "Apply when implementing livingDocumentation in testing context",
    "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
    "best_practices": [
      "Document the pattern usage and rationale in code comments for livingDocumentation",
      "Validate implementation against domain requirements before deployment"
    ]
  },
  "best_practices": [
    "Write scenarios at the business level, not UI interaction level Use: Given I am logged in as a registered user. Avoid: Given I click the login button\nAnd I type 'user@test.com' in the email field\nAnd I type 'password123' in the password field\nAnd I click submit",
    "Each scenario should test one business rule or behavior",
    "Scenarios should not depend on state from other scenarios",
    "Use domain terminology understood by stakeholders Use: When I register a new user account. Avoid: When I POST to /api/v1/users with JSON payload",
    "Build a library of reusable step definitions Consistent language across features Reduced maintenance burden Faster scenario authoring",
    "Use Background for common Given steps shared by all scenarios Keep Background short; if complex, consider hooks instead",
    "Use Scenario Outline for testing same behavior with different data Keep Examples tables focused; too many rows indicate split needed"
  ],
  "anti_patterns": [
    {
      "name": "Imperativescenarios",
      "problem": "Brittle, hard to read, maintenance nightmare",
      "fix": "Abstract to business-level declarative steps"
    },
    {
      "name": "Incidentaldetails",
      "problem": "Obscures the business intent",
      "fix": "Include only details essential to the behavior"
    },
    {
      "name": "Featurebloat",
      "problem": "Hard to navigate, likely mixing concerns",
      "fix": "Split by business capability, aim for 5-15 scenarios per feature"
    },
    {
      "name": "Coupledscenarios",
      "problem": "Cannot run in isolation, order-dependent failures",
      "fix": "Use proper setup in Given steps or Background"
    },
    {
      "name": "Duplicatedsteps",
      "problem": "Inconsistent behavior, maintenance burden",
      "fix": "Build reusable step library with parameterized steps"
    },
    {
      "name": "Techspeak",
      "problem": "Stakeholders cannot understand or validate scenarios",
      "fix": "Use ubiquitous language from domain-driven design"
    }
  ],
  "patterns": {
    "general": {
      "description": "Knowledge file containing Behavior-Driven Development patterns, Gherkin syntax, and framework guidance",
      "usage": "See detailed sections below",
      "use_when": "Apply when implementing general in testing context",
      "code_example": "See detailed sections below",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for general",
        "Validate implementation against domain requirements before deployment"
      ]
    }
  }
}