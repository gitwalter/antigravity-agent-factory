{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "bitcoin-protocol-patterns",
  "name": "Bitcoin Protocol Patterns",
  "title": "Bitcoin Protocol Patterns",
  "description": "Core concepts, patterns, and best practices for Bitcoin and Lightning Network development",
  "version": "1.0.0",
  "category": "specialized",
  "sources": [
    "https://developer.bitcoin.org/",
    "https://github.com/bitcoin/bitcoin",
    "https://lightning.engineering/",
    "https://docs.lightning.engineering/"
  ],
  "axiomAlignment": {
    "A1_verifiability": "Bitcoin's design enables cryptographic verification of all transactions",
    "A2_user_primacy": "Self-custody and key management prioritize user control",
    "A3_transparency": "UTXO model and script verification enable full auditability",
    "A4_non_harm": "Security patterns protect user funds and privacy",
    "A5_consistency": "Unified patterns for UTXO, PSBT, and Lightning flows"
  },
  "related_skills": [
    "error-handling",
    "security-sandboxing"
  ],
  "related_knowledge": [
    "defi-patterns.json",
    "solidity-patterns.json",
    "solana-patterns.json"
  ],
  "core_concepts": {
    "utxo_model": {
      "description": "Unspent Transaction Output - Bitcoin's accounting model",
      "key_insight": "Bitcoin doesn't have accounts with balances; instead, wallets track UTXOs they can spend",
      "structure": {
        "components": [
          {
            "name": "txid",
            "description": "Transaction ID that created this output"
          },
          {
            "name": "vout",
            "description": "Index of output in that transaction"
          },
          {
            "name": "value",
            "description": "Amount in satoshis (1 BTC = 100M sats)"
          },
          {
            "name": "scriptPubKey",
            "description": "Locking script (conditions to spend)"
          }
        ]
      },
      "spending_process": [
        "Reference UTXO by txid:vout",
        "Provide scriptSig (unlocking script) that satisfies scriptPubKey",
        "Create new outputs (which become new UTXOs)",
        "Original UTXO is consumed (no longer spendable)"
      ],
      "vs_account_model": {
        "utxo_advantages": [
          "Better privacy (each UTXO is independent)",
          "Parallel transaction validation",
          "Simpler proof of ownership"
        ],
        "account_advantages": [
          "Simpler balance tracking",
          "Easier smart contract state management"
        ]
      }
    },
    "script_system": {
      "description": "Bitcoin's simple stack-based scripting language",
      "characteristics": [
        "Not Turing-complete (no loops)",
        "Stateless (no persistent storage)",
        "Deterministic execution",
        "Resource-limited by design"
      ],
      "common_script_types": {
        "P2PKH": {
          "name": "Pay to Public Key Hash",
          "description": "Classic Bitcoin address starting with '1'",
          "scriptPubKey": "OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG",
          "scriptSig": "<signature> <pubKey>",
          "use_case": "Standard payments to single key"
        },
        "P2SH": {
          "name": "Pay to Script Hash",
          "description": "Address starting with '3', enables complex scripts",
          "scriptPubKey": "OP_HASH160 <scriptHash> OP_EQUAL",
          "scriptSig": "<signatures...> <redeemScript>",
          "use_case": "Multi-signature, timelocks, complex conditions"
        },
        "P2WPKH": {
          "name": "Pay to Witness Public Key Hash",
          "description": "Native SegWit address starting with 'bc1q'",
          "benefits": [
            "Lower fees",
            "Malleability fix",
            "Better scaling"
          ],
          "use_case": "Recommended for new applications"
        },
        "P2WSH": {
          "name": "Pay to Witness Script Hash",
          "description": "Native SegWit for complex scripts",
          "use_case": "Modern multi-sig, Lightning channels"
        },
        "P2TR": {
          "name": "Pay to Taproot",
          "description": "Taproot address starting with 'bc1p'",
          "benefits": [
            "Privacy (scripts hidden unless used)",
            "Efficiency",
            "Schnorr signatures"
          ],
          "use_case": "Most advanced, recommended for new development"
        }
      }
    },
    "transaction_structure": {
      "components": {
        "version": "Transaction format version (currently 1 or 2)",
        "inputs": "References to UTXOs being spent",
        "outputs": "New UTXOs being created",
        "locktime": "Earliest time/block transaction can be mined",
        "witness": "SegWit signature data (if applicable)"
      },
      "fees": {
        "calculation": "Fee = sum(inputs) - sum(outputs)",
        "units": "Satoshis per virtual byte (sat/vB)",
        "estimation": "Use mempool data to estimate competitive fee rate"
      }
    },
    "consensus_rules": {
      "description": "Rules all nodes must follow to validate blocks and transactions",
      "key_rules": [
        "Block subsidy schedule (halving every 210,000 blocks)",
        "Block size limit (4 million weight units)",
        "Difficulty adjustment every 2016 blocks",
        "Transaction validation (signatures, scripts, amounts)"
      ]
    }
  },
  "advanced_features": {
    "multi_signature": {
      "description": "Require multiple signatures to spend",
      "patterns": {
        "m_of_n": {
          "description": "M signatures required from N possible signers",
          "example": "2-of-3 multisig for company treasury",
          "script": "OP_2 <pubKey1> <pubKey2> <pubKey3> OP_3 OP_CHECKMULTISIG"
        }
      },
      "modern_approach": {
        "MuSig2": "Schnorr-based multi-signature (single aggregated signature)",
        "benefits": [
          "Privacy (looks like single-sig)",
          "Lower fees",
          "Taproot compatible"
        ]
      }
    },
    "timelocks": {
      "absolute_timelock": {
        "name": "CLTV (CheckLockTimeVerify)",
        "description": "Funds locked until specific time/block height",
        "use_cases": [
          "Vesting schedules",
          "Delayed payments"
        ]
      },
      "relative_timelock": {
        "name": "CSV (CheckSequenceVerify)",
        "description": "Funds locked for relative time after UTXO creation",
        "use_cases": [
          "Lightning channel dispute period",
          "Recovery mechanisms"
        ]
      }
    },
    "taproot": {
      "description": "Bitcoin's major upgrade enabling advanced scripting with privacy",
      "components": {
        "Schnorr_signatures": "More efficient, enables signature aggregation",
        "MAST": "Merkelized Alternative Script Trees - hide unused spending paths",
        "Tapscript": "Updated script version with new opcodes"
      },
      "key_path_spend": "Spend with just a signature (most private)",
      "script_path_spend": "Reveal and execute script branch (for complex conditions)"
    },
    "psbt": {
      "name": "Partially Signed Bitcoin Transaction",
      "description": "Standard format for multi-party transaction signing",
      "workflow": [
        "Creator: Build unsigned transaction",
        "Updater: Add derivation paths, UTXOs, scripts",
        "Signer(s): Add signatures",
        "Combiner: Merge signatures from multiple signers",
        "Finalizer: Complete transaction",
        "Extractor: Get final signed transaction"
      ],
      "use_cases": [
        "Hardware wallet integration",
        "Multi-signature workflows",
        "Air-gapped signing"
      ]
    }
  },
  "lightning_network": {
    "overview": {
      "description": "Layer 2 payment network for instant, low-cost Bitcoin transactions",
      "key_properties": [
        "Near-instant payments (milliseconds)",
        "Very low fees (sub-satoshi possible)",
        "Increased privacy (payments not broadcast)",
        "Final settlement on Bitcoin mainchain"
      ]
    },
    "payment_channels": {
      "description": "Two-party channel for unlimited off-chain transactions",
      "lifecycle": {
        "opening": {
          "steps": [
            "Create funding transaction (2-of-2 multisig)",
            "Exchange commitment transactions",
            "Broadcast funding transaction to mainchain"
          ],
          "on_chain": "1 transaction to open"
        },
        "operating": {
          "steps": [
            "Create new commitment transactions for each payment",
            "Exchange revocation secrets for old states",
            "No on-chain transactions needed"
          ]
        },
        "closing": {
          "cooperative": "Both parties sign closing transaction (1 tx)",
          "unilateral": "One party broadcasts commitment (delayed by timelock)",
          "breach": "If old state broadcast, counterparty can claim all funds"
        }
      }
    },
    "htlc": {
      "name": "Hash Time-Locked Contract",
      "description": "Enables trustless multi-hop payments",
      "components": {
        "hash_lock": "Payment requires preimage of hash",
        "time_lock": "Refund if payment not claimed in time"
      },
      "payment_flow": [
        "Receiver generates secret, shares hash",
        "Sender creates HTLC locked to hash",
        "Intermediate nodes forward HTLCs",
        "Receiver reveals secret to claim",
        "Secret propagates back, all HTLCs settle"
      ]
    },
    "implementations": {
      "LND": {
        "description": "Lightning Network Daemon by Lightning Labs",
        "language": "Go",
        "features": [
          "gRPC API",
          "Watchtower support",
          "Autopilot"
        ]
      },
      "CLN": {
        "description": "Core Lightning (formerly c-lightning)",
        "language": "C",
        "features": [
          "Plugin system",
          "Lightweight",
          "Modular"
        ]
      },
      "Eclair": {
        "description": "ACINQ's implementation",
        "language": "Scala",
        "features": [
          "Mobile-focused",
          "Phoenix wallet"
        ]
      },
      "LDK": {
        "description": "Lightning Dev Kit",
        "language": "Rust",
        "purpose": "Library for building custom Lightning implementations"
      }
    },
    "development_patterns": {
      "invoice_flow": {
        "description": "Standard payment request workflow",
        "steps": [
          "Receiver creates invoice (BOLT 11)",
          "Invoice contains: amount, payment_hash, expiry, route hints",
          "Sender decodes and pays invoice",
          "Receiver reveals preimage to complete"
        ]
      },
      "lnurl": {
        "description": "HTTP-based Lightning interaction protocol",
        "flows": [
          "lnurl-pay: Scan QR, server provides invoice",
          "lnurl-withdraw: Claim funds from service",
          "lnurl-auth: Login with Lightning wallet"
        ]
      },
      "keysend": {
        "description": "Spontaneous payments without invoice",
        "use_case": "Streaming payments, tips"
      }
    }
  },
  "development_tools": {
    "node_software": [
      {
        "name": "Bitcoin Core",
        "purpose": "Full node reference implementation"
      },
      {
        "name": "btcd",
        "purpose": "Go-based full node"
      }
    ],
    "libraries": {
      "python": [
        "python-bitcoinlib",
        "bdk-python"
      ],
      "javascript": [
        "bitcoinjs-lib",
        "bolt11",
        "lnurl-js"
      ],
      "rust": [
        "rust-bitcoin",
        "LDK",
        "BDK"
      ]
    },
    "testing": {
      "regtest": "Local private Bitcoin network for testing",
      "testnet": "Public test network (testnet3 or testnet4)",
      "signet": "Signed test network (more stable)"
    }
  },
  "security_patterns": {
    "key_management": {
      "best_practices": [
        "Use hardware wallets for significant funds",
        "Implement multi-signature for shared custody",
        "Back up seed phrases securely offline",
        "Use hierarchical deterministic (HD) wallets"
      ]
    },
    "transaction_security": {
      "practices": [
        "Verify addresses on hardware wallet display",
        "Use RBF (Replace-By-Fee) for fee bumping",
        "Wait for confirmations based on amount",
        "Implement address reuse prevention"
      ]
    },
    "lightning_security": {
      "practices": [
        "Run watchtower for channel monitoring",
        "Maintain channel backups (SCB)",
        "Set appropriate fee policies",
        "Monitor for force-close attempts"
      ]
    }
  },
  "best_practices": [
    "Use native SegWit (bech32) or Taproot addresses",
    "Implement proper fee estimation",
    "Handle transaction malleability (use SegWit)",
    "Test on testnet/regtest before mainnet",
    "Use established libraries, don't roll your own crypto",
    "Consider privacy implications of UTXO management",
    "For Lightning: maintain balanced channels",
    "Keep software updated for security patches"
  ],
  "patterns": {
    "utxo_management_description": {
      "description": "Track and manage unspent transaction outputs for wallet operations",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# utxo_management_description pattern for bitcoin-patterns\n# Implement based on description: Track and manage unspent transaction outputs for w...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "utxo_management_key_concepts": {
      "description": "['UTXO selection algorithms', 'Fee optimization', 'Privacy considerations']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "utxo_management_usage": {
      "description": "Wallet implementations, transaction construction, coin selection",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# utxo_management_usage pattern for bitcoin-patterns\n# Implement based on description: Wallet implementations, transaction construction, ...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "utxo_management_considerations": {
      "description": "Balance privacy vs fees, avoid address reuse, use coin control",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# utxo_management_considerations pattern for bitcoin-patterns\n# Implement based on description: Balance privacy vs fees, avoid address reuse, use ...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "multi_signature_wallets_description": {
      "description": "Require multiple signatures to spend funds, enhancing security for shared custody",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# multi_signature_wallets_description pattern for bitcoin-patterns\n# Implement based on description: Require multiple signatures to spend funds, enhanc...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "multi_signature_wallets_types": {
      "description": "['M-of-N multisig', 'MuSig2 (Schnorr aggregation)', 'Time-locked multisig']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "multi_signature_wallets_usage": {
      "description": "Company treasuries, escrow, shared accounts, hardware wallet backup",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# multi_signature_wallets_usage pattern for bitcoin-patterns\n# Implement based on description: Company treasuries, escrow, shared accounts, hardw...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "multi_signature_wallets_considerations": {
      "description": "Use P2WSH or Taproot for modern implementations, store keys securely",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# multi_signature_wallets_considerations pattern for bitcoin-patterns\n# Implement based on description: Use P2WSH or Taproot for modern implementations, s...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "lightning_payment_channels_description": {
      "description": "Open payment channel for off-chain transactions, settle on-chain when needed",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# lightning_payment_channels_description pattern for bitcoin-patterns\n# Implement based on description: Open payment channel for off-chain transactions, s...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "lightning_payment_channels_lifecycle": {
      "description": "['Channel opening', 'Off-chain payments', 'Channel closing']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "lightning_payment_channels_usage": {
      "description": "Instant payments, microtransactions, payment routing",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# lightning_payment_channels_usage pattern for bitcoin-patterns\n# Implement based on description: Instant payments, microtransactions, payment routi...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "lightning_payment_channels_considerations": {
      "description": "Maintain channel balance, run watchtower, backup channel state",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# lightning_payment_channels_considerations pattern for bitcoin-patterns\n# Implement based on description: Maintain channel balance, run watchtower, backup c...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "psbt_workflows_description": {
      "description": "Partially Signed Bitcoin Transaction format for multi-party signing",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# psbt_workflows_description pattern for bitcoin-patterns\n# Implement based on description: Partially Signed Bitcoin Transaction format for mu...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "psbt_workflows_stages": {
      "description": "['Creation', 'Updating', 'Signing', 'Combining', 'Finalizing']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "psbt_workflows_usage": {
      "description": "Hardware wallet integration, air-gapped signing, multi-sig coordination",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# psbt_workflows_usage pattern for bitcoin-patterns\n# Implement based on description: Hardware wallet integration, air-gapped signing, m...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "psbt_workflows_considerations": {
      "description": "Validate at each stage, use proper derivation paths, secure transport",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# psbt_workflows_considerations pattern for bitcoin-patterns\n# Implement based on description: Validate at each stage, use proper derivation path...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "taproot_scripting_description": {
      "description": "Advanced scripting with privacy using Schnorr signatures and MAST",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# taproot_scripting_description pattern for bitcoin-patterns\n# Implement based on description: Advanced scripting with privacy using Schnorr sign...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "taproot_scripting_features": {
      "description": "['Key path spending (private)', 'Script path spending (reveals script)']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "taproot_scripting_usage": {
      "description": "Complex conditions, multi-sig, time-locks, while maintaining privacy",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# taproot_scripting_usage pattern for bitcoin-patterns\n# Implement based on description: Complex conditions, multi-sig, time-locks, while m...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "taproot_scripting_considerations": {
      "description": "Most private when using key path, script path reveals conditions",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# taproot_scripting_considerations pattern for bitcoin-patterns\n# Implement based on description: Most private when using key path, script path reve...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "fee_estimation_description": {
      "description": "Estimate appropriate fee rates based on mempool conditions",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# fee_estimation_description pattern for bitcoin-patterns\n# Implement based on description: Estimate appropriate fee rates based on mempool co...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "fee_estimation_methods": {
      "description": "['Mempool analysis', 'Fee rate targeting', 'RBF for fee bumping']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "fee_estimation_usage": {
      "description": "Transaction construction, fee optimization, user experience",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# fee_estimation_usage pattern for bitcoin-patterns\n# Implement based on description: Transaction construction, fee optimization, user e...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "fee_estimation_considerations": {
      "description": "Balance speed vs cost, use RBF for stuck transactions, monitor mempool",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# fee_estimation_considerations pattern for bitcoin-patterns\n# Implement based on description: Balance speed vs cost, use RBF for stuck transacti...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    }
  },
  "anti_patterns": [
    {
      "name": "Address reuse",
      "problem": "Reusing Bitcoin addresses reduces privacy, allows address clustering, and enables transaction graph analysis",
      "fix": "Generate new address for each transaction, use HD wallets with proper derivation paths, implement address rotation"
    },
    {
      "name": "Not verifying addresses on hardware wallet display",
      "problem": "Malware can replace addresses in clipboard or on screen, sending funds to attacker's address",
      "fix": "Always verify recipient address on hardware wallet display before confirming transaction"
    },
    {
      "name": "Using legacy P2PKH addresses for new applications",
      "problem": "Legacy addresses have higher fees, transaction malleability issues, and worse privacy",
      "fix": "Use native SegWit (bech32) addresses starting with 'bc1q' or Taproot addresses starting with 'bc1p'"
    },
    {
      "name": "Insufficient fee estimation",
      "problem": "Transactions with too low fees get stuck in mempool for hours or days, blocking user funds",
      "fix": "Use mempool data to estimate competitive fee rates, implement RBF (Replace-By-Fee) for fee bumping"
    },
    {
      "name": "Not waiting for sufficient confirmations",
      "problem": "Accepting transactions with 0-1 confirmations risks double-spend attacks, especially for high-value transactions",
      "fix": "Wait for 1 confirmation for small amounts, 3-6 confirmations for moderate amounts, 6+ for large amounts"
    }
  ]
}