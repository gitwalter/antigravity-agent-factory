{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "nextjs-advanced-patterns",
  "name": "Next.js Advanced Patterns",
  "description": "Advanced Next.js 16 App Router patterns including parallel routes, intercepting routes, route groups, middleware patterns, ISR, on-demand revalidation, Server Actions, streaming, Edge Runtime, and tRPC integration",
  "version": "1.0.0",
  "category": "patterns",
  "axiomAlignment": {
    "love": "Powerful features that enhance developer experience and user performance",
    "truth": "Patterns based on Next.js official documentation and best practices",
    "beauty": "Elegant routing and data fetching solutions"
  },
  "patterns": {
    "parallel-routes": {
      "name": "Parallel Routes",
      "description": "Simultaneously render multiple pages in the same layout that can be navigated independently",
      "useCase": "Dashboard layouts, multi-column views, conditional layouts",
      "example": "@analytics and @team slots in dashboard layout",
      "benefits": [
        "Independent navigation",
        "Better UX",
        "Conditional rendering"
      ],
      "tradeoffs": [
        "More complex routing",
        "Requires understanding slots"
      ]
    },
    "intercepting-routes": {
      "name": "Intercepting Routes",
      "description": "Load a route while keeping the context of the current page in the background",
      "useCase": "Modals, photo galleries, detail views",
      "example": "@modal/(.)photo/[id] intercepts /photo/[id]",
      "benefits": [
        "Better UX",
        "Maintains context",
        "Smooth transitions"
      ],
      "tradeoffs": [
        "Complex routing structure"
      ]
    },
    "route-groups": {
      "name": "Route Groups",
      "description": "Organize routes without affecting the URL structure using parentheses",
      "useCase": "Organizing routes by feature, different layouts",
      "example": "(marketing) and (shop) route groups",
      "benefits": [
        "Better organization",
        "Shared layouts",
        "No URL impact"
      ],
      "tradeoffs": [
        "Can be confusing"
      ]
    },
    "middleware-patterns": {
      "name": "Middleware Patterns",
      "description": "Run code before a request is completed, modify response",
      "useCase": "Authentication, redirects, header modification, A/B testing",
      "example": "Auth middleware checking tokens, redirecting to login",
      "benefits": [
        "Centralized logic",
        "Performance",
        "Security"
      ],
      "tradeoffs": [
        "Edge runtime limitations"
      ]
    },
    "incremental-static-regeneration-isr": {
      "name": "Incremental Static Regeneration (ISR)",
      "description": "Update static pages after build time without rebuilding entire site",
      "useCase": "Content that changes periodically, product pages, blog posts",
      "example": "revalidate: 3600 for hourly updates",
      "benefits": [
        "Fast static pages",
        "Fresh content",
        "Scalable"
      ],
      "tradeoffs": [
        "Stale data during revalidation"
      ]
    },
    "on-demand-revalidation": {
      "name": "On-Demand Revalidation",
      "description": "Manually trigger revalidation of static pages",
      "useCase": "Content updates, CMS webhooks, admin actions",
      "example": "revalidatePath('/products') after product update",
      "benefits": [
        "Instant updates",
        "Control over caching"
      ],
      "tradeoffs": [
        "Requires API route"
      ]
    },
    "server-actions": {
      "name": "Server Actions",
      "description": "Async functions that run on the server, can be called from Server/Client Components",
      "useCase": "Form submissions, mutations, server-side operations",
      "example": "createUser server action called from form",
      "benefits": [
        "Type-safe",
        "No API routes needed",
        "Progressive enhancement"
      ],
      "tradeoffs": [
        "Server-only",
        "Limited error handling"
      ]
    },
    "streaming-with-suspense": {
      "name": "Streaming with Suspense",
      "description": "Progressively render UI as data becomes available",
      "useCase": "Slow data fetching, multiple data sources, better perceived performance",
      "example": "Suspense boundaries for different data sources",
      "benefits": [
        "Better UX",
        "Faster perceived load",
        "Progressive rendering"
      ],
      "tradeoffs": [
        "Requires Suspense boundaries"
      ]
    },
    "edge-runtime": {
      "name": "Edge Runtime",
      "description": "Run code at the edge for low latency",
      "useCase": "API routes that need low latency, simple logic",
      "example": "Edge API route for geolocation",
      "benefits": [
        "Low latency",
        "Global distribution"
      ],
      "tradeoffs": [
        "Limited Node.js APIs",
        "Smaller runtime"
      ]
    },
    "trpc-integration": {
      "name": "tRPC Integration",
      "description": "End-to-end type-safe APIs with tRPC and Next.js",
      "useCase": "Full-stack TypeScript apps, type-safe API calls",
      "example": "tRPC router with React Query integration",
      "benefits": [
        "Type safety",
        "No code generation",
        "Great DX"
      ],
      "tradeoffs": [
        "TypeScript only",
        "Learning curve"
      ]
    },
    "route-handlers": {
      "name": "Route Handlers",
      "description": "Create custom request handlers for API routes",
      "useCase": "REST APIs, webhooks, custom endpoints",
      "example": "GET/POST handlers in route.ts",
      "benefits": [
        "Flexible",
        "Full control"
      ],
      "tradeoffs": [
        "More boilerplate than Server Actions"
      ]
    },
    "dynamic-route-segments": {
      "name": "Dynamic Route Segments",
      "description": "Create dynamic routes using brackets",
      "useCase": "User profiles, product pages, blog posts",
      "example": "[id]/page.tsx, [...slug]/page.tsx",
      "benefits": [
        "Flexible routing",
        "Type-safe params"
      ],
      "tradeoffs": [
        "Requires proper handling"
      ]
    },
    "loading-states": {
      "name": "Loading States",
      "description": "Automatic loading UI for route segments",
      "useCase": "Show loading state during navigation",
      "example": "loading.tsx file in route segment",
      "benefits": [
        "Better UX",
        "Automatic",
        "Suspense-based"
      ],
      "tradeoffs": [
        "File-based convention"
      ]
    },
    "error-boundaries": {
      "name": "Error Boundaries",
      "description": "Handle errors in route segments",
      "useCase": "Error handling, fallback UI",
      "example": "error.tsx file with error boundary",
      "benefits": [
        "Graceful error handling",
        "Better UX"
      ],
      "tradeoffs": [
        "Client component only"
      ]
    },
    "not-found-pages": {
      "name": "Not Found Pages",
      "description": "Custom 404 pages for route segments",
      "useCase": "Custom 404 UI, nested not-found pages",
      "example": "not-found.tsx file",
      "benefits": [
        "Better UX",
        "Contextual 404s"
      ],
      "tradeoffs": [
        "File-based convention"
      ]
    },
    "metadata-api": {
      "name": "Metadata API",
      "description": "Generate metadata for SEO and social sharing",
      "useCase": "SEO optimization, Open Graph, Twitter Cards",
      "example": "export const metadata in layout/page",
      "benefits": [
        "SEO",
        "Social sharing",
        "Type-safe"
      ],
      "tradeoffs": [
        "Static only in some cases"
      ]
    }
  },
  "best_practices": [
    "Use Server Components by default",
    "Stream content with Suspense",
    "Leverage ISR for dynamic content",
    "Use Server Actions for mutations",
    "Implement proper error boundaries",
    "Optimize with Edge Runtime when appropriate",
    "Use route groups for organization",
    "Implement proper loading states"
  ],
  "anti_patterns": [
    "Using Client Components unnecessarily",
    "Not handling loading/error states",
    "Ignoring SEO metadata",
    "Not using ISR for static content",
    "Overusing Edge Runtime",
    "Not implementing proper error boundaries"
  ]
}