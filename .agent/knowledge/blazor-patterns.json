{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "blazor-patterns",
  "name": "Blazor Patterns",
  "title": "Blazor Development Patterns",
  "description": "Best practices and patterns for building Blazor Server, WebAssembly, and Auto applications including component lifecycle, state management, and SignalR",
  "version": "1.0.0",
  "category": "dotnet",
  "axiomAlignment": {
    "A1_verifiability": "Patterns include testing strategies for component verification",
    "A2_user_primacy": "Component patterns serve user interface and interactivity needs",
    "A3_transparency": "All patterns emphasize clear component structure and state management",
    "A4_non_harm": "Input validation and error boundaries prevent harmful UI states",
    "A5_consistency": "Unified Blazor patterns across Server, WebAssembly, and Auto modes"
  },
  "related_skills": [
    "blazor-development",
    "dotnet-backend",
    "dotnet-auth"
  ],
  "related_knowledge": [
    "dotnet-patterns.json",
    "dotnet-auth-patterns.json"
  ],
  "patterns": {
    "render_modes_server": {
      "description": "Server-side rendering with SignalR connection",
      "use_when": "Real-time updates needed, Small client footprint, Fast initial load",
      "characteristics": {
        "latency": "Network latency affects UI responsiveness",
        "scalability": "Limited by server connections",
        "offline": "Requires constant connection"
      },
      "best_practices": [
        "Optimize SignalR message size",
        "Use circuit reconnection handling",
        "Implement proper state management",
        "Handle connection state changes"
      ],
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "render_modes_webassembly": {
      "description": "Client-side rendering, runs in browser",
      "use_when": "Offline capability needed, Rich client-side interactions, Reduced server load",
      "characteristics": {
        "latency": "No network latency for UI",
        "scalability": "Scales with client devices",
        "offline": "Can work offline with caching"
      },
      "best_practices": [
        "Optimize initial download size",
        "Use lazy loading for assemblies",
        "Implement proper caching",
        "Handle offline scenarios"
      ],
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "render_modes_auto": {
      "description": "Server first, then WebAssembly (.NET 8+)",
      "use_when": "Best of both worlds, Progressive enhancement",
      "characteristics": {
        "initial_load": "Fast server-side initial load",
        "interactivity": "Switches to WebAssembly for interactivity",
        "best_experience": "Combines benefits of both modes"
      },
      "best_practices": [
        "Use for new applications",
        "Leverage server-side rendering initially",
        "Transition to WebAssembly smoothly"
      ],
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "render_modes_ssr": {
      "description": "Static Server-Side Rendering",
      "use_when": "SEO important, Static content, No interactivity needed",
      "characteristics": {
        "performance": "Fast initial render",
        "seo": "Fully crawlable",
        "interactivity": "No client-side interactivity"
      },
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "component_patterns_component_structure": {
      "description": "Organize components effectively",
      "structure": {
        "presentation": "UI-only components",
        "container": "Components with business logic",
        "layout": "Page layout components",
        "shared": "Reusable components"
      },
      "best_practices": [
        "Separate presentation from logic",
        "Use component parameters for data flow",
        "Implement component composition",
        "Create reusable component libraries"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
    },
    "component_patterns_component_lifecycle": {
      "description": "Understand and use component lifecycle methods",
      "methods": {
        "OnInitialized": "Synchronous initialization",
        "OnInitializedAsync": "Async initialization (preferred)",
        "OnParametersSet": "Parameter changes",
        "OnParametersSetAsync": "Async parameter handling",
        "OnAfterRender": "After render completion",
        "OnAfterRenderAsync": "Async post-render operations"
      },
      "best_practices": [
        "Use async lifecycle methods for data loading",
        "Call StateHasChanged() when needed",
        "Implement IAsyncDisposable for cleanup",
        "Avoid blocking calls in lifecycle methods"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
    },
    "component_patterns_parameter_patterns": {
      "description": "Pass data to components",
      "types": {
        "simple": "Primitive types (string, int, etc.)",
        "complex": "Objects and models",
        "event_callbacks": "Parent-child communication",
        "cascading": "Multi-level component communication"
      },
      "best_practices": [
        "Use [Parameter] attribute",
        "Use EventCallback for events",
        "Use CascadingValue for context sharing",
        "Validate parameters"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
    },
    "component_patterns_component_communication": {
      "description": "Communicate between components",
      "patterns": {
        "parent_to_child": "Parameters",
        "child_to_parent": "EventCallback",
        "sibling": "Shared service or state container",
        "cascading": "CascadingValue and CascadingParameter"
      },
      "best_practices": [
        "Use parameters for parent-to-child",
        "Use EventCallback for child-to-parent",
        "Use state container for complex state",
        "Avoid prop drilling with cascading values"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
    },
    "state_management_in_memory": {
      "description": "Component-level state",
      "use_when": "Simple, component-specific state",
      "implementation": "Private fields in component",
      "limitations": "Lost on navigation or refresh",
      "code_example": "Private fields in component",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "state_management_cascading_values": {
      "description": "Share state across component tree",
      "use_when": "Theme, user context, settings",
      "implementation": "CascadingValue component",
      "best_practices": [
        "Use for read-only shared state",
        "Avoid deep cascading hierarchies",
        "Use named cascading values when needed"
      ],
      "code_example": "CascadingValue component"
    },
    "state_management_state_container": {
      "description": "Centralized state management service",
      "use_when": "Complex application state",
      "implementation": "Singleton service with events",
      "best_practices": [
        "Use events to notify components",
        "Call StateHasChanged() in event handlers",
        "Implement proper state immutability"
      ],
      "code_example": "Singleton service with events"
    },
    "state_management_fluxor": {
      "description": "Redux-like state management library",
      "use_when": "Complex state with actions and reducers",
      "features": [
        "Actions",
        "Reducers",
        "Effects",
        "Middleware"
      ],
      "best_practices": [
        "Define clear action types",
        "Keep reducers pure",
        "Use effects for side effects",
        "Implement proper state immutability"
      ],
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "state_management_persistent_storage": {
      "description": "Persist state across sessions",
      "options": [
        "LocalStorage",
        "SessionStorage",
        "IndexedDB",
        "Server-side storage"
      ],
      "best_practices": [
        "Use LocalStorage for user preferences",
        "Use SessionStorage for temporary data",
        "Serialize/deserialize properly",
        "Handle storage quota errors"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "javascript_interop": {
      "description": "Call JavaScript from C# and vice versa",
      "patterns": {
        "csharp_to_javascript": {
          "description": "Call JavaScript functions from C#",
          "implementation": "IJSRuntime.InvokeAsync",
          "use_cases": [
            "DOM manipulation",
            "Third-party libraries",
            "Browser APIs"
          ],
          "best_practices": [
            "Use IJSObjectReference for modules",
            "Dispose JS object references",
            "Handle JavaScript errors",
            "Minimize interop calls"
          ],
          "use_when": "DOM manipulation, Third-party libraries, Browser APIs",
          "code_example": "IJSRuntime.InvokeAsync"
        },
        "javascript_to_csharp": {
          "description": "Call C# methods from JavaScript",
          "implementation": "DotNet.invokeMethodAsync",
          "use_cases": [
            "Event handlers",
            "Callbacks",
            "Third-party integrations"
          ],
          "best_practices": [
            "Use [JSInvokable] attribute",
            "Handle async operations properly",
            "Pass serializable data"
          ],
          "use_when": "Event handlers, Callbacks, Third-party integrations",
          "code_example": "DotNet.invokeMethodAsync"
        },
        "js_modules": {
          "description": "Import JavaScript modules",
          "implementation": "IJSObjectReference",
          "benefits": [
            "Better performance",
            "Module isolation",
            "Reusability"
          ],
          "best_practices": [
            "Import modules in OnAfterRenderAsync",
            "Dispose modules properly",
            "Use async/await"
          ],
          "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
          "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
        }
      },
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "forms_and_validation_editform": {
      "description": "Blazor's form component",
      "features": [
        "Two-way binding",
        "Validation",
        "Model binding"
      ],
      "best_practices": [
        "Use EditForm with Model",
        "Add DataAnnotationsValidator",
        "Use ValidationMessage components",
        "Handle OnValidSubmit"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
    },
    "forms_and_validation_input_components": {
      "description": "Built-in input components",
      "components": [
        "InputText",
        "InputNumber",
        "InputDate",
        "InputCheckbox",
        "InputSelect",
        "InputTextArea"
      ],
      "best_practices": [
        "Use appropriate input type",
        "Add validation attributes",
        "Use ValidationMessage for errors"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
    },
    "forms_and_validation_validation": {
      "description": "Validate form input using DataAnnotations, FluentValidation, or custom validators to ensure data integrity before submission.",
      "methods": {
        "data_annotations": "Built-in validation attributes",
        "fluent_validation": "FluentValidation library",
        "custom_validators": "Custom validation logic"
      },
      "best_practices": [
        "Use DataAnnotations for simple validation",
        "Use FluentValidation for complex rules",
        "Show validation errors clearly",
        "Validate on submit and blur"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "builder.Services.AddDbContext<AppDbContext>(o => o.UseSqlServer(conn));\nvar user = await context.Users.FirstOrDefaultAsync(u => u.Id == id);"
    },
    "authentication_aspnet_identity": {
      "description": "ASP.NET Core Identity integration",
      "features": [
        "User management",
        "Roles",
        "Claims",
        "Two-factor authentication"
      ],
      "best_practices": [
        "Use AuthorizeView component",
        "Check authentication state",
        "Implement role-based authorization",
        "Handle authentication state changes"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "dotnet ef migrations add AddUserTable\ndotnet ef database update\nvar users = await context.Users.Where(u => u.IsActive).ToListAsync();"
    },
    "authentication_authorization": {
      "description": "Control access to components and pages",
      "attributes": [
        "[Authorize]",
        "[Authorize(Roles = \"Admin\")]"
      ],
      "components": [
        "AuthorizeView",
        "CascadingAuthenticationState"
      ],
      "best_practices": [
        "Use AuthorizeView for conditional rendering",
        "Use [Authorize] attribute for pages",
        "Implement policy-based authorization",
        "Handle unauthorized access gracefully"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
    },
    "performance_optimization_techniques_virtualization": {
      "description": "Render only visible items",
      "implementation": "Virtualize component",
      "use_when": "Large lists or tables",
      "benefits": [
        "Reduced DOM elements",
        "Better performance",
        "Lower memory usage"
      ],
      "code_example": "Virtualize component",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "performance_optimization_techniques_lazy_loading": {
      "description": "Load components on demand",
      "implementation": "Lazy loading with Router",
      "use_when": "Large applications with many pages",
      "benefits": [
        "Smaller initial bundle",
        "Faster initial load"
      ],
      "code_example": "Lazy loading with Router",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "performance_optimization_techniques_prerendering": {
      "description": "Render components on server first",
      "implementation": "Server-side rendering",
      "use_when": "SEO important or fast initial load",
      "benefits": [
        "Better SEO",
        "Faster perceived load time"
      ],
      "code_example": "Server-side rendering",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "performance_optimization_techniques_key_directive": {
      "description": "Help Blazor track components in lists",
      "implementation": "@key directive",
      "use_when": "Rendering lists of components",
      "benefits": [
        "Better diffing",
        "Preserved component state"
      ],
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "performance_best_practices": {
      "description": "['Use @key in loops for better performance', 'Implement virtualization for large lists', 'Use lazy loading for large applications', 'Minimize JavaScript interop calls', 'Use ShouldRender() to prevent unnecessary renders', 'Optimize SignalR message size (Server mode)', 'Use compiled bindings for better performance']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "signalr_integration": {
      "description": "Real-time communication with SignalR (Blazor Server)",
      "patterns": {
        "hub_connection": {
          "description": "Connect to SignalR hub",
          "implementation": "HubConnectionBuilder",
          "use_cases": [
            "Real-time updates",
            "Notifications",
            "Chat applications"
          ],
          "use_when": "Real-time updates, Notifications, Chat applications",
          "code_example": "HubConnectionBuilder",
          "best_practices": [
            "Validate inputs and handle errors appropriately",
            "Document the pattern and when to use it"
          ]
        },
        "hub_methods": {
          "description": "Send and receive messages",
          "implementation": "HubConnection.On and SendAsync",
          "best_practices": [
            "Handle connection state",
            "Implement reconnection logic",
            "Dispose connections properly",
            "Handle errors gracefully"
          ],
          "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
          "code_example": "HubConnection.On and SendAsync"
        }
      },
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }",
      "best_practices": [
        "Validate inputs and handle errors appropriately",
        "Document the pattern and when to use it"
      ]
    },
    "testing_unit_testing": {
      "description": "Test components in isolation",
      "tools": [
        "bUnit",
        "xUnit",
        "Moq"
      ],
      "best_practices": [
        "Test component rendering",
        "Test parameter binding",
        "Test event callbacks",
        "Mock dependencies"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
    },
    "testing_integration_testing": {
      "description": "Test component interactions",
      "tools": [
        "Playwright",
        "Selenium",
        "bUnit"
      ],
      "best_practices": [
        "Test user interactions",
        "Test form submission",
        "Test navigation",
        "Test authentication flows"
      ],
      "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
      "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
    }
  },
  "best_practices": [
    "Use async lifecycle methods (OnInitializedAsync) for data loading",
    "Implement IAsyncDisposable for proper cleanup",
    "Use @key directive in loops for better performance",
    "Minimize JavaScript interop calls",
    "Use StateHasChanged() sparingly and appropriately",
    "Implement proper error boundaries",
    "Use cascading values for theme/context sharing",
    "Validate user input with DataAnnotations or FluentValidation",
    "Use AuthorizeView for conditional rendering based on auth",
    "Implement proper loading states",
    "Handle connection state in Blazor Server",
    "Use virtualization for large lists",
    "Optimize bundle size with lazy loading",
    "Use compiled bindings for better performance",
    "Implement proper state management patterns"
  ],
  "anti_patterns": [],
  "use_when": "ASP.NET Core applications, microservices, or Entity Framework data access",
  "code_example": "@page \"/counter\"\n<PageTitle>Counter</PageTitle>\n<h1>Counter</h1>\n<p role=\"status\">Current count: @currentCount</p>\n<button @onclick=\"IncrementCount\">Click me</button>\n@code { private int currentCount = 0; void IncrementCount() => currentCount++; }"
}