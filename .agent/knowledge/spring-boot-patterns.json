{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "spring-boot-patterns",
  "name": "Spring Boot Patterns",
  "title": "Spring Boot Application Patterns",
  "description": "Best practices and patterns for Spring Boot applications including REST APIs, dependency injection, configuration, security, and testing",
  "version": "1.0.0",
  "category": "java",
  "axiomAlignment": {
    "A1_verifiability": "Patterns include testing and validation for verification",
    "A2_user_primacy": "REST APIs and security patterns prioritize user needs and clear boundaries",
    "A3_transparency": "Patterns emphasize logging and observability for transparency",
    "A4_non_harm": "Error handling and validation patterns prevent harmful outcomes",
    "A5_consistency": "Unified Spring Boot patterns across application layers"
  },
  "related_skills": [
    "spring-boot-development",
    "spring-testing",
    "api-design",
    "error-handling",
    "logging-monitoring"
  ],
  "related_knowledge": [
    "spring-observability-patterns.json",
    "spring-microservices-patterns.json",
    "spring-kotlin-patterns.json",
    "error-handling-patterns.json"
  ],
  "patterns": {
    "rest_api_patterns": {
      "description": "REST API design and implementation patterns",
      "controller_patterns": {
        "rest_controller": "@RestController with @RequestMapping",
        "http_methods": "@GetMapping, @PostMapping, @PutMapping, @DeleteMapping",
        "path_variables": "@PathVariable for URL parameters",
        "request_body": "@RequestBody for JSON payloads",
        "response_entity": "ResponseEntity for HTTP status and headers"
      },
      "dto_patterns": {
        "description": "Data Transfer Objects for API requests/responses",
        "best_practices": [
          "Never expose entities directly",
          "Use separate DTOs for requests and responses",
          "Use Bean Validation annotations",
          "Implement proper equals/hashCode"
        ]
      },
      "best_practices": [
        "Use @RestController for REST endpoints",
        "Return ResponseEntity for proper HTTP status codes",
        "Use DTOs instead of entities",
        "Implement proper error handling",
        "Version APIs (/api/v1/)",
        "Use proper HTTP methods",
        "Follow RESTful conventions"
      ],
      "use_when": "When building Java/Spring applications and need rest api patterns",
      "code_example": "@RestController\n@RequestMapping(\"/api/v1/products\")\npublic class ProductController {\n    @GetMapping\n    public ResponseEntity<List<ProductDto>> getProducts() { return ResponseEntity.ok(service.findAll()); }\n    @PostMapping\n    public ResponseEntity<ProductDto> create(@RequestBody @Valid ProductCreateDto dto) { return ResponseEntity.status(201).body(service.create(dto)); }\n}"
    },
    "dependency_injection": {
      "description": "Spring dependency injection patterns",
      "injection_types": {
        "constructor": "Constructor injection (preferred)",
        "field": "Field injection with @Autowired (not recommended)",
        "setter": "Setter injection"
      },
      "bean_scopes": {
        "singleton": "Single instance per container (default)",
        "prototype": "New instance each time",
        "request": "One per HTTP request",
        "session": "One per HTTP session"
      },
      "best_practices": [
        "Use constructor injection",
        "Avoid field injection",
        "Use appropriate bean scopes",
        "Register beans with @Component, @Service, @Repository",
        "Use @Configuration for configuration classes"
      ],
      "use_when": "When building Java/Spring applications and need dependency injection",
      "code_example": "@Service\npublic class ProductService {\n    private final ProductRepository repo;\n    public ProductService(ProductRepository repo) { this.repo = repo; }\n}"
    },
    "configuration_patterns": {
      "description": "Application configuration patterns",
      "properties_files": {
        "application_yml": "YAML format (preferred)",
        "application_properties": "Properties format",
        "profiles": "Environment-specific configs (dev, prod)"
      },
      "configuration_properties": {
        "description": "@ConfigurationProperties for type-safe config",
        "example": "@ConfigurationProperties(prefix = \"app\")",
        "validation": "Use @Validated and Bean Validation"
      },
      "environment_variables": {
        "description": "Use environment variables for sensitive config",
        "pattern": "${ENV_VAR:default-value}",
        "best_practices": [
          "Use for secrets",
          "Provide defaults",
          "Document required variables"
        ]
      },
      "best_practices": [
        "Use YAML for complex config",
        "Use @ConfigurationProperties",
        "Separate by profiles",
        "Use environment variables for secrets",
        "Validate configuration"
      ],
      "use_when": "When building Java/Spring applications and need configuration patterns",
      "code_example": "@ConfigurationProperties(prefix = \"app\")\n@Validated\npublic class AppProperties {\n    private String apiUrl;\n    private int timeout;\n}"
    },
    "transaction_management": {
      "description": "Transaction management patterns",
      "declarative": {
        "description": "@Transactional annotation",
        "attributes": {
          "readOnly": "readOnly = true for queries",
          "propagation": "REQUIRED, REQUIRES_NEW, etc.",
          "isolation": "READ_COMMITTED, SERIALIZABLE, etc.",
          "rollbackFor": "Exceptions that trigger rollback"
        }
      },
      "best_practices": [
        "Use @Transactional on service methods",
        "Set readOnly = true for queries",
        "Handle transaction boundaries properly",
        "Avoid @Transactional on controllers",
        "Use appropriate propagation"
      ],
      "use_when": "When building Java/Spring applications and need transaction management",
      "code_example": "@Transactional(readOnly = true)\npublic List<Product> findAll() { return repo.findAll(); }\n@Transactional(rollbackFor = Exception.class)\npublic Product save(Product p) { return repo.save(p); }"
    },
    "exception_handling": {
      "description": "Exception handling patterns",
      "controller_advice": {
        "description": "@ControllerAdvice for global exception handling",
        "exception_handler": "@ExceptionHandler for specific exceptions",
        "best_practices": [
          "Create GlobalExceptionHandler",
          "Handle validation errors",
          "Return proper error responses",
          "Log exceptions"
        ]
      },
      "custom_exceptions": {
        "description": "Create custom exception classes",
        "pattern": "Extend RuntimeException or checked exceptions",
        "best_practices": [
          "Use meaningful names",
          "Include error codes",
          "Provide context"
        ]
      },
      "best_practices": [
        "Use @ControllerAdvice",
        "Handle all exception types",
        "Return proper HTTP status codes",
        "Log exceptions with context",
        "Don't expose internal details"
      ],
      "use_when": "When building Java/Spring applications and need exception handling",
      "code_example": "@ControllerAdvice\npublic class GlobalExceptionHandler {\n    @ExceptionHandler(ResourceNotFoundException.class)\n    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {\n        return ResponseEntity.status(404).body(new ErrorResponse(ex.getMessage()));\n    }\n}"
    },
    "validation_patterns": {
      "description": "Input validation patterns",
      "bean_validation": {
        "annotations": {
          "@NotNull": "Field cannot be null",
          "@NotBlank": "String cannot be blank",
          "@Size": "Size constraints",
          "@Min/@Max": "Numeric constraints",
          "@Email": "Email validation",
          "@Pattern": "Regex validation"
        },
        "usage": "@Valid on @RequestBody parameters"
      },
      "custom_validators": {
        "description": "Create custom validation annotations",
        "pattern": "Implement ConstraintValidator interface"
      },
      "best_practices": [
        "Use Bean Validation",
        "Validate at controller level",
        "Create custom validators when needed",
        "Return proper validation errors"
      ],
      "use_when": "When building Java/Spring applications and need validation patterns",
      "code_example": "@PostMapping\npublic ResponseEntity<Product> create(@RequestBody @Valid ProductCreateDto dto) {\n    return ResponseEntity.ok(service.create(dto));\n}"
    },
    "security_patterns": {
      "description": "Spring Security patterns",
      "authentication": {
        "jwt": "JWT token authentication",
        "oauth2": "OAuth 2.0 authentication",
        "basic": "HTTP Basic authentication"
      },
      "authorization": {
        "method_security": "@PreAuthorize, @PostAuthorize",
        "url_security": "HttpSecurity configuration",
        "roles": "Role-based access control"
      },
      "best_practices": [
        "Use Spring Security",
        "Implement JWT for stateless auth",
        "Use method security",
        "Configure CORS properly",
        "Use HTTPS in production",
        "Validate tokens"
      ],
      "use_when": "When building Java/Spring applications and need security patterns",
      "code_example": "@EnableWebSecurity\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) { ... }\n}"
    },
    "testing_patterns": {
      "description": "Testing patterns for Spring Boot",
      "unit_tests": {
        "description": "Test individual components",
        "tools": [
          "JUnit 5",
          "Mockito",
          "AssertJ"
        ],
        "pattern": "@ExtendWith(MockitoExtension.class)"
      },
      "integration_tests": {
        "description": "Test with Spring context",
        "annotations": {
          "@SpringBootTest": "Full application context",
          "@WebMvcTest": "Web layer only",
          "@DataJpaTest": "Data layer only"
        },
        "tools": [
          "Testcontainers",
          "MockMvc"
        ]
      },
      "best_practices": [
        "Write unit tests for services",
        "Use @SpringBootTest for integration tests",
        "Use Testcontainers for real databases",
        "Mock external dependencies",
        "Test both success and failure scenarios"
      ],
      "use_when": "When building Java/Spring applications and need testing patterns",
      "code_example": "# Testing Patterns - implement per Java/Spring conventions"
    },
    "logging_patterns": {
      "description": "Logging patterns. This pattern applies to Java/Spring and provides production-ready implementation guidance.",
      "slf4j": {
        "description": "SLF4J logging facade",
        "implementation": "Logback (default)",
        "usage": "LoggerFactory.getLogger(Class.class)"
      },
      "structured_logging": {
        "description": "JSON logging with Logstash encoder",
        "pattern": "logback-spring.xml with LogstashEncoder",
        "mdc": "Mapped Diagnostic Context for correlation IDs"
      },
      "best_practices": [
        "Use structured logging in production",
        "Add correlation IDs",
        "Use appropriate log levels",
        "Don't log sensitive information"
      ],
      "use_when": "When building Java/Spring applications and need logging patterns",
      "code_example": "# Logging Patterns - implement per Java/Spring conventions"
    },
    "async_patterns": {
      "description": "Asynchronous processing patterns",
      "async_annotation": {
        "description": "@Async for async methods",
        "configuration": "@EnableAsync",
        "executor": "Configure ThreadPoolTaskExecutor"
      },
      "completable_future": {
        "description": "CompletableFuture for async operations",
        "usage": "Return CompletableFuture<T>"
      },
      "best_practices": [
        "Use @Async for long-running operations",
        "Configure thread pool",
        "Handle exceptions properly",
        "Use CompletableFuture for composition"
      ],
      "use_when": "When building Java/Spring applications and need async patterns",
      "code_example": "# Async Patterns - implement per Java/Spring conventions"
    },
    "caching_patterns": {
      "description": "Caching patterns. This pattern applies to Java/Spring and provides production-ready implementation guidance.",
      "cache_annotation": {
        "@Cacheable": "Cache method results",
        "@CacheEvict": "Evict cache entries",
        "@CachePut": "Update cache",
        "@Caching": "Multiple cache operations"
      },
      "cache_providers": {
        "caffeine": "Local cache",
        "redis": "Distributed cache",
        "ehcache": "Java cache"
      },
      "best_practices": [
        "Use @Cacheable for expensive operations",
        "Configure cache eviction",
        "Use Redis for distributed caching",
        "Monitor cache hit rates"
      ],
      "use_when": "When building Java/Spring applications and need caching patterns",
      "code_example": "# Caching Patterns - implement per Java/Spring conventions"
    },
    "actuator_patterns": {
      "description": "Spring Boot Actuator patterns",
      "endpoints": {
        "health": "Application health",
        "metrics": "Application metrics",
        "info": "Application information",
        "prometheus": "Prometheus metrics"
      },
      "health_indicators": {
        "description": "Custom health checks",
        "pattern": "Implement HealthIndicator interface"
      },
      "best_practices": [
        "Enable Actuator endpoints",
        "Secure sensitive endpoints",
        "Create custom health indicators",
        "Use health probes for Kubernetes"
      ],
      "use_when": "When building Java/Spring applications and need actuator patterns",
      "code_example": "# Actuator Patterns - implement per Java/Spring conventions"
    }
  },
  "best_practices": [],
  "anti_patterns": []
}