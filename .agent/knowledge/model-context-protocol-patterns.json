{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "model-context-protocol-patterns",
  "name": "Model Context Protocol Patterns",
  "title": "MCP Patterns",
  "description": "Best practices and patterns for Model Context Protocol (MCP) - the open standard for connecting AI agents to external tools, resources, and prompts across frameworks",
  "version": "1.0.0",
  "last_updated": "2026-02-11",
  "category": "integration",
  "axiomAlignment": {
    "A1_verifiability": "MCP standardizes tool interfaces for verification across frameworks",
    "A2_user_primacy": "Approval flows and permissions put users in control",
    "A3_transparency": "Explicit tool/resource/prompt schemas make capabilities clear",
    "A4_non_harm": "Security patterns prevent unauthorized access",
    "A5_consistency": "Unified protocol across all MCP-compatible agents"
  },
  "related_skills": [
    "mcp-integration",
    "tool-usage",
    "security-sandboxing"
  ],
  "related_knowledge": [
    "langchain-patterns.json",
    "anthropic-patterns.json",
    "crewai-patterns.json"
  ],
  "patterns": {
    "mcp_overview": {
      "description": "Model Context Protocol fundamentals",
      "use_when": "Understanding MCP architecture before building servers or integrating agents",
      "code_example": "# MCP configuration in mcp.json\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@anthropic/mcp-filesystem\", \"/allowed/path\"]\n    }\n  }\n}",
      "what_is_mcp": "Open standard for connecting AI assistants to external data sources, tools, and prompts",
      "core_primitives": {
        "tools": "Functions the model can invoke (e.g., search, write_file)",
        "resources": "Data the model can read (e.g., files, database records)",
        "prompts": "Reusable prompt templates for common tasks"
      },
      "architecture": {
        "host": "Application running the AI model (e.g., Claude Desktop, Cursor)",
        "client": "Protocol handler within the host",
        "server": "External service providing tools/resources/prompts"
      },
      "best_practices": [
        "Use MCP for framework-agnostic tool sharing",
        "Follow the host-client-server architecture",
        "Expose tools, resources, and prompts through standard primitives",
        "Leverage cross-platform compatibility"
      ]
    },
    "server_types": {
      "description": "MCP transport mechanisms for server communication",
      "use_when": "Choosing the right transport for MCP server deployment",
      "code_example": "# stdio for local, Streamable HTTP for remote\n# mcp.json\n{\n  \"mcpServers\": {\n    \"local-tool\": {\"command\": \"npx\", \"args\": [\"-y\", \"@anthropic/mcp-filesystem\"]},\n    \"remote-tool\": {\"url\": \"https://api.example.com/mcp\", \"transport\": \"streamable-http\"}\n  }\n}",
      "stdio": {
        "description": "Standard I/O transport for local processes",
        "use_when": "Local single-user tools, development, CLI integration",
        "code_example": "# mcp.json configuration for stdio server\n{\n  \"mcpServers\": {\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@anthropic/mcp-filesystem\", \"/allowed/path\"],\n      \"transport\": \"stdio\"\n    },\n    \"python-tool\": {\n      \"command\": \"python\",\n      \"args\": [\"-m\", \"my_mcp_server\"],\n      \"cwd\": \"/path/to/server\"\n    }\n  }\n}",
        "best_practices": [
          "Use for local development and testing",
          "Restrict file paths with arguments",
          "Set working directory for relative paths"
        ]
      },
      "streamable_http": {
        "description": "HTTP-based transport for scalable remote access (recommended)",
        "use_when": "Production deployments, multi-client access, cloud services",
        "code_example": "# Streamable HTTP server configuration\n{\n  \"mcpServers\": {\n    \"remote-tools\": {\n      \"url\": \"https://mcp.example.com/tools\",\n      \"transport\": \"streamable-http\",\n      \"headers\": {\n        \"Authorization\": \"Bearer ${MCP_API_KEY}\"\n      }\n    }\n  }\n}\n\n# Python server implementation\nfrom mcp.server import Server\nfrom mcp.server.streamable_http import StreamableHTTPServer\n\nserver = Server('my-tools')\n\n@server.tool()\nasync def search(query: str) -> str:\n    \"\"\"Search for information.\"\"\"\n    return f'Results for: {query}'\n\nhttp_server = StreamableHTTPServer(server, port=8080)\nawait http_server.start()",
        "best_practices": [
          "Use for production and multi-user scenarios",
          "Implement authentication with headers",
          "Enable TLS for secure communication",
          "Set up health checks and monitoring"
        ]
      },
      "sse_deprecated": {
        "description": "Server-Sent Events transport (DEPRECATED)",
        "status": "deprecated",
        "migration": "Migrate to Streamable HTTP for new implementations",
        "note": "SSE may still work but is no longer recommended"
      },
      "best_practices": [
        "Use stdio for local development and single-user tools",
        "Use Streamable HTTP for production multi-client deployments",
        "Migrate from SSE to Streamable HTTP",
        "Always implement authentication for remote transports"
      ]
    },
    "building_servers": {
      "description": "Create MCP servers to expose tools and resources",
      "use_when": "Sharing capabilities with MCP-compatible agents",
      "code_example": "from mcp.server import Server\nfrom mcp.server.stdio import StdioServer\nimport asyncio\n\nserver = Server('my-tools')\n\n@server.tool()\nasync def search(query: str) -> str:\n    \"\"\"Search for information.\"\"\"\n    return f'Results for: {query}'\n\nif __name__ == '__main__':\n    asyncio.run(StdioServer(server).run())",
      "python_server": {
        "code_example": "from mcp.server import Server\nfrom mcp.types import Tool, Resource, TextContent\nfrom pydantic import BaseModel\n\n# Create server\nserver = Server('my-tools')\n\n# Define tool with Pydantic schema\nclass SearchParams(BaseModel):\n    query: str\n    max_results: int = 10\n\n@server.tool()\nasync def search_database(params: SearchParams) -> str:\n    \"\"\"Search the internal database.\"\"\"\n    results = await db.search(params.query, limit=params.max_results)\n    return '\\n'.join(results)\n\n# Define resource\n@server.resource('config://app/settings')\nasync def get_settings() -> Resource:\n    \"\"\"Get application settings.\"\"\"\n    settings = await load_settings()\n    return Resource(\n        uri='config://app/settings',\n        name='App Settings',\n        mimeType='application/json',\n        text=json.dumps(settings)\n    )\n\n# Define prompt template\n@server.prompt()\nasync def code_review_prompt(code: str, language: str) -> list:\n    \"\"\"Generate a code review prompt.\"\"\"\n    return [\n        {'role': 'user', 'content': f'Review this {language} code:\\n```{language}\\n{code}\\n```'}\n    ]\n\n# Run server\nif __name__ == '__main__':\n    import asyncio\n    from mcp.server.stdio import StdioServer\n    \n    asyncio.run(StdioServer(server).run())"
      },
      "typescript_server": {
        "code_example": "import { Server } from '@modelcontextprotocol/sdk/server';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio';\n\nconst server = new Server({\n  name: 'my-tools',\n  version: '1.0.0'\n});\n\n// Define tool\nserver.addTool({\n  name: 'search_database',\n  description: 'Search the internal database',\n  inputSchema: {\n    type: 'object',\n    properties: {\n      query: { type: 'string' },\n      maxResults: { type: 'number', default: 10 }\n    },\n    required: ['query']\n  },\n  handler: async (params) => {\n    const results = await db.search(params.query, params.maxResults);\n    return { content: [{ type: 'text', text: results.join('\\n') }] };\n  }\n});\n\n// Run server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);"
      },
      "best_practices": [
        "Use Pydantic models for Python schemas",
        "Provide detailed tool descriptions",
        "Handle errors gracefully with clear messages",
        "Implement proper resource URI schemes"
      ]
    },
    "gateway_pattern": {
      "description": "Centralized MCP gateway for routing and security",
      "use_when": "Managing multiple MCP servers with unified access control",
      "code_example": "from mcp.gateway import MCPGateway, Route, AuthPolicy\n\n# Create gateway\ngateway = MCPGateway(\n    name='enterprise-mcp-gateway',\n    port=8080\n)\n\n# Define routes to backend servers\ngateway.add_route(Route(\n    path='/tools/filesystem',\n    backend='http://localhost:8001',\n    auth_policy=AuthPolicy.REQUIRE_TOKEN,\n    rate_limit='100/minute'\n))\n\ngateway.add_route(Route(\n    path='/tools/database',\n    backend='http://localhost:8002',\n    auth_policy=AuthPolicy.REQUIRE_APPROVAL,\n    allowed_tools=['read_*']  # Wildcard allow\n))\n\ngateway.add_route(Route(\n    path='/tools/github',\n    backend='http://localhost:8003',\n    auth_policy=AuthPolicy.REQUIRE_TOKEN,\n    denied_tools=['delete_*', 'push_*']  # Deny destructive\n))\n\n# Authentication middleware\n@gateway.auth_handler\nasync def verify_token(request):\n    token = request.headers.get('Authorization')\n    if not token or not await validate_jwt(token):\n        return None  # Deny access\n    return {'user_id': decode_jwt(token)['sub']}\n\n# Approval middleware\n@gateway.approval_handler\nasync def request_approval(tool_call, user_context):\n    # Send approval request via Slack, email, etc.\n    approval_id = await send_approval_request(\n        tool=tool_call.tool_name,\n        args=tool_call.args,\n        user=user_context['user_id']\n    )\n    return await wait_for_approval(approval_id, timeout=300)\n\n# Audit logging\n@gateway.on_tool_call\nasync def audit_log(tool_call, user_context, result):\n    await log_to_siem({\n        'event': 'mcp_tool_call',\n        'tool': tool_call.tool_name,\n        'user': user_context['user_id'],\n        'success': result.success\n    })\n\nawait gateway.start()",
      "best_practices": [
        "Use gateway for centralized access control",
        "Implement token-based authentication",
        "Add approval flows for sensitive tools",
        "Log all tool calls for audit"
      ]
    },
    "security_patterns": {
      "description": "Security best practices for MCP deployments",
      "use_when": "Deploying MCP servers in production or multi-tenant environments",
      "code_example": "# Restrict tool access per server\nmcp_config = {\n    'servers': [{\n        'name': 'filesystem',\n        'allowed_tools': ['read_file', 'list_directory'],\n        'allowed_paths': ['/data/public']\n    }]\n}",
      "best_practices": [
        "Apply least privilege - restrict tools and paths",
        "Use authentication for remote MCP servers",
        "Require human approval for destructive operations",
        "Audit all tool calls in production"
      ],
      "least_privilege": {
        "description": "Grant minimum required permissions",
        "code_example": "# In agent configuration\nmcp_config = {\n    'servers': [\n        {\n            'name': 'filesystem',\n            'allowed_tools': ['read_file', 'list_directory'],  # No write\n            'allowed_paths': ['/data/public']  # Restricted paths\n        },\n        {\n            'name': 'database',\n            'allowed_tools': ['select_*'],  # Read-only\n            'denied_tools': ['drop_*', 'delete_*', 'truncate_*']\n        }\n    ]\n}",
        "best_practices": [
          "Whitelist allowed tools explicitly",
          "Deny destructive operations by default",
          "Restrict resource access to specific paths"
        ]
      },
      "authentication": {
        "description": "Authenticate clients to MCP servers",
        "code_example": "# Server-side authentication\nfrom mcp.server import Server\nfrom mcp.server.auth import TokenAuth, JWTAuth\n\nserver = Server('secure-tools')\n\n# Token-based auth\nserver.set_auth(TokenAuth(\n    tokens={\n        'token123': {'user': 'alice', 'roles': ['admin']},\n        'token456': {'user': 'bob', 'roles': ['reader']}\n    }\n))\n\n# Or JWT auth\nserver.set_auth(JWTAuth(\n    issuer='https://auth.example.com',\n    audience='mcp-server',\n    jwks_uri='https://auth.example.com/.well-known/jwks.json'\n))\n\n# Role-based tool access\n@server.tool(roles=['admin'])\nasync def delete_record(id: str) -> str:\n    \"\"\"Delete a record (admin only).\"\"\"\n    await db.delete(id)\n    return f'Deleted {id}'"
      },
      "approval_flows": {
        "description": "Require human approval for sensitive operations",
        "code_example": "from mcp.server import Server\nfrom mcp.server.approval import ApprovalRequired, SlackApprover\n\nserver = Server('sensitive-tools')\n\napprover = SlackApprover(\n    webhook_url=os.environ['SLACK_WEBHOOK'],\n    channel='#approvals',\n    timeout=300\n)\n\n@server.tool()\n@ApprovalRequired(approver, reason='Modifies production data')\nasync def update_production_config(key: str, value: str) -> str:\n    \"\"\"Update production configuration.\"\"\"\n    await config.set(key, value)\n    return f'Updated {key}'",
        "best_practices": [
          "Require approval for destructive actions",
          "Set reasonable timeouts",
          "Provide context for informed decisions",
          "Log all approval decisions"
        ]
      },
      "auditing": {
        "description": "Log all MCP interactions for security monitoring",
        "code_example": "from mcp.server import Server\nfrom mcp.server.audit import AuditLogger, CloudAudit\n\nserver = Server('audited-tools')\n\n# Configure audit logging\naudit = AuditLogger(\n    backends=[\n        CloudAudit(project='my-project'),  # Google Cloud Audit\n        FileAudit(path='/var/log/mcp-audit.json')\n    ],\n    include_args=True,\n    include_results=False,  # Don't log potentially sensitive results\n    redact_patterns=['password', 'secret', 'token']\n)\n\nserver.set_audit_logger(audit)"
      }
    },
    "testing_mcp": {
      "description": "Test MCP servers and integrations",
      "use_when": "Ensuring MCP servers work correctly",
      "code_example": "import pytest\nfrom mcp.testing import MCPTestClient, MockServer\n\n# Unit test MCP server\n@pytest.fixture\nasync def mcp_client():\n    from my_server import server\n    client = MCPTestClient(server)\n    await client.connect()\n    yield client\n    await client.disconnect()\n\nasync def test_search_tool(mcp_client):\n    # List available tools\n    tools = await mcp_client.list_tools()\n    assert 'search_database' in [t.name for t in tools]\n    \n    # Call tool\n    result = await mcp_client.call_tool(\n        'search_database',\n        {'query': 'test', 'max_results': 5}\n    )\n    assert result.success\n    assert len(result.content) > 0\n\nasync def test_resource_access(mcp_client):\n    # List resources\n    resources = await mcp_client.list_resources()\n    assert 'config://app/settings' in [r.uri for r in resources]\n    \n    # Read resource\n    resource = await mcp_client.read_resource('config://app/settings')\n    assert resource.mimeType == 'application/json'\n\n# Integration test with mock server\nasync def test_agent_with_mcp():\n    mock = MockServer()\n    mock.add_tool('search', lambda q: f'Results for {q}')\n    \n    async with mock.run() as server:\n        agent = create_agent(mcp_servers=[server.url])\n        result = await agent.run('Search for Python tutorials')\n        assert 'Results for' in result",
      "best_practices": [
        "Unit test server tools independently",
        "Test resource access permissions",
        "Use mock servers for agent integration tests",
        "Test error handling and edge cases"
      ]
    },
    "packaging": {
      "description": "Package and distribute MCP servers",
      "use_when": "Sharing MCP servers with others",
      "code_example": "# pyproject.toml for Python MCP server\n[project]\nname = \"my-mcp-tools\"\nversion = \"1.0.0\"\n[project.scripts]\nmy-mcp-tools = \"my_mcp_tools.server:main\"\n\n# Install and use: uvx my-mcp-tools",
      "npm_package": {
        "code_example": "// package.json\n{\n  \"name\": \"@myorg/mcp-database-tools\",\n  \"version\": \"1.0.0\",\n  \"bin\": {\n    \"mcp-database\": \"./dist/server.js\"\n  },\n  \"mcp\": {\n    \"name\": \"database-tools\",\n    \"description\": \"Database query and management tools\",\n    \"tools\": [\"query\", \"insert\", \"update\"],\n    \"resources\": [\"schema://tables/*\"]\n  }\n}\n\n// Usage\n// npx @myorg/mcp-database-tools"
      },
      "python_package": {
        "code_example": "# pyproject.toml\n[project]\nname = \"mcp-database-tools\"\nversion = \"1.0.0\"\n\n[project.scripts]\nmcp-database = \"mcp_database:main\"\n\n[project.entry-points.mcp]\nserver = \"mcp_database:server\"\n\n# Usage\n# python -m mcp_database\n# or: mcp-database"
      },
      "best_practices": [
        "Use standard package managers (npm, pip)",
        "Include MCP metadata in package config",
        "Document all tools and resources",
        "Version servers semantically"
      ]
    },
    "observability": {
      "description": "Monitor MCP server health and usage",
      "use_when": "Production MCP deployments",
      "code_example": "from mcp.server import Server\nfrom mcp.server.observability import (\n    PrometheusMetrics,\n    OpenTelemetryTracing,\n    HealthCheck\n)\n\nserver = Server('monitored-tools')\n\n# Prometheus metrics\nmetrics = PrometheusMetrics(port=9090)\nserver.add_middleware(metrics)\n\n# OpenTelemetry tracing\ntracing = OpenTelemetryTracing(\n    service_name='mcp-database-tools',\n    exporter='jaeger',\n    endpoint='http://jaeger:14268/api/traces'\n)\nserver.add_middleware(tracing)\n\n# Health checks\nhealth = HealthCheck(\n    checks=[\n        ('database', lambda: db.ping()),\n        ('redis', lambda: redis.ping())\n    ]\n)\nserver.add_endpoint('/health', health)\n\n# Metrics exposed:\n# - mcp_tool_calls_total\n# - mcp_tool_duration_seconds\n# - mcp_tool_errors_total\n# - mcp_resource_reads_total",
      "best_practices": [
        "Expose Prometheus metrics",
        "Add distributed tracing",
        "Implement health checks",
        "Set up alerting for errors"
      ]
    }
  },
  "best_practices": [
    "Use Streamable HTTP for production deployments (SSE is deprecated)",
    "Use stdio for local development and single-user tools",
    "Implement least-privilege access with allowed_tools whitelists",
    "Require human approval for destructive or sensitive operations",
    "Add authentication (token or JWT) for remote MCP servers",
    "Log all tool calls for audit and security monitoring",
    "Use MCP gateway for centralized routing and access control",
    "Package MCP servers for easy distribution via npm or pip",
    "Enable Prometheus metrics and health checks in production",
    "Test MCP servers with unit and integration tests"
  ],
  "anti_patterns": [
    {
      "name": "Open Access MCP",
      "problem": "Any client can call any tool without authentication",
      "fix": "Implement token or JWT authentication"
    },
    {
      "name": "No Tool Restrictions",
      "problem": "Agent can call destructive tools without oversight",
      "fix": "Use allowed_tools and denied_tools filters"
    },
    {
      "name": "Missing Audit Logs",
      "problem": "Cannot investigate security incidents",
      "fix": "Log all tool calls with context"
    },
    {
      "name": "SSE in Production",
      "problem": "Using deprecated transport",
      "fix": "Migrate to Streamable HTTP"
    },
    {
      "name": "Hardcoded Secrets",
      "problem": "API keys in MCP configuration",
      "fix": "Use environment variables: ${ENV_VAR}"
    }
  ],
  "common_mcp_servers": {
    "official_anthropic": [
      "@anthropic/mcp-filesystem - File system access",
      "@anthropic/mcp-github - GitHub API",
      "@anthropic/mcp-memory - Persistent memory",
      "@anthropic/mcp-slack - Slack integration"
    ],
    "community": [
      "@mcp/postgres - PostgreSQL database",
      "@mcp/redis - Redis cache",
      "@mcp/web-search - Web search APIs",
      "@mcp/browser - Browser automation"
    ]
  },
  "sources": [
    "https://modelcontextprotocol.io/",
    "https://github.com/anthropics/mcp",
    "https://docs.anthropic.com/en/docs/agents-and-tools/mcp"
  ]
}