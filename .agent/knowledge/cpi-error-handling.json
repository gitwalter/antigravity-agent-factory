{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "cpi-error-handling",
  "name": "Cpi Error Handling",
  "title": "CPI Error Handling Patterns",
  "description": "Exception handling, retry strategies, and error routing patterns for SAP CPI",
  "version": "1.0.0",
  "category": "sap",
  "axiomAlignment": {
    "A1_verifiability": "Exception subprocesses and correlation IDs enable traceable error handling",
    "A2_user_primacy": "Proper error handling preserves message integrity and supports reprocessing",
    "A3_transparency": "Explicit error categories and routing make failure handling auditable",
    "A4_non_harm": "Circuit breaker and retry strategies prevent cascading failures",
    "A5_consistency": "Unified error handling patterns across CPI flows ensure predictable behavior"
  },
  "related_skills": [
    "cpi-error-handling",
    "cpi-integration-flow",
    "cpi-groovy-scripting"
  ],
  "related_knowledge": [
    "b2b-patterns.json",
    "mapping-patterns.json",
    "error-handling-patterns.json"
  ],
  "metadata": {
    "name": "CPI Error Handling Patterns",
    "description": "Exception handling, retry strategies, and error routing patterns for SAP CPI",
    "version": "1.0.0",
    "lastUpdated": "2026-01-30"
  },
  "exceptionHandling": {
    "exceptionSubprocess": {
      "description": "Dedicated subprocess for error handling",
      "implementation": "Add Exception Subprocess to integration process",
      "steps": [
        "Capture error details (exception message, stack trace)",
        "Log error with business context",
        "Set error properties for monitoring",
        "Send alert notification if critical",
        "Route to dead letter queue or error handling flow"
      ],
      "properties": [
        {
          "name": "SAP_ErrorModelStepID",
          "description": "Step where error occurred"
        },
        {
          "name": "SAP_ErrorText",
          "description": "Error description"
        },
        {
          "name": "ErrorMessage",
          "description": "Custom error message"
        },
        {
          "name": "ErrorTimestamp",
          "description": "When error occurred"
        },
        {
          "name": "ErrorCorrelationId",
          "description": "Correlation ID for tracing"
        }
      ]
    },
    "tryCatchPattern": {
      "description": "Standard try-catch in Groovy scripts",
      "pattern": "try {\n  // processing logic\n} catch (Exception e) {\n  message.setProperty('ErrorMessage', e.message)\n  message.setProperty('ErrorScript', 'ScriptName')\n  messageLog.addAttachmentAsString('Error', e.stackTrace.join('\\n'), 'text/plain')\n  throw e\n}",
      "bestPractices": [
        "Always log error details before re-throwing",
        "Set meaningful error properties",
        "Include stack trace for debugging",
        "Preserve original exception with cause"
      ]
    }
  },
  "retryStrategies": {
    "immediateRetry": {
      "description": "Retry immediately after failure",
      "useCase": "Transient network issues",
      "configuration": {
        "retryCount": 3,
        "delay": "0s"
      }
    },
    "fixedDelay": {
      "description": "Retry with fixed delay between attempts",
      "useCase": "Rate limiting, temporary unavailability",
      "configuration": {
        "retryCount": 3,
        "delay": "5s"
      }
    },
    "exponentialBackoff": {
      "description": "Increasing delay between retries",
      "useCase": "System recovery, load management",
      "configuration": {
        "retryCount": 5,
        "initialDelay": "1s",
        "multiplier": 2,
        "maxDelay": "60s"
      },
      "pattern": "delays: 1s, 2s, 4s, 8s, 16s"
    },
    "customRetry": {
      "description": "Groovy-based retry with custom logic",
      "pattern": "def maxRetries = 3\ndef retryCount = message.getProperty('RetryCount') ?: 0\nif (retryCount < maxRetries) {\n  message.setProperty('RetryCount', retryCount + 1)\n  sleep(1000 * Math.pow(2, retryCount))\n  // retry logic\n} else {\n  throw new Exception('Max retries exceeded')\n}"
    }
  },
  "errorRouting": {
    "deadLetterChannel": {
      "description": "Route failed messages to error queue",
      "implementation": "JMS queue for failed messages",
      "purposes": [
        "Manual review",
        "Reprocessing",
        "Audit trail"
      ]
    },
    "errorNotification": {
      "description": "Send alerts on error",
      "channels": [
        "Email",
        "Slack webhook",
        "Microsoft Teams",
        "SNMP trap"
      ],
      "content": [
        "Error type",
        "Timestamp",
        "Message ID",
        "Business context"
      ]
    },
    "errorTransformation": {
      "description": "Transform error to standard format",
      "pattern": "Create error response with code, message, details, timestamp"
    }
  },
  "circuitBreaker": {
    "description": "Prevent cascading failures",
    "states": [
      "CLOSED",
      "OPEN",
      "HALF_OPEN"
    ],
    "configuration": {
      "failureThreshold": 5,
      "recoveryTimeout": "60s",
      "successThreshold": 2
    },
    "implementation": "Track failures in property, check before external calls"
  },
  "errorCategories": {
    "transient": {
      "description": "Temporary errors that may resolve",
      "examples": [
        "Network timeout",
        "Service unavailable",
        "Rate limited"
      ],
      "strategy": "Retry with backoff"
    },
    "permanent": {
      "description": "Errors that won't resolve with retry",
      "examples": [
        "Invalid input",
        "Authorization failure",
        "Resource not found"
      ],
      "strategy": "Log and route to error handling"
    },
    "business": {
      "description": "Business rule violations",
      "examples": [
        "Validation failure",
        "Duplicate entry",
        "Insufficient funds"
      ],
      "strategy": "Return business error response"
    }
  },
  "best_practices": [
    "Always implement exception subprocess for production flows - never let errors go unhandled",
    "Use correlation IDs for end-to-end tracing - propagate correlation ID through all integration steps",
    "Log sufficient context for debugging - include message ID, step name, error type, and business context",
    "Distinguish between retryable and non-retryable errors - implement different handling strategies",
    "Set proper alerts for critical errors - configure email/Slack notifications for business-critical failures",
    "Use dead letter queues for message preservation - store failed messages for manual review and reprocessing",
    "Implement idempotency for retry scenarios - use message IDs to prevent duplicate processing",
    "Monitor error rates and patterns - set up dashboards to track error trends and identify issues early",
    "Document error handling in flow documentation - describe error scenarios and handling strategies",
    "Test error scenarios during development - simulate failures to verify error handling works correctly",
    "Use exponential backoff for retries - implement increasing delays (1s, 2s, 4s, 8s) to reduce system load",
    "Implement circuit breaker pattern - prevent cascading failures by stopping calls to failing systems"
  ],
  "anti_patterns": [
    {
      "name": "Swallowing exceptions without logging",
      "problem": "Hidden errors make debugging impossible and cause silent failures in production",
      "fix": "Always log exception details with messageLog before re-throwing or routing to error handler"
    },
    {
      "name": "Retrying non-retryable errors indefinitely",
      "problem": "Retrying permanent errors (like invalid input) wastes resources and delays error notification",
      "fix": "Categorize errors (transient vs permanent), only retry transient errors with backoff"
    },
    {
      "name": "Not preserving original message on error",
      "problem": "Lost original messages prevent reprocessing and make root cause analysis difficult",
      "fix": "Store original message in dead letter queue or error storage before error transformation"
    },
    {
      "name": "Missing correlation IDs for tracing",
      "problem": "Without correlation IDs, tracing messages across systems and debugging issues is impossible",
      "fix": "Generate correlation ID at flow start, propagate through all steps, include in all logs"
    },
    {
      "name": "Logging sensitive data in error messages",
      "problem": "Logging PII, passwords, or payment data violates security policies and compliance",
      "fix": "Mask sensitive fields in logs, use placeholders for sensitive data, log only error context"
    },
    {
      "name": "Not implementing circuit breaker for external calls",
      "problem": "Continued calls to failing systems cause cascading failures and resource exhaustion",
      "fix": "Track failure counts, open circuit after threshold, attempt recovery after timeout"
    },
    {
      "name": "Ignoring error monitoring and alerting",
      "problem": "Unmonitored errors go undetected until users report issues, causing extended downtime",
      "fix": "Set up error rate monitoring, configure alerts for critical errors, review error patterns regularly"
    }
  ],
  "patterns": {
    "general": {
      "description": "Reference documentation",
      "usage": "See detailed sections below",
      "use_when": "When implementing general or when Reference documentation",
      "code_example": "try {\n  def body = message.getBody(String)\n  // process\n} catch (Exception e) {\n  message.setProperty('ErrorMessage', e.message)\n  throw e\n}",
      "best_practices": [
        "Always implement exception subprocess for production flows - never let errors go unhandled",
        "Use correlation IDs for end-to-end tracing - propagate correlation ID through all integration steps",
        "Log sufficient context for debugging - include message ID, step name, error type, and business context",
        "Distinguish between retryable and non-retryable errors - implement different handling strategies"
      ]
    }
  }
}
