{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "prisma-database-patterns",
  "name": "Prisma Database Patterns",
  "description": "Prisma ORM patterns including schema design, relations (1:1, 1:N, M:N), enums, composite types, middleware, transactions, raw queries, seeding, migrations, type-safe patterns, and performance optimization",
  "version": "1.0.0",
  "category": "patterns",
  "axiomAlignment": {
    "love": "Type-safe database access that delights developers",
    "truth": "Patterns based on Prisma best practices and real-world usage",
    "beauty": "Elegant schema design and query patterns"
  },
  "patterns": {
    "schema-design": {
      "name": "Schema Design",
      "description": "Designing Prisma schemas with proper types, relations, and constraints",
      "useCase": "All database modeling",
      "example": "User model with proper types and relations",
      "benefits": [
        "Type safety",
        "Database constraints",
        "Documentation"
      ],
      "tradeoffs": [
        "Requires migrations"
      ]
    },
    "one-to-one-relations": {
      "name": "One-to-One Relations",
      "description": "Model 1:1 relationships between models",
      "useCase": "User-Profile, Order-Invoice relationships",
      "example": "User has one Profile, Profile belongs to one User",
      "benefits": [
        "Clear relationships",
        "Type-safe"
      ],
      "tradeoffs": [
        "Requires unique constraint"
      ]
    },
    "one-to-many-relations": {
      "name": "One-to-Many Relations",
      "description": "Model 1:N relationships between models",
      "useCase": "User-Posts, Category-Products relationships",
      "example": "User has many Posts, Post belongs to one User",
      "benefits": [
        "Common pattern",
        "Easy to query"
      ],
      "tradeoffs": [
        "None significant"
      ]
    },
    "many-to-many-relations": {
      "name": "Many-to-Many Relations",
      "description": "Model M:N relationships using intermediate table",
      "useCase": "Post-Tags, User-Roles relationships",
      "example": "PostTag intermediate model connecting Post and Tag",
      "benefits": [
        "Flexible",
        "Can add extra fields"
      ],
      "tradeoffs": [
        "More complex queries"
      ]
    },
    "self-relations": {
      "name": "Self-Relations",
      "description": "Model relationships within the same model",
      "useCase": "User-Manager, Category-Parent relationships",
      "example": "User has manager and directReports",
      "benefits": [
        "Flexible hierarchies"
      ],
      "tradeoffs": [
        "Can be complex"
      ]
    },
    "enums": {
      "name": "Enums",
      "description": "Define enumerated types in schema",
      "useCase": "Status fields, roles, categories",
      "example": "enum Role { USER, ADMIN, MODERATOR }",
      "benefits": [
        "Type safety",
        "Database constraints"
      ],
      "tradeoffs": [
        "Requires migration to change"
      ]
    },
    "composite-types": {
      "name": "Composite Types",
      "description": "Group fields together (MongoDB only)",
      "useCase": "Address, contact information",
      "example": "type Address { street, city, zipCode }",
      "benefits": [
        "Better organization"
      ],
      "tradeoffs": [
        "MongoDB only"
      ]
    },
    "transactions": {
      "name": "Transactions",
      "description": "Execute multiple operations atomically",
      "useCase": "Operations that must succeed or fail together",
      "example": "Create user and profile in transaction",
      "benefits": [
        "Data consistency",
        "Rollback on error"
      ],
      "tradeoffs": [
        "Performance overhead"
      ]
    },
    "raw-queries": {
      "name": "Raw Queries",
      "description": "Execute raw SQL queries when needed",
      "useCase": "Complex queries, database-specific features",
      "example": "$queryRaw with SQL template",
      "benefits": [
        "Full SQL power",
        "Performance"
      ],
      "tradeoffs": [
        "No type safety",
        "Database-specific"
      ]
    },
    "migrations": {
      "name": "Migrations",
      "description": "Version control database schema changes",
      "useCase": "All schema changes",
      "example": "prisma migrate dev --name add_user_role",
      "benefits": [
        "Version control",
        "Reproducible",
        "Team collaboration"
      ],
      "tradeoffs": [
        "Requires discipline"
      ]
    },
    "seeding": {
      "name": "Seeding",
      "description": "Populate database with initial/test data",
      "useCase": "Development, testing, demo data",
      "example": "prisma/seed.ts with sample data",
      "benefits": [
        "Consistent test data",
        "Easy setup"
      ],
      "tradeoffs": [
        "Requires maintenance"
      ]
    },
    "query-optimization": {
      "name": "Query Optimization",
      "description": "Optimize queries with select, include, pagination",
      "useCase": "Performance optimization",
      "example": "Select only needed fields, use pagination",
      "benefits": [
        "Better performance",
        "Reduced data transfer"
      ],
      "tradeoffs": [
        "More complex queries"
      ]
    },
    "middleware": {
      "name": "Middleware",
      "description": "Intercept and modify queries",
      "useCase": "Logging, soft deletes, query modification",
      "example": "Logging middleware, soft delete middleware",
      "benefits": [
        "Cross-cutting concerns",
        "Reusable logic"
      ],
      "tradeoffs": [
        "Can affect performance"
      ]
    },
    "connection-pooling": {
      "name": "Connection Pooling",
      "description": "Reuse database connections efficiently",
      "useCase": "Production applications",
      "example": "Prisma Client with connection pool",
      "benefits": [
        "Better performance",
        "Resource efficiency"
      ],
      "tradeoffs": [
        "Requires configuration"
      ]
    },
    "type-safe-queries": {
      "name": "Type-Safe Queries",
      "description": "Leverage TypeScript types from Prisma schema",
      "useCase": "All queries",
      "example": "Typed queries with autocomplete",
      "benefits": [
        "Type safety",
        "Better DX",
        "Fewer bugs"
      ],
      "tradeoffs": [
        "Requires TypeScript"
      ]
    }
  },
  "best_practices": [
    "Always use migrations for schema changes",
    "Use transactions for related operations",
    "Select only needed fields",
    "Use indexes for frequently queried fields",
    "Implement connection pooling",
    "Use enums for fixed value sets",
    "Leverage type safety",
    "Optimize queries with select/include"
  ],
  "anti_patterns": [
    "Modifying database directly",
    "Not using transactions when needed",
    "Fetching all fields unnecessarily",
    "Not using indexes",
    "Ignoring type safety",
    "Not handling errors properly",
    "Not using migrations"
  ]
}