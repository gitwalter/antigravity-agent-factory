{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "ERC Token Standards",
  "description": "Ethereum Request for Comments token standards and implementation patterns",
  "version": "1.0.0",
  "standards": {
    "ERC20": {
      "title": "Fungible Token Standard",
      "eip": "EIP-20",
      "description": "Standard interface for fungible tokens",
      "use_when": "Creating currencies, utility tokens, governance tokens",
      "required_functions": [
        "totalSupply() \u2192 uint256",
        "balanceOf(address) \u2192 uint256",
        "transfer(address to, uint256 amount) \u2192 bool",
        "allowance(address owner, address spender) \u2192 uint256",
        "approve(address spender, uint256 amount) \u2192 bool",
        "transferFrom(address from, address to, uint256 amount) \u2192 bool"
      ],
      "required_events": [
        "Transfer(address indexed from, address indexed to, uint256 value)",
        "Approval(address indexed owner, address indexed spender, uint256 value)"
      ],
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyToken is ERC20, ERC20Burnable, ERC20Permit, Ownable {\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) ERC20Permit(name) Ownable(msg.sender) {\n        _mint(msg.sender, initialSupply * 10 ** decimals());\n    }\n    \n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n}",
      "extensions": {
        "ERC20Burnable": "Allows token holders to burn their tokens",
        "ERC20Capped": "Enforces maximum supply",
        "ERC20Pausable": "Allows pausing all transfers",
        "ERC20Permit": "Gasless approvals via signatures (EIP-2612)",
        "ERC20Votes": "Voting and delegation for governance",
        "ERC20Snapshot": "Historical balance snapshots",
        "ERC20FlashMint": "Built-in flash loan capability"
      },
      "best_practices": [
        "Use OpenZeppelin implementation",
        "Consider adding Permit for gasless approvals",
        "Emit Transfer event from address(0) for mints",
        "Emit Transfer event to address(0) for burns"
      ],
      "common_issues": [
        "Missing return values (use SafeERC20 for interactions)",
        "Rebase tokens break composability",
        "Fee-on-transfer tokens need special handling"
      ]
    },
    "ERC721": {
      "title": "Non-Fungible Token Standard",
      "eip": "EIP-721",
      "description": "Standard interface for non-fungible tokens (NFTs)",
      "use_when": "Unique assets, collectibles, art, real estate tokenization",
      "required_functions": [
        "balanceOf(address owner) \u2192 uint256",
        "ownerOf(uint256 tokenId) \u2192 address",
        "safeTransferFrom(address from, address to, uint256 tokenId, bytes data)",
        "safeTransferFrom(address from, address to, uint256 tokenId)",
        "transferFrom(address from, address to, uint256 tokenId)",
        "approve(address to, uint256 tokenId)",
        "setApprovalForAll(address operator, bool approved)",
        "getApproved(uint256 tokenId) \u2192 address",
        "isApprovedForAll(address owner, address operator) \u2192 bool"
      ],
      "required_events": [
        "Transfer(address indexed from, address indexed to, uint256 indexed tokenId)",
        "Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)",
        "ApprovalForAll(address indexed owner, address indexed operator, bool approved)"
      ],
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyNFT is ERC721, ERC721Enumerable, ERC721URIStorage, ERC721Royalty, Ownable {\n    uint256 private _nextTokenId;\n    uint256 public constant MAX_SUPPLY = 10000;\n    uint256 public mintPrice = 0.01 ether;\n    \n    constructor() ERC721(\"MyNFT\", \"MNFT\") Ownable(msg.sender) {\n        _setDefaultRoyalty(msg.sender, 250); // 2.5% royalty\n    }\n    \n    function mint(address to, string memory uri) external payable {\n        require(msg.value >= mintPrice, \"Insufficient payment\");\n        require(_nextTokenId < MAX_SUPPLY, \"Max supply reached\");\n        \n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n        _setTokenURI(tokenId, uri);\n    }\n    \n    // Required overrides\n    function _update(address to, uint256 tokenId, address auth)\n        internal override(ERC721, ERC721Enumerable) returns (address) {\n        return super._update(to, tokenId, auth);\n    }\n    \n    function _increaseBalance(address account, uint128 value)\n        internal override(ERC721, ERC721Enumerable) {\n        super._increaseBalance(account, value);\n    }\n    \n    function tokenURI(uint256 tokenId)\n        public view override(ERC721, ERC721URIStorage) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n    \n    function supportsInterface(bytes4 interfaceId)\n        public view override(ERC721, ERC721Enumerable, ERC721URIStorage, ERC721Royalty)\n        returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}",
      "extensions": {
        "ERC721Enumerable": "Enumeration of all tokens and per-owner tokens",
        "ERC721URIStorage": "Storage-based token URI management",
        "ERC721Burnable": "Allows token holders to burn NFTs",
        "ERC721Pausable": "Allows pausing all transfers",
        "ERC721Royalty": "On-chain royalty info (EIP-2981)",
        "ERC721Votes": "Voting and delegation for governance"
      },
      "metadata_standard": {
        "description": "JSON metadata format for NFTs",
        "schema": {
          "name": "Asset name",
          "description": "Asset description",
          "image": "URI to image (IPFS recommended)",
          "external_url": "External link",
          "attributes": "[{trait_type, value}]"
        }
      }
    },
    "ERC1155": {
      "title": "Multi-Token Standard",
      "eip": "EIP-1155",
      "description": "Standard for contracts managing multiple token types",
      "use_when": "Games with multiple item types, mixed fungible/non-fungible tokens",
      "benefits": [
        "Single contract for multiple token types",
        "Batch transfers for gas efficiency",
        "Mixed fungible and non-fungible tokens"
      ],
      "required_functions": [
        "balanceOf(address account, uint256 id) \u2192 uint256",
        "balanceOfBatch(address[] accounts, uint256[] ids) \u2192 uint256[]",
        "setApprovalForAll(address operator, bool approved)",
        "isApprovedForAll(address account, address operator) \u2192 bool",
        "safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes data)",
        "safeBatchTransferFrom(address from, address to, uint256[] ids, uint256[] amounts, bytes data)"
      ],
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract GameItems is ERC1155, ERC1155Supply, Ownable {\n    uint256 public constant GOLD = 0;\n    uint256 public constant SILVER = 1;\n    uint256 public constant SWORD = 2;\n    uint256 public constant SHIELD = 3;\n    \n    constructor() ERC1155(\"https://game.example/api/item/{id}.json\") Ownable(msg.sender) {\n        _mint(msg.sender, GOLD, 10**18, \"\");\n        _mint(msg.sender, SILVER, 10**27, \"\");\n    }\n    \n    function mint(address account, uint256 id, uint256 amount, bytes memory data)\n        external onlyOwner {\n        _mint(account, id, amount, data);\n    }\n    \n    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)\n        external onlyOwner {\n        _mintBatch(to, ids, amounts, data);\n    }\n    \n    function _update(address from, address to, uint256[] memory ids, uint256[] memory values)\n        internal override(ERC1155, ERC1155Supply) {\n        super._update(from, to, ids, values);\n    }\n}"
    },
    "ERC4626": {
      "title": "Tokenized Vault Standard",
      "eip": "EIP-4626",
      "description": "Standard for tokenized yield-bearing vaults",
      "use_when": "Yield aggregators, lending pools, staking contracts",
      "benefits": [
        "Standardized interface for all yield-bearing tokens",
        "Easy composability between DeFi protocols",
        "Built-in share price calculation"
      ],
      "required_functions": [
        "asset() \u2192 address",
        "totalAssets() \u2192 uint256",
        "convertToShares(uint256 assets) \u2192 uint256",
        "convertToAssets(uint256 shares) \u2192 uint256",
        "maxDeposit(address receiver) \u2192 uint256",
        "previewDeposit(uint256 assets) \u2192 uint256",
        "deposit(uint256 assets, address receiver) \u2192 uint256",
        "maxMint(address receiver) \u2192 uint256",
        "previewMint(uint256 shares) \u2192 uint256",
        "mint(uint256 shares, address receiver) \u2192 uint256",
        "maxWithdraw(address owner) \u2192 uint256",
        "previewWithdraw(uint256 assets) \u2192 uint256",
        "withdraw(uint256 assets, address receiver, address owner) \u2192 uint256",
        "maxRedeem(address owner) \u2192 uint256",
        "previewRedeem(uint256 shares) \u2192 uint256",
        "redeem(uint256 shares, address receiver, address owner) \u2192 uint256"
      ],
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\n\ncontract SimpleVault is ERC4626 {\n    constructor(IERC20 asset_)\n        ERC4626(asset_)\n        ERC20(\"Vault Token\", \"vTKN\")\n    {}\n    \n    function totalAssets() public view override returns (uint256) {\n        return IERC20(asset()).balanceOf(address(this));\n    }\n}",
      "security_considerations": [
        "Inflation attack: First depositor manipulation",
        "Rounding direction: Always round against the user",
        "Donation attacks: Track internal vs external balances"
      ]
    },
    "ERC2981": {
      "title": "NFT Royalty Standard",
      "eip": "EIP-2981",
      "description": "Standard for retrieving royalty payment information",
      "use_when": "NFTs with creator royalties",
      "interface": "royaltyInfo(uint256 tokenId, uint256 salePrice) \u2192 (address receiver, uint256 royaltyAmount)",
      "note": "Marketplaces must voluntarily respect royalties"
    },
    "ERC2612": {
      "title": "Permit Extension for ERC20",
      "eip": "EIP-2612",
      "description": "Gasless token approvals via signatures",
      "benefits": [
        "Users don't need ETH for approvals",
        "One transaction instead of approve + transfer",
        "Better UX for new users"
      ],
      "function": "permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)"
    }
  },
  "implementation_checklist": {
    "all_tokens": [
      "Use OpenZeppelin implementations",
      "Emit all required events",
      "Implement supportsInterface (EIP-165)",
      "Add NatSpec documentation",
      "Write comprehensive tests"
    ],
    "ERC20_specific": [
      "Consider permit for gasless approvals",
      "Handle decimals correctly (typically 18)",
      "Consider max supply cap"
    ],
    "ERC721_specific": [
      "Use _safeMint to verify receiver",
      "Implement proper metadata URI",
      "Consider royalties (ERC2981)"
    ],
    "ERC1155_specific": [
      "Use batch operations for efficiency",
      "Implement proper URI with {id} substitution",
      "Consider supply tracking extension"
    ]
  },
  "id": "erc-standards",
  "name": "Erc Standards",
  "category": "patterns",
  "patterns": {
    "erc-standards-base": {
      "name": "Base Erc Standards Pattern",
      "description": "Standard pattern for Erc Standards",
      "usage": "Use as a starting point for this category.",
      "use_when": "When implementing erc-standards-base",
      "code_example": "// Example for erc-standards-base",
      "best_practices": [
        "Use appropriately for best results.",
        "Monitor results and optimize."
      ]
    }
  },
  "best_practices": [],
  "anti_patterns": [],
  "axiomAlignment": {
    "A1_verifiability": "Patterns are verified through automated testing.",
    "A2_user_primacy": "The user maintains control over all generated output.",
    "A3_transparency": "All automated actions are logged and verifiable.",
    "A4_non_harm": "Strict safety checks prevent destructive operations.",
    "A5_consistency": "Uniform patterns ensure predictable system behavior."
  },
  "related_skills": [
    "onboarding-flow"
  ],
  "related_knowledge": [
    "manifest.json"
  ]
}
