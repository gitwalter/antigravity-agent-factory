{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "defi-protocol-patterns",
  "name": "DeFi Protocol Patterns",
  "title": "DeFi Protocol Patterns",
  "description": "Design patterns for decentralized finance protocols",
  "version": "1.0.0",
  "category": "specialized",
  "axiomAlignment": {
    "A1_verifiability": "On-chain state and events enable full protocol verification",
    "A2_user_primacy": "Slippage protection and withdrawal control prioritize users",
    "A3_transparency": "All DeFi patterns emphasize transparent, verifiable operations",
    "A4_non_harm": "Patterns include safety mechanisms to protect user funds",
    "A5_consistency": "Unified patterns for AMM, lending, vaults, and oracles"
  },
  "related_skills": [
    "error-handling",
    "security-sandboxing",
    "ai-cost-optimization"
  ],
  "related_knowledge": [
    "solidity-patterns.json",
    "solana-patterns.json",
    "bitcoin-patterns.json"
  ],
  "amm_patterns": {
    "constant_product": {
      "description": "x * y = k automated market maker (Uniswap V2 style)",
      "formula": "x * y = k (constant product invariant)",
      "use_when": "General-purpose token swaps",
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract ConstantProductAMM is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    \n    IERC20 public immutable token0;\n    IERC20 public immutable token1;\n    \n    uint256 public reserve0;\n    uint256 public reserve1;\n    \n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    \n    uint256 public constant FEE_DENOMINATOR = 1000;\n    uint256 public constant FEE_NUMERATOR = 3; // 0.3% fee\n    \n    event Swap(address indexed sender, uint256 amountIn, uint256 amountOut, bool zeroForOne);\n    event AddLiquidity(address indexed provider, uint256 amount0, uint256 amount1, uint256 lpTokens);\n    event RemoveLiquidity(address indexed provider, uint256 amount0, uint256 amount1, uint256 lpTokens);\n    \n    constructor(address _token0, address _token1) {\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n    \n    function swap(address tokenIn, uint256 amountIn) external nonReentrant returns (uint256 amountOut) {\n        require(tokenIn == address(token0) || tokenIn == address(token1), \"Invalid token\");\n        require(amountIn > 0, \"Amount must be > 0\");\n        \n        bool isToken0 = tokenIn == address(token0);\n        (IERC20 tokenInContract, IERC20 tokenOutContract, uint256 reserveIn, uint256 reserveOut) = \n            isToken0 \n                ? (token0, token1, reserve0, reserve1) \n                : (token1, token0, reserve1, reserve0);\n        \n        tokenInContract.safeTransferFrom(msg.sender, address(this), amountIn);\n        \n        // Apply fee\n        uint256 amountInWithFee = amountIn * (FEE_DENOMINATOR - FEE_NUMERATOR);\n        amountOut = (reserveOut * amountInWithFee) / (reserveIn * FEE_DENOMINATOR + amountInWithFee);\n        \n        tokenOutContract.safeTransfer(msg.sender, amountOut);\n        \n        _updateReserves();\n        emit Swap(msg.sender, amountIn, amountOut, isToken0);\n    }\n    \n    function _updateReserves() private {\n        reserve0 = token0.balanceOf(address(this));\n        reserve1 = token1.balanceOf(address(this));\n    }\n}",
      "best_practices": [
        "Use ReentrancyGuard on all swap functions",
        "Emit events for all swaps",
        "Include slippage protection in frontend",
        "Consider price impact for large trades"
      ],
      "limitations": [
        "Capital inefficient for correlated assets",
        "Impermanent loss for liquidity providers"
      ]
    },
    "concentrated_liquidity": {
      "description": "Liquidity within price ranges (Uniswap V3 style)",
      "use_when": "Capital-efficient liquidity for predictable price ranges",
      "key_concepts": [
        "Tick-based pricing",
        "Position NFTs for LP tracking",
        "Just-in-time liquidity"
      ],
      "reference": "Uniswap V3 Whitepaper"
    },
    "stableswap": {
      "description": "Optimized for stable asset swaps (Curve style)",
      "formula": "Hybrid constant sum + constant product",
      "use_when": "Trading between pegged assets (USDC/USDT/DAI)",
      "benefits": [
        "Very low slippage for pegged assets",
        "High capital efficiency"
      ]
    }
  },
  "lending_patterns": {
    "overcollateralized_lending": {
      "description": "Borrow against collateral with safety margin",
      "use_when": "Trustless lending without credit checks",
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ninterface IPriceOracle {\n    function getPrice(address token) external view returns (uint256);\n}\n\ncontract LendingPool is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    \n    struct Position {\n        uint256 collateralAmount;\n        uint256 borrowedAmount;\n        address collateralToken;\n    }\n    \n    mapping(address => Position) public positions;\n    \n    IERC20 public immutable borrowToken;\n    IPriceOracle public immutable oracle;\n    \n    uint256 public constant COLLATERAL_FACTOR = 75; // 75% LTV\n    uint256 public constant LIQUIDATION_THRESHOLD = 80; // 80% triggers liquidation\n    uint256 public constant LIQUIDATION_BONUS = 5; // 5% bonus for liquidators\n    \n    event Deposit(address indexed user, address indexed collateral, uint256 amount);\n    event Borrow(address indexed user, uint256 amount);\n    event Repay(address indexed user, uint256 amount);\n    event Liquidate(address indexed user, address indexed liquidator, uint256 collateralSeized);\n    \n    function deposit(address collateralToken, uint256 amount) external nonReentrant {\n        IERC20(collateralToken).safeTransferFrom(msg.sender, address(this), amount);\n        \n        positions[msg.sender].collateralAmount += amount;\n        positions[msg.sender].collateralToken = collateralToken;\n        \n        emit Deposit(msg.sender, collateralToken, amount);\n    }\n    \n    function borrow(uint256 amount) external nonReentrant {\n        Position storage pos = positions[msg.sender];\n        \n        uint256 collateralValue = _getCollateralValue(pos);\n        uint256 maxBorrow = (collateralValue * COLLATERAL_FACTOR) / 100;\n        \n        require(pos.borrowedAmount + amount <= maxBorrow, \"Insufficient collateral\");\n        \n        pos.borrowedAmount += amount;\n        borrowToken.safeTransfer(msg.sender, amount);\n        \n        emit Borrow(msg.sender, amount);\n    }\n    \n    function liquidate(address user) external nonReentrant {\n        Position storage pos = positions[user];\n        require(_isLiquidatable(pos), \"Position healthy\");\n        \n        uint256 collateralToSeize = pos.collateralAmount * (100 + LIQUIDATION_BONUS) / 100;\n        \n        // Liquidator repays debt\n        borrowToken.safeTransferFrom(msg.sender, address(this), pos.borrowedAmount);\n        \n        // Liquidator receives collateral\n        IERC20(pos.collateralToken).safeTransfer(msg.sender, collateralToSeize);\n        \n        emit Liquidate(user, msg.sender, collateralToSeize);\n        \n        delete positions[user];\n    }\n    \n    function _getCollateralValue(Position storage pos) internal view returns (uint256) {\n        return pos.collateralAmount * oracle.getPrice(pos.collateralToken) / 1e18;\n    }\n    \n    function _isLiquidatable(Position storage pos) internal view returns (bool) {\n        uint256 collateralValue = _getCollateralValue(pos);\n        uint256 threshold = (collateralValue * LIQUIDATION_THRESHOLD) / 100;\n        return pos.borrowedAmount > threshold;\n    }\n}",
      "key_parameters": [
        "Collateral Factor (LTV): Maximum borrow relative to collateral",
        "Liquidation Threshold: When positions become liquidatable",
        "Liquidation Bonus: Incentive for liquidators"
      ],
      "risks": [
        "Oracle manipulation",
        "Cascading liquidations",
        "Bad debt if liquidation fails"
      ]
    },
    "flash_loans": {
      "description": "Uncollateralized loans repaid in same transaction",
      "use_when": "Arbitrage, collateral swaps, liquidations",
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IFlashLoanReceiver {\n    function executeOperation(\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata params\n    ) external returns (bool);\n}\n\ncontract FlashLoanProvider {\n    using SafeERC20 for IERC20;\n    \n    uint256 public constant FLASH_LOAN_FEE = 9; // 0.09% fee\n    uint256 public constant FEE_PRECISION = 10000;\n    \n    event FlashLoan(address indexed receiver, address indexed token, uint256 amount, uint256 fee);\n    \n    function flashLoan(\n        address receiver,\n        address token,\n        uint256 amount,\n        bytes calldata params\n    ) external {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        require(balanceBefore >= amount, \"Insufficient liquidity\");\n        \n        uint256 fee = (amount * FLASH_LOAN_FEE) / FEE_PRECISION;\n        \n        IERC20(token).safeTransfer(receiver, amount);\n        \n        require(\n            IFlashLoanReceiver(receiver).executeOperation(token, amount, fee, params),\n            \"Flash loan failed\"\n        );\n        \n        uint256 balanceAfter = IERC20(token).balanceOf(address(this));\n        require(balanceAfter >= balanceBefore + fee, \"Flash loan not repaid\");\n        \n        emit FlashLoan(receiver, token, amount, fee);\n    }\n}",
      "security_notes": [
        "Entire operation must succeed or revert",
        "Cannot use flash loans for governance attacks if properly designed",
        "Protocols should use TWAP oracles to resist manipulation"
      ]
    }
  },
  "staking_patterns": {
    "simple_staking": {
      "description": "Stake tokens to earn rewards",
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract StakingRewards is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    \n    IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardsToken;\n    \n    uint256 public rewardRate; // Rewards per second\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public balances;\n    \n    uint256 public totalSupply;\n    \n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    \n    constructor(address _stakingToken, address _rewardsToken) {\n        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IERC20(_rewardsToken);\n    }\n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = block.timestamp;\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) return rewardPerTokenStored;\n        return rewardPerTokenStored + \n            ((block.timestamp - lastUpdateTime) * rewardRate * 1e18) / totalSupply;\n    }\n    \n    function earned(address account) public view returns (uint256) {\n        return (balances[account] * (rewardPerToken() - userRewardPerTokenPaid[account])) / 1e18 \n            + rewards[account];\n    }\n    \n    function stake(uint256 amount) external nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        totalSupply += amount;\n        balances[msg.sender] += amount;\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    function withdraw(uint256 amount) external nonReentrant updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        totalSupply -= amount;\n        balances[msg.sender] -= amount;\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    function getReward() external nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            rewardsToken.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n}",
      "best_practices": [
        "Use updateReward modifier for accurate reward tracking",
        "Implement ReentrancyGuard",
        "Consider adding emergency withdraw function"
      ]
    },
    "vote_escrow": {
      "description": "Lock tokens for voting power (ve-token model)",
      "use_when": "Governance with time-weighted voting",
      "key_concepts": [
        "Longer lock = more voting power",
        "Voting power decays linearly",
        "Non-transferable positions"
      ],
      "reference": "Curve veCRV model"
    }
  },
  "vault_patterns": {
    "erc4626_vault": {
      "description": "Standardized yield-bearing vault (EIP-4626)",
      "use_when": "Any tokenized yield strategy",
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract YieldVault is ERC4626 {\n    constructor(\n        IERC20 asset_,\n        string memory name_,\n        string memory symbol_\n    ) ERC4626(asset_) ERC20(name_, symbol_) {}\n    \n    function totalAssets() public view override returns (uint256) {\n        // Return total assets under management\n        return IERC20(asset()).balanceOf(address(this)) + _getExternalYield();\n    }\n    \n    function _getExternalYield() internal view returns (uint256) {\n        // Override to add yield from external protocols\n        return 0;\n    }\n    \n    function harvest() external {\n        // Collect and reinvest yield\n    }\n}",
      "standard_functions": [
        "deposit(assets, receiver) \u2192 shares",
        "mint(shares, receiver) \u2192 assets",
        "withdraw(assets, receiver, owner) \u2192 shares",
        "redeem(shares, receiver, owner) \u2192 assets"
      ],
      "benefits": [
        "Standardized interface for integrations",
        "Automatic share price calculation",
        "Composability with other DeFi protocols"
      ]
    }
  },
  "oracle_patterns": {
    "chainlink_integration": {
      "description": "Use Chainlink decentralized price feeds",
      "code_example": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract PriceConsumer {\n    AggregatorV3Interface internal immutable priceFeed;\n    \n    uint256 public constant STALENESS_THRESHOLD = 1 hours;\n    \n    constructor(address _priceFeed) {\n        priceFeed = AggregatorV3Interface(_priceFeed);\n    }\n    \n    function getLatestPrice() public view returns (int256) {\n        (\n            uint80 roundId,\n            int256 price,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        \n        require(price > 0, \"Invalid price\");\n        require(updatedAt > 0, \"Round not complete\");\n        require(block.timestamp - updatedAt < STALENESS_THRESHOLD, \"Stale price\");\n        require(answeredInRound >= roundId, \"Stale round\");\n        \n        return price;\n    }\n    \n    function getDecimals() public view returns (uint8) {\n        return priceFeed.decimals();\n    }\n}",
      "validation_checks": [
        "Price is positive",
        "Round is complete",
        "Data is not stale",
        "Answered in current round"
      ]
    },
    "twap_oracle": {
      "description": "Time-weighted average price from AMM",
      "use_when": "Need manipulation-resistant price",
      "key_concepts": [
        "Accumulate price over time",
        "Query price difference over period",
        "Resistant to single-block manipulation"
      ]
    }
  },
  "governance_patterns": {
    "token_voting": {
      "description": "Governance by token holders",
      "implementation": "OpenZeppelin Governor",
      "key_parameters": [
        "Voting delay: Time before voting starts",
        "Voting period: Duration of voting",
        "Quorum: Minimum participation required",
        "Proposal threshold: Tokens needed to propose"
      ]
    },
    "timelock": {
      "description": "Delay execution of governance decisions",
      "use_when": "Allow users to exit before changes take effect",
      "implementation": "OpenZeppelin TimelockController"
    }
  },
  "security_patterns": {
    "pausable": {
      "description": "Emergency pause functionality",
      "implementation": "OpenZeppelin Pausable",
      "use_when": "Need circuit breaker for emergencies"
    },
    "rate_limiting": {
      "description": "Limit withdrawal amounts over time",
      "use_when": "Reduce impact of exploits"
    }
  },
  "patterns": {
    "constant_product_amm_description": {
      "description": "Uniswap V2-style AMM using x * y = k invariant for token swaps",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# constant_product_amm_description pattern for defi-patterns\n# Implement based on description: Uniswap V2-style AMM using x * y = k invariant for...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "constant_product_amm_use_case": {
      "description": "General-purpose DEX for any token pair",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# constant_product_amm_use_case pattern for defi-patterns\n# Implement based on description: General-purpose DEX for any token pair...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "constant_product_amm_benefits": {
      "description": "['Simple implementation', 'Always has liquidity', 'No order book needed']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "constant_product_amm_limitations": {
      "description": "['Capital inefficient', 'Impermanent loss for LPs', 'High slippage for large trades']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "overcollateralized_lending_description": {
      "description": "Lending protocol requiring collateral exceeding loan value with liquidation mechanism",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# overcollateralized_lending_description pattern for defi-patterns\n# Implement based on description: Lending protocol requiring collateral exceeding lo...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "overcollateralized_lending_use_case": {
      "description": "Trustless lending without credit checks, borrowing against crypto assets",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# overcollateralized_lending_use_case pattern for defi-patterns\n# Implement based on description: Trustless lending without credit checks, borrowing...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "overcollateralized_lending_key_parameters": {
      "description": "['Collateral factor (LTV)', 'Liquidation threshold', 'Liquidation bonus']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "overcollateralized_lending_risks": {
      "description": "['Oracle manipulation', 'Cascading liquidations', 'Bad debt accumulation']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "flash_loans_description": {
      "description": "Uncollateralized loans that must be repaid in same transaction",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# flash_loans_description pattern for defi-patterns\n# Implement based on description: Uncollateralized loans that must be repaid in same...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "flash_loans_use_case": {
      "description": "Arbitrage, collateral swaps, liquidations, complex DeFi strategies",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# flash_loans_use_case pattern for defi-patterns\n# Implement based on description: Arbitrage, collateral swaps, liquidations, complex...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "flash_loans_security": {
      "description": "Entire operation reverts if not repaid, cannot be used for governance attacks if properly designed",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# flash_loans_security pattern for defi-patterns\n# Implement based on description: Entire operation reverts if not repaid, cannot be ...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "flash_loans_considerations": {
      "description": "Protocols should use TWAP oracles to resist flash loan manipulation",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# flash_loans_considerations pattern for defi-patterns\n# Implement based on description: Protocols should use TWAP oracles to resist flash ...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "staking_rewards_description": {
      "description": "Distribute rewards proportional to staked amount and time staked",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# staking_rewards_description pattern for defi-patterns\n# Implement based on description: Distribute rewards proportional to staked amount a...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "staking_rewards_use_case": {
      "description": "Token staking, liquidity mining, protocol governance participation",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# staking_rewards_use_case pattern for defi-patterns\n# Implement based on description: Token staking, liquidity mining, protocol governan...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "staking_rewards_implementation": {
      "description": "Track rewardPerToken, update on stake/unstake, use updateReward modifier",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# staking_rewards_implementation pattern for defi-patterns\n# Implement based on description: Track rewardPerToken, update on stake/unstake, use...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "staking_rewards_considerations": {
      "description": "Handle reward token supply, consider vesting periods",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# staking_rewards_considerations pattern for defi-patterns\n# Implement based on description: Handle reward token supply, consider vesting perio...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "erc4626_vault_description": {
      "description": "Standardized yield-bearing vault interface for tokenized strategies",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# erc4626_vault_description pattern for defi-patterns\n# Implement based on description: Standardized yield-bearing vault interface for tok...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "erc4626_vault_use_case": {
      "description": "Any yield strategy that should be composable with other DeFi protocols",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# erc4626_vault_use_case pattern for defi-patterns\n# Implement based on description: Any yield strategy that should be composable with ...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "erc4626_vault_benefits": {
      "description": "['Standard interface', 'Automatic share calculation', 'Composability']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "erc4626_vault_functions": {
      "description": "['deposit/mint', 'withdraw/redeem', 'totalAssets for share price']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "oracle_integration_description": {
      "description": "Fetch and validate price data from decentralized oracle networks",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# oracle_integration_description pattern for defi-patterns\n# Implement based on description: Fetch and validate price data from decentralized o...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "oracle_integration_providers": {
      "description": "['Chainlink', 'TWAP from AMM', 'Multiple oracle aggregation']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "oracle_integration_validation": {
      "description": "['Check price staleness', 'Verify round completeness', 'Validate price > 0']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    },
    "oracle_integration_security": {
      "description": "Use TWAP for manipulation resistance, check multiple sources for critical operations",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# oracle_integration_security pattern for defi-patterns\n# Implement based on description: Use TWAP for manipulation resistance, check multip...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    }
  },
  "best_practices": [
    "Always use ReentrancyGuard on all functions that make external calls or transfer tokens",
    "Implement slippage protection in frontend and require minimum output amounts in smart contracts",
    "Use time-weighted average price (TWAP) oracles instead of spot prices to resist manipulation",
    "Validate all account ownership and relationships before trusting account data in Solana programs",
    "Implement circuit breakers and pause functionality for emergency situations",
    "Use established libraries like OpenZeppelin for Ethereum and Anchor for Solana instead of custom implementations",
    "Emit events for all state changes to enable off-chain indexing and monitoring",
    "Get professional security audits before mainnet deployment, especially for protocols handling user funds"
  ],
  "anti_patterns": [
    {
      "name": "Using spot price oracles without manipulation protection",
      "problem": "Flash loans can manipulate spot prices in single transaction, draining protocol funds",
      "solution": "Use TWAP oracles, Chainlink price feeds with staleness checks, or aggregate multiple oracle sources"
    },
    {
      "name": "Missing reentrancy protection on external calls",
      "problem": "Attacker can re-enter function before state updates, draining funds or bypassing checks",
      "solution": "Use ReentrancyGuard, follow Checks-Effects-Interactions pattern, update state before external calls"
    },
    {
      "name": "Not validating account ownership in Solana programs",
      "problem": "Attacker can pass fake accounts with crafted data, bypassing security checks",
      "solution": "Always use Anchor's Account<'info, T> type or manually verify account.owner matches expected program"
    },
    {
      "name": "Allowing arbitrary program invocation in CPI",
      "problem": "Attacker can invoke malicious program, causing unexpected behavior or fund loss",
      "solution": "Verify program_id matches expected value before CPI, use Anchor's Program<'info, T> type"
    },
    {
      "name": "Missing access control on privileged functions",
      "problem": "Anyone can call admin functions, change parameters, or drain protocol funds",
      "solution": "Use OpenZeppelin Ownable or AccessControl, verify signers in Solana, implement multi-sig for critical operations"
    }
  ]
}