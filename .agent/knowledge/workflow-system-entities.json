{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "workflow-entities",
  "name": "Workflow System Entities",
  "title": "Workflow System Entities",
  "description": "Entity definitions and relationships for the Cursor Agent Factory Workflow System",
  "version": "1.0.0",
  "category": "workflows",
  "philosophy": "Workflows are the choreography of intelligence - composing agents, skills, knowledge, and tools into purposeful action sequences that learn and improve over time.",
  "entities": {
    "workflow": {
      "name": "Workflow",
      "description": "A complete orchestrated process that achieves a specific goal through coordinated phases, steps, and decisions",
      "purpose": "Define autonomous multi-step processes that can diagnose, decide, act, and learn",
      "keyProperties": [
        "id",
        "name",
        "version",
        "triggers",
        "phases",
        "decisionPoints",
        "escalations",
        "learningHooks"
      ],
      "relationships": {
        "contains": [
          "phase",
          "decisionPoint",
          "escalation",
          "learningHook"
        ],
        "activatedBy": [
          "trigger"
        ],
        "references": [
          "knowledge"
        ],
        "requires": [
          "mcpRequirement"
        ],
        "tracks": [
          "state"
        ]
      },
      "examples": [
        "debug-pipeline-failure",
        "onboarding-new-developer",
        "code-review-automation",
        "incident-response"
      ]
    },
    "trigger": {
      "name": "Trigger",
      "description": "A condition or event that activates a workflow",
      "purpose": "Define when and how workflows are started",
      "types": {
        "event": {
          "description": "External system sends a signal",
          "examples": [
            "GitHub Actions failure webhook",
            "Jira issue created"
          ]
        },
        "manual": {
          "description": "User explicitly requests activation",
          "examples": [
            "'Debug this failure'",
            "'Run code review'"
          ]
        },
        "schedule": {
          "description": "Time-based activation",
          "examples": [
            "Every day at midnight",
            "Every 6 hours"
          ]
        },
        "watch": {
          "description": "File or state change detection",
          "examples": [
            "Config file modified",
            "Error log updated"
          ]
        },
        "chain": {
          "description": "Another workflow completes",
          "examples": [
            "Post-deployment verification",
            "Cleanup after build"
          ]
        },
        "webhook": {
          "description": "HTTP endpoint receives request",
          "examples": [
            "CI/CD callback",
            "External service notification"
          ]
        }
      },
      "relationships": {
        "activates": [
          "workflow"
        ]
      }
    },
    "phase": {
      "name": "Phase",
      "description": "A logical grouping of related steps within a workflow",
      "purpose": "Organize workflow execution into meaningful chunks with clear goals",
      "keyProperties": [
        "id",
        "name",
        "goal",
        "steps",
        "parallel",
        "timeout",
        "onFailure"
      ],
      "relationships": {
        "containedBy": [
          "workflow"
        ],
        "contains": [
          "step",
          "decisionPoint"
        ],
        "mayTrigger": [
          "escalation"
        ],
        "transitionsTo": [
          "phase"
        ]
      },
      "examples": [
        "diagnosis",
        "resolution",
        "verification",
        "learning"
      ]
    },
    "step": {
      "name": "Step",
      "description": "An atomic unit of work within a phase",
      "purpose": "Execute a single, focused action using skills or MCP tools",
      "keyProperties": [
        "id",
        "name",
        "skill",
        "inputs",
        "outputs",
        "timeout",
        "retry"
      ],
      "relationships": {
        "containedBy": [
          "phase"
        ],
        "invokes": [
          "skill"
        ],
        "executes": [
          "action"
        ],
        "uses": [
          "mcpTool"
        ],
        "produces": [
          "output"
        ]
      },
      "examples": [
        "parse-error-log",
        "identify-root-cause",
        "apply-fix",
        "run-tests"
      ]
    },
    "skill": {
      "name": "Skill",
      "description": "A reusable capability that can be invoked by workflow steps",
      "purpose": "Encapsulate complex behaviors as composable, testable units",
      "location": ".cursor/skills/{skill-id}/SKILL.md",
      "keyProperties": [
        "name",
        "description",
        "triggers",
        "inputs",
        "outputs",
        "knowledge",
        "mcpServers"
      ],
      "relationships": {
        "invokedBy": [
          "step"
        ],
        "uses": [
          "knowledge",
          "mcpServer"
        ],
        "mayInvoke": [
          "skill"
        ]
      },
      "categories": [
        "diagnostic",
        "resolution",
        "research",
        "generation",
        "validation"
      ],
      "examples": [
        "log-analysis",
        "root-cause-analysis",
        "test-rewrite",
        "code-fix",
        "mcp-manager"
      ]
    },
    "mcpServer": {
      "name": "MCP Server",
      "description": "An external tool integration providing capabilities via Model Context Protocol",
      "purpose": "Connect workflows to external services, APIs, and tools",
      "catalogLocation": "knowledge/mcp-servers-catalog.json",
      "keyProperties": [
        "id",
        "name",
        "transport",
        "authentication",
        "capabilities",
        "tools"
      ],
      "relationships": {
        "requiredBy": [
          "workflow",
          "skill"
        ],
        "provides": [
          "mcpTool"
        ],
        "mayFallbackTo": [
          "mcpServer"
        ]
      },
      "categories": [
        "core",
        "code",
        "data",
        "cloud",
        "collab",
        "aiml"
      ],
      "examples": [
        "github",
        "sentry",
        "brave-search",
        "context7"
      ]
    },
    "mcpTool": {
      "name": "MCP Tool",
      "description": "A specific capability exposed by an MCP server",
      "purpose": "Perform actions in external systems",
      "keyProperties": [
        "name",
        "description",
        "parameters",
        "returns"
      ],
      "relationships": {
        "providedBy": [
          "mcpServer"
        ],
        "usedBy": [
          "step"
        ]
      },
      "examples": [
        "github.get_workflow_run",
        "brave-search.brave_web_search",
        "sentry.get_issue"
      ]
    },
    "knowledge": {
      "name": "Knowledge",
      "description": "Structured reference data that informs workflow decisions",
      "purpose": "Provide context, patterns, and historical data for intelligent decision-making",
      "location": "knowledge/{name}.json",
      "keyProperties": [
        "title",
        "description",
        "version",
        "content"
      ],
      "relationships": {
        "referencedBy": [
          "workflow",
          "skill"
        ],
        "updatedBy": [
          "learningHook"
        ]
      },
      "categories": [
        "patterns",
        "strategies",
        "lessons",
        "catalogs",
        "schemas"
      ],
      "examples": [
        "error-patterns.json",
        "fix-strategies.json",
        "lessons-learned.json",
        "mcp-servers-catalog.json"
      ]
    },
    "decisionPoint": {
      "name": "Decision Point",
      "description": "A conditional branching point in workflow execution",
      "purpose": "Enable dynamic workflow paths based on runtime conditions",
      "keyProperties": [
        "id",
        "evaluate",
        "branches",
        "default"
      ],
      "relationships": {
        "containedBy": [
          "workflow",
          "phase"
        ],
        "branchesTo": [
          "phase",
          "step"
        ],
        "mayTrigger": [
          "escalation"
        ]
      },
      "examples": [
        "confidence-check",
        "error-type-routing",
        "capability-detection"
      ]
    },
    "branch": {
      "name": "Branch",
      "description": "A possible path from a decision point",
      "purpose": "Define conditions and destinations for workflow routing",
      "keyProperties": [
        "condition",
        "goto",
        "action",
        "escalation"
      ],
      "relationships": {
        "containedBy": [
          "decisionPoint"
        ],
        "goesTo": [
          "phase",
          "step"
        ],
        "triggers": [
          "escalation"
        ]
      }
    },
    "escalation": {
      "name": "Escalation",
      "description": "A point where human involvement is requested",
      "purpose": "Ensure human oversight for uncertain or high-risk situations",
      "keyProperties": [
        "id",
        "trigger",
        "method",
        "prompt",
        "timeout",
        "onTimeout"
      ],
      "methods": {
        "interactive": "Pause execution and ask user",
        "notification": "Inform user but continue",
        "issue": "Create tracking issue for later",
        "abort": "Stop workflow entirely",
        "fallback": "Try alternative approach"
      },
      "relationships": {
        "containedBy": [
          "workflow"
        ],
        "triggeredBy": [
          "phase",
          "step",
          "decisionPoint"
        ],
        "resumesTo": [
          "phase",
          "step"
        ]
      },
      "examples": [
        "confirm-destructive-action",
        "request-credentials",
        "low-confidence-fix"
      ]
    },
    "state": {
      "name": "State",
      "description": "Runtime tracking of workflow progress and collected data",
      "purpose": "Enable resume, debugging, and progress visibility",
      "keyProperties": [
        "currentPhase",
        "currentStep",
        "startTime",
        "attempts",
        "collectedEvidence",
        "outputs"
      ],
      "relationships": {
        "trackedBy": [
          "workflow"
        ],
        "persistedTo": [
          "stateStore"
        ],
        "restoredFrom": [
          "checkpoint"
        ]
      }
    },
    "learningHook": {
      "name": "Learning Hook",
      "description": "A capture point for continuous improvement",
      "purpose": "Extract patterns from workflow execution to improve future performance",
      "keyProperties": [
        "event",
        "capture",
        "store",
        "transform",
        "actions"
      ],
      "events": [
        "workflow_success",
        "workflow_failure",
        "step_complete",
        "step_failure",
        "escalation_resolved",
        "user_correction"
      ],
      "relationships": {
        "containedBy": [
          "workflow"
        ],
        "updates": [
          "knowledge"
        ],
        "capturesFrom": [
          "step",
          "phase",
          "escalation"
        ]
      },
      "examples": [
        "capture-successful-fix",
        "record-failed-attempt",
        "integrate-user-feedback"
      ]
    },
    "output": {
      "name": "Output",
      "description": "Data produced by a step for use by subsequent steps",
      "purpose": "Enable data flow between workflow steps",
      "keyProperties": [
        "name",
        "type",
        "required",
        "value"
      ],
      "relationships": {
        "producedBy": [
          "step"
        ],
        "consumedBy": [
          "step",
          "decisionPoint"
        ]
      }
    }
  },
  "relationships": {
    "summary": "The workflow system forms a hierarchy: Workflows contain Phases, Phases contain Steps. Steps invoke Skills and use MCP Tools. Decision Points route between Phases. Escalations involve humans. Learning Hooks update Knowledge for continuous improvement.",
    "diagram": "See docs/research/WORKFLOW_SYSTEM.md for visual diagrams"
  },
  "lifecycleStates": {
    "workflow": [
      "idle",
      "triggered",
      "validating",
      "initializing",
      "acquiringMCP",
      "needsAuth",
      "executing",
      "decisionPoint",
      "researching",
      "escalating",
      "paused",
      "verifying",
      "learning",
      "completed",
      "failed",
      "cancelled"
    ],
    "phase": [
      "pending",
      "executing",
      "completed",
      "failed",
      "skipped"
    ],
    "step": [
      "pending",
      "executing",
      "retrying",
      "completed",
      "failed",
      "skipped"
    ]
  },
  "expressionLanguage": {
    "description": "Expression syntax for referencing values in workflows",
    "syntax": "${expression}",
    "references": {
      "context": "${context.fieldName}",
      "steps": "${steps.stepId.outputs.outputName}",
      "phases": "${phases.phaseId.outputs.outputName}",
      "knowledge": "${knowledge.fileName.jsonPath}",
      "state": "${state.fieldName}",
      "env": "${env.VARIABLE_NAME}",
      "workflow": "${workflow.id|name|duration}"
    },
    "functions": {
      "uuid": "Generate unique identifier",
      "now": "Current timestamp",
      "contains": "Array/string contains check",
      "length": "Array/string length"
    }
  },
  "extensionPoints": {
    "customSkills": {
      "description": "Add new skills in .cursor/skills/{id}/SKILL.md",
      "process": "Define inputs, outputs, process steps, and dependencies"
    },
    "customMCPServers": {
      "description": "Add servers to knowledge/mcp-servers-catalog.json",
      "process": "Define server metadata, authentication, and tools"
    },
    "customKnowledge": {
      "description": "Add knowledge files to knowledge/ directory",
      "process": "Create JSON with appropriate schema"
    },
    "workflowInheritance": {
      "description": "Extend existing workflows with 'extends' property",
      "process": "Override phases, steps, or add new elements"
    }
  },
  "relatedDocuments": [
    {
      "name": "WORKFLOW_SYSTEM.md",
      "path": "docs/research/WORKFLOW_SYSTEM.md",
      "purpose": "Conceptual architecture for humans"
    },
    {
      "name": "WORKFLOW_AUTHORING.md",
      "path": "docs/WORKFLOW_AUTHORING.md",
      "purpose": "Practical guide for creating workflows"
    },
    {
      "name": "WORKFLOW_PATTERNS.md",
      "path": "docs/reference/WORKFLOW_PATTERNS.md",
      "purpose": "Reusable workflow pattern catalog"
    },
    {
      "name": "workflow-schema.json",
      "path": "knowledge/schemas/workflow-schema.json",
      "purpose": "JSON Schema for validation"
    }
  ],
  "patterns": {
    "entity_composition": {
      "name": "Entity Composition Pattern",
      "description": "Workflows contain Phases, Phases contain Steps. Steps invoke Skills and use MCP Tools. Clear containment hierarchy enables predictable execution.",
      "usage": "When designing workflows, follow the containment hierarchy: Workflow \u2192 Phase \u2192 Step \u2192 Skill/MCP Tool"
    },
    "state_persistence": {
      "name": "State Persistence Pattern",
      "description": "Capture workflow state after each phase completion. Enable resume from checkpoints on failure.",
      "usage": "Implement checkpointing in state entity. Store phase outputs, current position, and collected evidence"
    },
    "expression_reference": {
      "name": "Expression Reference Pattern",
      "description": "Use ${expression} syntax to reference outputs from previous steps, context values, and knowledge files.",
      "usage": "Reference step outputs: ${steps.stepId.outputs.outputName}. Reference context: ${context.fieldName}"
    },
    "delegation_through_skills": {
      "name": "Delegation Through Skills Pattern",
      "description": "Steps delegate work to Skills rather than directly invoking tools. Skills encapsulate reusable capabilities.",
      "usage": "Define skills in .cursor/skills/{id}/SKILL.md. Reference skills by ID in step definitions"
    },
    "escalation_resolution": {
      "name": "Escalation Resolution Pattern",
      "description": "When escalation occurs, store escalation context in state. Define resumeTo path for continuation after human response.",
      "usage": "Set escalation.resumeTo to phase or step ID. Store user response in state for workflow continuation"
    },
    "learning_hook_capture": {
      "name": "Learning Hook Capture Pattern",
      "description": "After critical phases, capture patterns, outcomes, and lessons to knowledge files for continuous improvement.",
      "usage": "Define learningHook events (workflow_success, step_failure). Transform captured data and update knowledge files"
    }
  },
  "best_practices": [
    "Define clear entity relationships upfront - document which entities contain, reference, or depend on others",
    "Use consistent naming conventions across entities (e.g., all IDs use kebab-case, all names use Title Case)",
    "Validate entity references at workflow load time - ensure referenced skills, MCP servers, and knowledge files exist",
    "Design phases with single responsibility - each phase should have one clear goal and produce specific outputs",
    "Implement expression language validation - verify ${references} resolve to valid paths before execution",
    "Document entity lifecycle states explicitly - define valid state transitions and error states",
    "Use delegation patterns consistently - follow established delegation rules from agent-team-registry.json",
    "Capture entity metadata (version, created date, dependencies) to enable compatibility checking and migration"
  ],
  "anti_patterns": [
    {
      "name": "Circular Entity Dependencies",
      "problem": "Workflows reference skills that reference workflows, creating circular dependencies that prevent resolution",
      "solution": "Maintain acyclic dependency graph. Use knowledge files as shared dependencies. Break cycles by introducing intermediate entities"
    },
    {
      "name": "Ambiguous Expression References",
      "problem": "Expression language references like ${steps.output} fail at runtime because output names don't match or steps haven't executed",
      "solution": "Validate all expression references against entity schemas at workflow definition time. Use type checking for outputs"
    },
    {
      "name": "Orphaned Entity Definitions",
      "problem": "Entities defined but never referenced, or referenced entities missing from definitions",
      "solution": "Maintain entity registry. Validate all references resolve. Use linting tools to detect orphaned entities"
    },
    {
      "name": "State Mutation Without Tracking",
      "problem": "Workflow state modified without updating state entity, causing inconsistencies and preventing resume",
      "solution": "Treat state as immutable. Create new state snapshots after each phase. Use state reducers for deterministic updates"
    },
    {
      "name": "Escalation Without Recovery Path",
      "problem": "Workflows escalate to humans but don't define how to resume after human response",
      "solution": "Define resumeTo path for all escalations. Store escalation context in state. Provide clear instructions for human responders"
    }
  ]
}