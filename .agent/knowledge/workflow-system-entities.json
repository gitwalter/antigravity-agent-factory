{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "workflow-system-entities",
  "name": "Workflow System Entities",
  "title": "Workflow System Entities",
  "description": "Entity definitions and relationships for the Cursor Agent Factory Workflow System",
  "version": "1.0.0",
  "category": "workflow",
  "philosophy": "Workflows are the choreography of intelligence - composing agents, skills, knowledge, and tools into purposeful action sequences that learn and improve over time.",
  "entities": {
    "workflow": {
      "name": "Workflow",
      "description": "A complete orchestrated process that achieves a specific goal through coordinated phases, steps, and decisions",
      "purpose": "Define autonomous multi-step processes that can diagnose, decide, act, and learn",
      "keyProperties": [
        "id",
        "name",
        "version",
        "triggers",
        "phases",
        "decisionPoints",
        "escalations",
        "learningHooks"
      ],
      "relationships": {
        "contains": [
          "phase",
          "decisionPoint",
          "escalation",
          "learningHook"
        ],
        "activatedBy": [
          "trigger"
        ],
        "references": [
          "knowledge"
        ],
        "requires": [
          "mcpRequirement"
        ],
        "tracks": [
          "state"
        ]
      },
      "examples": [
        "debug-pipeline-failure",
        "onboarding-new-developer",
        "code-review-automation",
        "incident-response"
      ]
    },
    "trigger": {
      "name": "Trigger",
      "description": "A condition or event that activates a workflow",
      "purpose": "Define when and how workflows are started",
      "types": {
        "event": {
          "description": "External system sends a signal",
          "examples": [
            "GitHub Actions failure webhook",
            "Jira issue created"
          ]
        },
        "manual": {
          "description": "User explicitly requests activation",
          "examples": [
            "'Debug this failure'",
            "'Run code review'"
          ]
        },
        "schedule": {
          "description": "Time-based activation",
          "examples": [
            "Every day at midnight",
            "Every 6 hours"
          ]
        },
        "watch": {
          "description": "File or state change detection",
          "examples": [
            "Config file modified",
            "Error log updated"
          ]
        },
        "chain": {
          "description": "Another workflow completes",
          "examples": [
            "Post-deployment verification",
            "Cleanup after build"
          ]
        },
        "webhook": {
          "description": "HTTP endpoint receives request",
          "examples": [
            "CI/CD callback",
            "External service notification"
          ]
        }
      },
      "relationships": {
        "activates": [
          "workflow"
        ]
      }
    },
    "phase": {
      "name": "Phase",
      "description": "A logical grouping of related steps within a workflow",
      "purpose": "Organize workflow execution into meaningful chunks with clear goals",
      "keyProperties": [
        "id",
        "name",
        "goal",
        "steps",
        "parallel",
        "timeout",
        "onFailure"
      ],
      "relationships": {
        "containedBy": [
          "workflow"
        ],
        "contains": [
          "step",
          "decisionPoint"
        ],
        "mayTrigger": [
          "escalation"
        ],
        "transitionsTo": [
          "phase"
        ]
      },
      "examples": [
        "diagnosis",
        "resolution",
        "verification",
        "learning"
      ]
    },
    "step": {
      "name": "Step",
      "description": "An atomic unit of work within a phase",
      "purpose": "Execute a single, focused action using skills or MCP tools",
      "keyProperties": [
        "id",
        "name",
        "skill",
        "inputs",
        "outputs",
        "timeout",
        "retry"
      ],
      "relationships": {
        "containedBy": [
          "phase"
        ],
        "invokes": [
          "skill"
        ],
        "executes": [
          "action"
        ],
        "uses": [
          "mcpTool"
        ],
        "produces": [
          "output"
        ]
      },
      "examples": [
        "parse-error-log",
        "identify-root-cause",
        "apply-fix",
        "run-tests"
      ]
    },
    "skill": {
      "name": "Skill",
      "description": "A reusable capability that can be invoked by workflow steps",
      "purpose": "Encapsulate complex behaviors as composable, testable units",
      "location": "{directories.skills}/{skill-id}/SKILL.md",
      "keyProperties": [
        "name",
        "description",
        "triggers",
        "inputs",
        "outputs",
        "knowledge",
        "mcpServers"
      ],
      "relationships": {
        "invokedBy": [
          "step"
        ],
        "uses": [
          "knowledge",
          "mcpServer"
        ],
        "mayInvoke": [
          "skill"
        ]
      },
      "categories": [
        "diagnostic",
        "resolution",
        "research",
        "generation",
        "validation"
      ],
      "examples": [
        "log-analysis",
        "root-cause-analysis",
        "test-rewrite",
        "code-fix",
        "mcp-manager"
      ]
    },
    "mcpServer": {
      "name": "MCP Server",
      "description": "An external tool integration providing capabilities via Model Context Protocol",
      "purpose": "Connect workflows to external services, APIs, and tools",
      "catalogLocation": "{directories.knowledge}/mcp-servers-catalog.json",
      "keyProperties": [
        "id",
        "name",
        "transport",
        "authentication",
        "capabilities",
        "tools"
      ],
      "relationships": {
        "requiredBy": [
          "workflow",
          "skill"
        ],
        "provides": [
          "mcpTool"
        ],
        "mayFallbackTo": [
          "mcpServer"
        ]
      },
      "categories": [
        "core",
        "code",
        "data",
        "cloud",
        "collab",
        "aiml"
      ],
      "examples": [
        "github",
        "sentry",
        "brave-search",
        "context7"
      ]
    },
    "mcpTool": {
      "name": "MCP Tool",
      "description": "A specific capability exposed by an MCP server",
      "purpose": "Perform actions in external systems",
      "keyProperties": [
        "name",
        "description",
        "parameters",
        "returns"
      ],
      "relationships": {
        "providedBy": [
          "mcpServer"
        ],
        "usedBy": [
          "step"
        ]
      },
      "examples": [
        "github.get_workflow_run",
        "brave-search.brave_web_search",
        "sentry.get_issue"
      ]
    },
    "knowledge": {
      "name": "Knowledge",
      "description": "Structured reference data that informs workflow decisions",
      "purpose": "Provide context, patterns, and historical data for intelligent decision-making",
      "location": "{directories.knowledge}/{name}.json",
      "keyProperties": [
        "title",
        "description",
        "version",
        "content"
      ],
      "relationships": {
        "referencedBy": [
          "workflow",
          "skill"
        ],
        "updatedBy": [
          "learningHook"
        ]
      },
      "categories": [
        "patterns",
        "strategies",
        "lessons",
        "catalogs",
        "schemas"
      ],
      "examples": [
        "error-patterns.json",
        "fix-strategies.json",
        "lessons-learned.json",
        "mcp-servers-catalog.json"
      ]
    },
    "decisionPoint": {
      "name": "Decision Point",
      "description": "A conditional branching point in workflow execution",
      "purpose": "Enable dynamic workflow paths based on runtime conditions",
      "keyProperties": [
        "id",
        "evaluate",
        "branches",
        "default"
      ],
      "relationships": {
        "containedBy": [
          "workflow",
          "phase"
        ],
        "branchesTo": [
          "phase",
          "step"
        ],
        "mayTrigger": [
          "escalation"
        ]
      },
      "examples": [
        "confidence-check",
        "error-type-routing",
        "capability-detection"
      ]
    },
    "branch": {
      "name": "Branch",
      "description": "A possible path from a decision point",
      "purpose": "Define conditions and destinations for workflow routing",
      "keyProperties": [
        "condition",
        "goto",
        "action",
        "escalation"
      ],
      "relationships": {
        "containedBy": [
          "decisionPoint"
        ],
        "goesTo": [
          "phase",
          "step"
        ],
        "triggers": [
          "escalation"
        ]
      }
    },
    "escalation": {
      "name": "Escalation",
      "description": "A point where human involvement is requested",
      "purpose": "Ensure human oversight for uncertain or high-risk situations",
      "keyProperties": [
        "id",
        "trigger",
        "method",
        "prompt",
        "timeout",
        "onTimeout"
      ],
      "methods": {
        "interactive": "Pause execution and ask user",
        "notification": "Inform user but continue",
        "issue": "Create tracking issue for later",
        "abort": "Stop workflow entirely",
        "fallback": "Try alternative approach"
      },
      "relationships": {
        "containedBy": [
          "workflow"
        ],
        "triggeredBy": [
          "phase",
          "step",
          "decisionPoint"
        ],
        "resumesTo": [
          "phase",
          "step"
        ]
      },
      "examples": [
        "confirm-destructive-action",
        "request-credentials",
        "low-confidence-fix"
      ]
    },
    "state": {
      "name": "State",
      "description": "Runtime tracking of workflow progress and collected data",
      "purpose": "Enable resume, debugging, and progress visibility",
      "keyProperties": [
        "currentPhase",
        "currentStep",
        "startTime",
        "attempts",
        "collectedEvidence",
        "outputs"
      ],
      "relationships": {
        "trackedBy": [
          "workflow"
        ],
        "persistedTo": [
          "stateStore"
        ],
        "restoredFrom": [
          "checkpoint"
        ]
      }
    },
    "learningHook": {
      "name": "Learning Hook",
      "description": "A capture point for continuous improvement",
      "purpose": "Extract patterns from workflow execution to improve future performance",
      "keyProperties": [
        "event",
        "capture",
        "store",
        "transform",
        "actions"
      ],
      "events": [
        "workflow_success",
        "workflow_failure",
        "step_complete",
        "step_failure",
        "escalation_resolved",
        "user_correction"
      ],
      "relationships": {
        "containedBy": [
          "workflow"
        ],
        "updates": [
          "knowledge"
        ],
        "capturesFrom": [
          "step",
          "phase",
          "escalation"
        ]
      },
      "examples": [
        "capture-successful-fix",
        "record-failed-attempt",
        "integrate-user-feedback"
      ]
    },
    "output": {
      "name": "Output",
      "description": "Data produced by a step for use by subsequent steps",
      "purpose": "Enable data flow between workflow steps",
      "keyProperties": [
        "name",
        "type",
        "required",
        "value"
      ],
      "relationships": {
        "producedBy": [
          "step"
        ],
        "consumedBy": [
          "step",
          "decisionPoint"
        ]
      }
    }
  },
  "relationships": {
    "summary": "The workflow system forms a hierarchy: Workflows contain Phases, Phases contain Steps. Steps invoke Skills and use MCP Tools. Decision Points route between Phases. Escalations involve humans. Learning Hooks update Knowledge for continuous improvement.",
    "diagram": "See {directories.docs}/research/WORKFLOW_SYSTEM.md for visual diagrams"
  },
  "lifecycleStates": {
    "workflow": [
      "idle",
      "triggered",
      "validating",
      "initializing",
      "acquiringMCP",
      "needsAuth",
      "executing",
      "decisionPoint",
      "researching",
      "escalating",
      "paused",
      "verifying",
      "learning",
      "completed",
      "failed",
      "cancelled"
    ],
    "phase": [
      "pending",
      "executing",
      "completed",
      "failed",
      "skipped"
    ],
    "step": [
      "pending",
      "executing",
      "retrying",
      "completed",
      "failed",
      "skipped"
    ]
  },
  "expressionLanguage": {
    "description": "Expression syntax for referencing values in workflows",
    "syntax": "${expression}",
    "references": {
      "context": "${context.fieldName}",
      "steps": "${steps.stepId.outputs.outputName}",
      "phases": "${phases.phaseId.outputs.outputName}",
      "knowledge": "${knowledge.fileName.jsonPath}",
      "state": "${state.fieldName}",
      "env": "${env.VARIABLE_NAME}",
      "workflow": "${workflow.id|name|duration}"
    },
    "functions": {
      "uuid": "Generate unique identifier",
      "now": "Current timestamp",
      "contains": "Array/string contains check",
      "length": "Array/string length"
    }
  },
  "extensionPoints": {
    "customSkills": {
      "description": "Add new skills in {directories.skills}/{id}/SKILL.md",
      "process": "Define inputs, outputs, process steps, and dependencies"
    },
    "customMCPServers": {
      "description": "Add servers to {directories.knowledge}/mcp-servers-catalog.json",
      "process": "Define server metadata, authentication, and tools"
    },
    "customKnowledge": {
      "description": "Add knowledge files to {directories.knowledge}/ directory",
      "process": "Create JSON with appropriate schema"
    },
    "workflowInheritance": {
      "description": "Extend existing workflows with 'extends' property",
      "process": "Override phases, steps, or add new elements"
    }
  },
  "relatedDocuments": [
    {
      "name": "WORKFLOW_SYSTEM.md",
      "path": "{directories.docs}/research/WORKFLOW_SYSTEM.md",
      "purpose": "Conceptual architecture for humans"
    },
    {
      "name": "WORKFLOW_AUTHORING.md",
      "path": "{directories.docs}/WORKFLOW_AUTHORING.md",
      "purpose": "Practical guide for creating workflows"
    },
    {
      "name": "w-o-r-k-f-l-o-w-patterns.md",
      "path": "{directories.docs}/reference/WORKFLOW_PATTERNS.md",
      "purpose": "Reusable workflow pattern catalog"
    },
    {
      "name": "workflow-schema.json",
      "path": "{directories.knowledge}/schemas/workflow-schema.json",
      "purpose": "JSON Schema for validation"
    }
  ],
  "patterns": {
    "entity_composition_name": {
      "description": "Entity Composition Pattern",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# entity_composition_name pattern for workflow-entities\n# Implement based on description: Entity Composition Pattern...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "entity_composition_description": {
      "description": "Workflows contain Phases, Phases contain Steps. Steps invoke Skills and use MCP Tools. Clear containment hierarchy enables predictable execution.",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# entity_composition_description pattern for workflow-entities\n# Implement based on description: Workflows contain Phases, Phases contain Steps. St...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "entity_composition_usage": {
      "description": "When designing workflows, follow the containment hierarchy: Workflow \u2192 Phase \u2192 Step \u2192 Skill/MCP Tool",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# entity_composition_usage pattern for workflow-entities\n# Implement based on description: When designing workflows, follow the containment h...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "state_persistence_name": {
      "description": "State Persistence Pattern",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# state_persistence_name pattern for workflow-entities\n# Implement based on description: State Persistence Pattern...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "state_persistence_description": {
      "description": "Capture workflow state after each phase completion. Enable resume from checkpoints on failure.",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# state_persistence_description pattern for workflow-entities\n# Implement based on description: Capture workflow state after each phase completion...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "state_persistence_usage": {
      "description": "Implement checkpointing in state entity. Store phase outputs, current position, and collected evidence",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# state_persistence_usage pattern for workflow-entities\n# Implement based on description: Implement checkpointing in state entity. Store pha...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "expression_reference_name": {
      "description": "Expression Reference Pattern",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# expression_reference_name pattern for workflow-entities\n# Implement based on description: Expression Reference Pattern...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "expression_reference_description": {
      "description": "Use ${expression} syntax to reference outputs from previous steps, context values, and knowledge files.",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# expression_reference_description pattern for workflow-entities\n# Implement based on description: Use ${expression} syntax to reference outputs from...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "expression_reference_usage": {
      "description": "Reference step outputs: ${steps.stepId.outputs.outputName}. Reference context: ${context.fieldName}",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# expression_reference_usage pattern for workflow-entities\n# Implement based on description: Reference step outputs: ${steps.stepId.outputs.out...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "delegation_through_skills_name": {
      "description": "Delegation Through Skills Pattern",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# delegation_through_skills_name pattern for workflow-entities\n# Implement based on description: Delegation Through Skills Pattern...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "delegation_through_skills_description": {
      "description": "Steps delegate work to Skills rather than directly invoking tools. Skills encapsulate reusable capabilities.",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# delegation_through_skills_description pattern for workflow-entities\n# Implement based on description: Steps delegate work to Skills rather than directly...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "delegation_through_skills_usage": {
      "description": "Define skills in {directories.skills}/{id}/SKILL.md. Reference skills by ID in step definitions",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# delegation_through_skills_usage pattern for workflow-entities\n# Implement based on description: Define skills in {directories.skills}/{id}/SKILL.m...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "escalation_resolution_name": {
      "description": "Escalation Resolution Pattern",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# escalation_resolution_name pattern for workflow-entities\n# Implement based on description: Escalation Resolution Pattern...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "escalation_resolution_description": {
      "description": "When escalation occurs, store escalation context in state. Define resumeTo path for continuation after human response.",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# escalation_resolution_description pattern for workflow-entities\n# Implement based on description: When escalation occurs, store escalation context i...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "escalation_resolution_usage": {
      "description": "Set escalation.resumeTo to phase or step ID. Store user response in state for workflow continuation",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# escalation_resolution_usage pattern for workflow-entities\n# Implement based on description: Set escalation.resumeTo to phase or step ID. Store...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "learning_hook_capture_name": {
      "description": "Learning Hook Capture Pattern",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# learning_hook_capture_name pattern for workflow-entities\n# Implement based on description: Learning Hook Capture Pattern...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "learning_hook_capture_description": {
      "description": "After critical phases, capture patterns, outcomes, and lessons to knowledge files for continuous improvement.",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# learning_hook_capture_description pattern for workflow-entities\n# Implement based on description: After critical phases, capture patterns, outcomes,...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "learning_hook_capture_usage": {
      "description": "Define learningHook events (workflow_success, step_failure). Transform captured data and update knowledge files",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# learning_hook_capture_usage pattern for workflow-entities\n# Implement based on description: Define learningHook events (workflow_success, step...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    }
  },
  "best_practices": [
    "Define clear entity relationships upfront - document which entities contain, reference, or depend on others",
    "Use consistent naming conventions across entities (e.g., all IDs use kebab-case, all names use Title Case)",
    "Validate entity references at workflow load time - ensure referenced skills, MCP servers, and knowledge files exist",
    "Design phases with single responsibility - each phase should have one clear goal and produce specific outputs",
    "Implement expression language validation - verify ${references} resolve to valid paths before execution",
    "Document entity lifecycle states explicitly - define valid state transitions and error states",
    "Use delegation patterns consistently - follow established delegation rules from agent-team-registry.json",
    "Capture entity metadata (version, created date, dependencies) to enable compatibility checking and migration"
  ],
  "anti_patterns": [
    {
      "name": "Circular Entity Dependencies",
      "problem": "Workflows reference skills that reference workflows, creating circular dependencies that prevent resolution",
      "fix": "Maintain acyclic dependency graph. Use knowledge files as shared dependencies. Break cycles by introducing intermediate entities"
    },
    {
      "name": "Ambiguous Expression References",
      "problem": "Expression language references like ${steps.output} fail at runtime because output names don't match or steps haven't executed",
      "fix": "Validate all expression references against entity schemas at workflow definition time. Use type checking for outputs"
    },
    {
      "name": "Orphaned Entity Definitions",
      "problem": "Entities defined but never referenced, or referenced entities missing from definitions",
      "fix": "Maintain entity registry. Validate all references resolve. Use linting tools to detect orphaned entities"
    },
    {
      "name": "State Mutation Without Tracking",
      "problem": "Workflow state modified without updating state entity, causing inconsistencies and preventing resume",
      "fix": "Treat state as immutable. Create new state snapshots after each phase. Use state reducers for deterministic updates"
    },
    {
      "name": "Escalation Without Recovery Path",
      "problem": "Workflows escalate to humans but don't define how to resume after human response",
      "fix": "Define resumeTo path for all escalations. Store escalation context in state. Provide clear instructions for human responders"
    }
  ],
  "axiomAlignment": {
    "A1_verifiability": "All patterns include verifiable examples and test approaches",
    "A2_user_primacy": "Patterns prioritize user needs and practical outcomes",
    "A3_transparency": "Pattern selection rationale is clearly documented",
    "A4_non_harm": "Patterns include safety considerations and error handling",
    "A5_consistency": "Patterns follow established conventions and standards"
  },
  "related_skills": [
    "none"
  ],
  "related_knowledge": [
    "best-practices.json"
  ]
}