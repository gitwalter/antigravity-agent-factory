{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "reactive-indexing-patterns",
  "name": "Reactive Indexing Patterns",
  "title": "Reactive Indexing Patterns",
  "description": "Patterns for instant artifact synchronization using reactive file watching and cached indices",
  "version": "1.0.0",
  "category": "ai-ml",
  "axiomAlignment": {
    "A1_verifiability": "Cached indices include hashes for integrity verification",
    "A2_user_primacy": "Respects developer flow (Wu Wei) by eliminating friction",
    "A3_transparency": "Clear separation between fast local checks and accurate CI validation",
    "A4_non_harm": "Layered architecture prevents harmful bypasses and stale validation",
    "A5_consistency": "Unified reactive indexing patterns across cache, triggers, and CI"
  },
  "related_skills": [
    "ci-monitor",
    "commit-release",
    "pipeline-error-fix"
  ],
  "related_knowledge": [
    "cicd-patterns.json",
    "workflow-patterns.json",
    "workflow-entities.json"
  ],
  "research_sources": {
    "academic": {
      "salsa": {
        "description": "Rust framework for incremental, on-demand programs",
        "url": "https://salsa-rs.github.io/salsa/",
        "key_insight": "Store computation results in database, reuse when inputs unchanged",
        "applicability": "Inspired cache structure design"
      },
      "adapton": {
        "description": "Language-based framework for general-purpose incremental computation",
        "url": "https://docs.rs/adapton/",
        "key_insight": "Demanded computation graph with demand-driven change propagation",
        "applicability": "Theoretical foundation for affected detection"
      }
    },
    "industry": {
      "nx_affected": {
        "description": "Nx monorepo tool's affected pattern",
        "url": "https://nx.dev/docs/features/ci-features/affected",
        "key_insight": "Use git to identify changed files, map to projects via dependency graph",
        "applicability": "Inspired directory trigger mapping"
      },
      "turborepo": {
        "description": "Turborepo's computation hashing for cache invalidation",
        "key_insight": "Hash includes source files, config, deps, runtime values",
        "applicability": "Inspired hash-based cache validation"
      },
      "pre_commit": {
        "description": "Git hook framework with environment caching",
        "url": "https://pre-commit.com/",
        "key_insight": "Runs only on staged/changed files, caches hook environments",
        "applicability": "Recommended for hook management layer"
      }
    },
    "tools": {
      "python_watchdog": {
        "description": "Python file system event monitoring library",
        "url": "https://python-watchdog.readthedocs.io/",
        "key_insight": "Observer pattern for reactive file watching",
        "applicability": "Optional daemon-based reactive updates"
      },
      "vscode_runonsave": {
        "description": "VS Code extension to run commands on file save",
        "url": "https://marketplace.visualstudio.com/items?itemName=emeraldwalk.RunOnSave",
        "key_insight": "IDE-integrated file save triggers",
        "applicability": "Recommended for VS Code users"
      },
      "chokidar": {
        "description": "Minimal cross-platform file watching for JavaScript",
        "url": "https://github.com/paulmillr/chokidar",
        "key_insight": "Event-based architecture using EventEmitter",
        "applicability": "Reference for Node.js projects"
      }
    }
  },
  "patterns": {
    "layered_validation": {
      "description": "Separate fast local validation from accurate CI validation",
      "layers": {
        "pre_commit": {
          "purpose": "Instant feedback during development",
          "method": "Read from cached index",
          "accuracy": "Approximate (based on last save)",
          "speed": "< 2 seconds"
        },
        "ci_pipeline": {
          "purpose": "Authoritative validation before merge",
          "method": "Full computation (pytest --collect-only)",
          "accuracy": "Exact",
          "speed": "30+ seconds acceptable"
        }
      },
      "rationale": "Developers need fast feedback; CI ensures accuracy",
      "use_when": "When implementing this pattern in your AI/ML application",
      "code_example": "# Implement pattern based on description\n# Use appropriate imports and domain-specific logic\nresult = process_data(input_data)",
      "best_practices": [
        "Separate fast local validation (pre-commit hooks reading from cache) from accurate CI validation (full computation) - developers need < 2s feedback, CI can take 30+ seconds",
        "Use file-based counting methods (regex scanning for test functions) instead of subprocess calls (pytest --collect-only) in hooks for 100x speed improvement",
        "Implement affected detection to update only relevant index sections when files change - map directories to artifact types and update incrementally",
        "Store cache with content hashes for validation - include hash of directory contents to detect staleness without full recomputation",
        "Debounce rapid file changes (100ms window) to avoid excessive index updates during active development"
      ]
    },
    "cache_structure": {
      "description": "JSON-based artifact index with metadata",
      "schema": {
        "schema_version": "Semantic version for cache format",
        "updated_at": "ISO 8601 timestamp of last update",
        "artifacts": {
          "<artifact_type>": {
            "count": "Number of artifacts",
            "hash": "Content hash for validation",
            "last_modified": "Most recent file modification",
            "breakdown": "Optional category breakdown"
          }
        }
      },
      "location": "{directories.cache}/artifact-index.json",
      "gitignore": true,
      "use_when": "When implementing this pattern in your AI/ML application",
      "code_example": "# Implement pattern based on description\n# Use appropriate imports and domain-specific logic\nresult = process_data(input_data)",
      "best_practices": [
        "Separate fast local validation (pre-commit hooks reading from cache) from accurate CI validation (full computation) - developers need < 2s feedback, CI can take 30+ seconds",
        "Use file-based counting methods (regex scanning for test functions) instead of subprocess calls (pytest --collect-only) in hooks for 100x speed improvement",
        "Implement affected detection to update only relevant index sections when files change - map directories to artifact types and update incrementally",
        "Store cache with content hashes for validation - include hash of directory contents to detect staleness without full recomputation",
        "Debounce rapid file changes (100ms window) to avoid excessive index updates during active development"
      ]
    },
    "reactive_update": {
      "description": "Update index on file save events",
      "triggers": [
        "File save in monitored directory",
        "Git checkout/merge",
        "Manual rebuild request"
      ],
      "update_scope": "Only affected artifact type, not full rebuild",
      "debouncing": "Aggregate rapid changes (100ms window)",
      "use_when": "When implementing this pattern in your AI/ML application",
      "code_example": "# Implement pattern based on description\n# Use appropriate imports and domain-specific logic\nresult = process_data(input_data)",
      "best_practices": [
        "Separate fast local validation (pre-commit hooks reading from cache) from accurate CI validation (full computation) - developers need < 2s feedback, CI can take 30+ seconds",
        "Use file-based counting methods (regex scanning for test functions) instead of subprocess calls (pytest --collect-only) in hooks for 100x speed improvement",
        "Implement affected detection to update only relevant index sections when files change - map directories to artifact types and update incrementally",
        "Store cache with content hashes for validation - include hash of directory contents to detect staleness without full recomputation",
        "Debounce rapid file changes (100ms window) to avoid excessive index updates during active development"
      ]
    },
    "staleness_detection": {
      "description": "Determine when cache needs refresh",
      "methods": {
        "time_based": "Index older than threshold (e.g., 1 hour)",
        "hash_based": "Directory hash differs from cached hash",
        "file_count": "Quick file count differs from cached count"
      },
      "fallback": "If stale, run fast file-based count before commit",
      "use_when": "When implementing this pattern in your AI/ML application",
      "code_example": "# Implement pattern based on description\n# Use appropriate imports and domain-specific logic\nresult = process_data(input_data)",
      "best_practices": [
        "Separate fast local validation (pre-commit hooks reading from cache) from accurate CI validation (full computation) - developers need < 2s feedback, CI can take 30+ seconds",
        "Use file-based counting methods (regex scanning for test functions) instead of subprocess calls (pytest --collect-only) in hooks for 100x speed improvement",
        "Implement affected detection to update only relevant index sections when files change - map directories to artifact types and update incrementally",
        "Store cache with content hashes for validation - include hash of directory contents to detect staleness without full recomputation",
        "Debounce rapid file changes (100ms window) to avoid excessive index updates during active development"
      ]
    },
    "file_based_counting": {
      "description": "Fast alternative to subprocess-based counting",
      "implementation": {
        "test_functions": "Regex scan for def test_* patterns",
        "file_count": "Simple glob with exclusions",
        "directory_count": "Count matching directories"
      },
      "performance": "~100x faster than pytest --collect-only",
      "trade_off": "May slightly differ from pytest (e.g., parametrized tests)",
      "use_when": "When implementing this pattern in your AI/ML application",
      "code_example": "# Implement pattern based on description\n# Use appropriate imports and domain-specific logic\nresult = process_data(input_data)",
      "best_practices": [
        "Separate fast local validation (pre-commit hooks reading from cache) from accurate CI validation (full computation) - developers need < 2s feedback, CI can take 30+ seconds",
        "Use file-based counting methods (regex scanning for test functions) instead of subprocess calls (pytest --collect-only) in hooks for 100x speed improvement",
        "Implement affected detection to update only relevant index sections when files change - map directories to artifact types and update incrementally",
        "Store cache with content hashes for validation - include hash of directory contents to detect staleness without full recomputation",
        "Debounce rapid file changes (100ms window) to avoid excessive index updates during active development"
      ]
    },
    "directory_triggers": {
      "description": "Map directories to affected artifact types",
      "example": {
        "{directories.agents}": [
          "agents"
        ],
        "{directories.skills}": [
          "skills"
        ],
        "tests": [
          "tests"
        ]
      },
      "usage": "On file change, update only relevant index sections",
      "use_when": "When implementing this pattern in your AI/ML application",
      "code_example": "# Implement pattern based on description\n# Use appropriate imports and domain-specific logic\nresult = process_data(input_data)",
      "best_practices": [
        "Separate fast local validation (pre-commit hooks reading from cache) from accurate CI validation (full computation) - developers need < 2s feedback, CI can take 30+ seconds",
        "Use file-based counting methods (regex scanning for test functions) instead of subprocess calls (pytest --collect-only) in hooks for 100x speed improvement",
        "Implement affected detection to update only relevant index sections when files change - map directories to artifact types and update incrementally",
        "Store cache with content hashes for validation - include hash of directory contents to detect staleness without full recomputation",
        "Debounce rapid file changes (100ms window) to avoid excessive index updates during active development"
      ]
    }
  },
  "implementation_guidance": {
    "minimum_viable": {
      "description": "Simplest implementation that provides value",
      "steps": [
        "Add file-based counting method",
        "Create cache JSON structure",
        "Modify pre-commit to read from cache",
        "Run full sync in CI only"
      ]
    },
    "full_reactive": {
      "description": "Complete reactive system with file watching",
      "steps": [
        "Minimum viable implementation",
        "Add update_index.py script",
        "Configure VS Code RunOnSave",
        "Optional: Python watchdog daemon"
      ]
    }
  },
  "anti_patterns": [
    {
      "name": "Slow subprocesses in pre-commit hooks",
      "problem": "Running slow subprocesses (pytest --collect-only, full index rebuilds) in pre-commit hooks breaks developer flow, causes frustration, and encourages --no-verify bypasses",
      "fix": "Move slow operations to CI pipeline, use fast file-based counting methods in hooks, or read from cached index for instant feedback"
    },
    {
      "name": "Full index rebuild on every change",
      "problem": "Rebuilding entire index on any file change wastes computation, doesn't scale, and creates unnecessary delays in development workflow",
      "fix": "Implement affected detection using directory-to-artifact-type mapping, update only relevant index sections when files change"
    },
    {
      "name": "No authoritative validation layer",
      "problem": "Relying only on fast local validation (cached counts) allows approximate counts to drift from reality, leading to false positives/negatives",
      "fix": "Always have CI as authoritative validation layer - local cache provides fast feedback, CI ensures accuracy before merge with full computation"
    },
    {
      "name": "No staleness detection",
      "problem": "Using stale cache without detection leads to incorrect validation results and false confidence in artifact counts",
      "fix": "Implement staleness detection using time-based thresholds, content hashes, or file counts - refresh cache if stale before critical operations"
    },
    {
      "name": "No debouncing for rapid changes",
      "problem": "Updating index on every file save event during active editing causes excessive computation and performance issues",
      "fix": "Debounce rapid file changes (100ms window) to aggregate multiple saves and update index once per editing session"
    }
  ],
  "related_patterns": [
    "ci-cd-patterns",
    "workflow-patterns"
  ],
  "best_practices": [
    "Separate fast local validation (pre-commit hooks reading from cache) from accurate CI validation (full computation) - developers need < 2s feedback, CI can take 30+ seconds",
    "Use file-based counting methods (regex scanning for test functions) instead of subprocess calls (pytest --collect-only) in hooks for 100x speed improvement",
    "Implement affected detection to update only relevant index sections when files change - map directories to artifact types and update incrementally",
    "Store cache with content hashes for validation - include hash of directory contents to detect staleness without full recomputation",
    "Debounce rapid file changes (100ms window) to avoid excessive index updates during active development",
    "Use collection aliases or versioned cache keys for zero-downtime cache updates when rebuilding indices",
    "Always have CI as authoritative validation layer - local cache is approximate for speed, CI ensures accuracy before merge",
    "Track cache metadata (updated_at, schema_version) to handle cache format migrations and detect stale caches"
  ]
}
