{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "testcontainers-patterns",
  "name": "Testcontainers Patterns",
  "title": "Testcontainers Integration Testing Patterns",
  "description": "Best practices and patterns for using Testcontainers in Spring Boot integration tests",
  "version": "1.0.0",
  "category": "testing",
  "axiomAlignment": {
    "A1_verifiability": "Testcontainers enable verifiable integration tests with real dependencies",
    "A2_user_primacy": "Real database testing ensures user-facing data flows work correctly",
    "A3_transparency": "Tests provide transparent verification of application behavior",
    "A4_non_harm": "Isolated containers prevent test pollution and unintended side effects",
    "A5_consistency": "Reproducible environments ensure consistent test results across teams"
  },
  "related_skills": [
    "spring-testing",
    "java-containerization",
    "agent-testing"
  ],
  "related_knowledge": [
    "spring-patterns.json",
    "test-patterns.json",
    "kotest-patterns.json"
  ],
  "patterns": {
    "overview": {
      "description": "Testcontainers provides lightweight, throwaway instances of databases, message brokers, and other services for integration testing",
      "benefits": [
        "Real database testing without mocks",
        "Isolated test environments",
        "Reproducible tests",
        "No manual test database setup",
        "CI/CD friendly"
      ],
      "use_when": "When building Java/Spring applications and need overview",
      "code_example": "# Overview - implement per Java/Spring conventions",
      "best_practices": [
        "Follow overview best practices for your stack",
        "Validate and test the implementation before production use"
      ]
    },
    "database_containers_postgresql": {
      "description": "PostgreSQL database container",
      "setup": "@Container static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:15\")",
      "configuration": {
        "withDatabaseName": "Set database name",
        "withUsername": "Set database username",
        "withPassword": "Set database password",
        "withInitScript": "Run initialization script",
        "withReuse": "Reuse container across tests"
      },
      "dynamic_properties": "@DynamicPropertySource to configure Spring datasource",
      "example": "PostgreSQLContainer with @SpringBootTest and @Testcontainers",
      "use_when": "Apply when implementing postgresql in testing context",
      "code_example": "PostgreSQLContainer with @SpringBootTest and @Testcontainers",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for postgresql",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "database_containers_mysql": {
      "description": "MySQL database container",
      "setup": "@Container static MySQLContainer<?> mysql = new MySQLContainer<>(\"mysql:8\")",
      "configuration": {
        "withDatabaseName": "Set database name",
        "withUsername": "Set database username",
        "withPassword": "Set database password"
      },
      "use_when": "Testing MySQL-specific features",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for mysql",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "database_containers_mariadb": {
      "description": "MariaDB database container",
      "setup": "@Container static MariaDBContainer<?> mariadb = new MariaDBContainer<>(\"mariadb:10\")",
      "use_when": "Testing MariaDB compatibility",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for mariadb",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "database_containers_mongodb": {
      "description": "Implements mongodb for reliable, maintainable code. Use when the scenario requires this pattern.",
      "setup": "@Container static MongoDBContainer mongo = new MongoDBContainer(\"mongo:6\")",
      "use_when": "Testing MongoDB repositories",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for mongodb",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "database_containers_oracle": {
      "description": "Oracle database container",
      "setup": "@Container static OracleContainer oracle = new OracleContainer(\"gvenzl/oracle-xe:21-slim\")",
      "use_when": "Testing Oracle database compatibility",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for oracle",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "message_broker_containers_kafka": {
      "description": "Apache Kafka container",
      "setup": "@Container static KafkaContainer kafka = new KafkaContainer(DockerImageName.parse(\"confluentinc/cp-kafka:latest\"))",
      "configuration": {
        "withEnv": "Set Kafka environment variables",
        "withNetwork": "Join Docker network"
      },
      "dynamic_properties": "spring.kafka.bootstrap-servers from kafka.getBootstrapServers()",
      "use_when": "Testing Kafka producers/consumers",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for kafka",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "message_broker_containers_rabbitmq": {
      "description": "RabbitMQ message broker container",
      "setup": "@Container static RabbitMQContainer rabbitmq = new RabbitMQContainer(\"rabbitmq:3-management\")",
      "configuration": {
        "withUser": "Set RabbitMQ username",
        "withPassword": "Set RabbitMQ password",
        "withVhost": "Set virtual host"
      },
      "dynamic_properties": "spring.rabbitmq.host and spring.rabbitmq.port",
      "use_when": "Testing RabbitMQ messaging",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for rabbitmq",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "message_broker_containers_pulsar": {
      "description": "Apache Pulsar container",
      "setup": "@Container static PulsarContainer pulsar = new PulsarContainer(\"apachepulsar/pulsar:latest\")",
      "use_when": "Testing Pulsar messaging",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for pulsar",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "cache_containers_redis": {
      "description": "Redis cache container",
      "setup": "@Container static GenericContainer<?> redis = new GenericContainer<>(\"redis:7-alpine\").withExposedPorts(6379)",
      "configuration": {
        "withExposedPorts": "Expose Redis port",
        "withCommand": "Set Redis commands"
      },
      "dynamic_properties": "spring.data.redis.host and spring.data.redis.port",
      "use_when": "Testing Redis caching or Spring Session",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for redis",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "cache_containers_hazelcast": {
      "description": "Implements hazelcast for reliable, maintainable code. Use when the scenario requires this pattern.",
      "setup": "@Container static GenericContainer<?> hazelcast = new GenericContainer<>(\"hazelcast/hazelcast:5\")",
      "use_when": "Testing Hazelcast distributed cache",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for hazelcast",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "search_containers_elasticsearch": {
      "description": "Elasticsearch container",
      "setup": "@Container static ElasticsearchContainer elasticsearch = new ElasticsearchContainer(\"docker.elastic.co/elasticsearch/elasticsearch:8.8.0\")",
      "configuration": {
        "withPassword": "Set Elasticsearch password",
        "withEnv": "Set environment variables"
      },
      "use_when": "Testing Elasticsearch repositories",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for elasticsearch",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "search_containers_opensearch": {
      "description": "OpenSearch container",
      "setup": "@Container static OpenSearchContainer opensearch = new OpenSearchContainer(\"opensearchproject/opensearch:2\")",
      "use_when": "Testing OpenSearch",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for opensearch",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "test_patterns_static_container": {
      "description": "Container shared across all tests in class",
      "pattern": "@Container static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:15\")",
      "use_when": "Container can be reused across tests",
      "benefits": [
        "Faster test execution",
        "Resource efficient"
      ],
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for static_container",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "test_patterns_instance_container": {
      "description": "New container for each test",
      "pattern": "@Container PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:15\")",
      "use_when": "Tests need isolated containers",
      "benefits": [
        "Complete isolation",
        "No test interference"
      ],
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for instance_container",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "test_patterns_dynamic_property_source": {
      "description": "Configure Spring properties from container",
      "pattern": "@DynamicPropertySource static void configureProperties(DynamicPropertyRegistry registry)",
      "example": "registry.add(\"spring.datasource.url\", postgres::getJdbcUrl)",
      "use_when": "Need to configure Spring Boot from container",
      "best_practices": [
        "Use method references for dynamic values",
        "Configure all required properties",
        "Handle port mapping correctly"
      ],
      "code_example": "registry.add(\"spring.datasource.url\", postgres::getJdbcUrl)"
    },
    "test_patterns_test_configuration": {
      "description": "Test-specific Spring configuration",
      "pattern": "@TestConfiguration with @Import",
      "use_when": "Need test-specific beans",
      "example": "TestConfiguration with mock beans",
      "code_example": "TestConfiguration with mock beans",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for test_configuration",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "test_patterns_lifecycle_management": {
      "description": "Container lifecycle management",
      "patterns": {
        "start": "Container starts before tests",
        "stop": "Container stops after tests",
        "reuse": "Reuse container across test runs"
      },
      "best_practices": [
        "Use @Container for automatic lifecycle",
        "Use static containers when possible",
        "Enable reuse for faster tests"
      ],
      "use_when": "Apply when implementing lifecycle management in testing context",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'"
    },
    "spring_boot_integration_spring_boot_test": {
      "description": "Full Spring Boot context with Testcontainers",
      "pattern": "@SpringBootTest @Testcontainers",
      "use_when": "Need full application context",
      "configuration": "@DynamicPropertySource for datasource configuration",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for spring_boot_test",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "spring_boot_integration_data_jpa_test": {
      "description": "JPA slice test with Testcontainers",
      "pattern": "@DataJpaTest @Testcontainers",
      "use_when": "Testing only JPA layer",
      "configuration": "@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for data_jpa_test",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "spring_boot_integration_jdbc_test": {
      "description": "JDBC slice test with Testcontainers",
      "pattern": "@JdbcTest @Testcontainers",
      "use_when": "Testing JDBC operations",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for jdbc_test",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "spring_boot_integration_transactional": {
      "description": "Use @Transactional for test cleanup",
      "pattern": "@SpringBootTest @Transactional",
      "benefits": [
        "Automatic rollback",
        "Clean test data"
      ],
      "use_when": "Need database cleanup between tests",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for transactional",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "advanced_patterns_docker_compose": {
      "description": "Use Docker Compose for multiple services",
      "setup": "@Container static DockerComposeContainer<?> compose = new DockerComposeContainer<>(new File(\"docker-compose-test.yml\"))",
      "use_when": "Need multiple services (database + cache + broker)",
      "benefits": [
        "Single configuration",
        "Service dependencies"
      ],
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for docker_compose",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "advanced_patterns_network_isolation": {
      "description": "Isolate containers in Docker network",
      "pattern": "Network.newNetwork() and container.withNetwork()",
      "use_when": "Need network isolation",
      "benefits": [
        "Isolated tests",
        "No port conflicts"
      ],
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for network_isolation",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "advanced_patterns_volume_mounts": {
      "description": "Mount volumes for data persistence",
      "pattern": "container.withFileSystemBind()",
      "use_when": "Need to persist test data",
      "use_cases": [
        "Database initialization scripts",
        "Configuration files"
      ],
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for volume_mounts",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "advanced_patterns_environment_variables": {
      "description": "Set container environment variables",
      "pattern": "container.withEnv(\"KEY\", \"value\")",
      "use_when": "Need to configure container behavior",
      "examples": [
        "Database passwords",
        "Feature flags",
        "Service URLs"
      ],
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for environment_variables",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "advanced_patterns_wait_strategies": {
      "description": "Wait for container to be ready",
      "patterns": {
        "http_wait": "Wait for HTTP endpoint",
        "log_wait": "Wait for log message",
        "healthcheck": "Wait for health check"
      },
      "use_when": "Container needs time to start",
      "example": "Wait.forHttp(\"/health\")",
      "code_example": "Wait.forHttp(\"/health\")",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for wait_strategies",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "testcontainers_cloud": {
      "description": "Testcontainers Cloud for faster execution",
      "benefits": [
        "Faster container startup",
        "No local Docker required",
        "Parallel test execution",
        "CI/CD optimization"
      ],
      "setup": "Set TESTCONTAINERS_RYUK_DISABLED and use Testcontainers Cloud",
      "use_when": "Need faster test execution or CI/CD",
      "configuration": "Environment variables for cloud access",
      "code_example": "# Testcontainers Cloud\nSet TESTCONTAINERS_RYUK_DISABLED and use Testcontainers Cloud",
      "best_practices": [
        "Follow testcontainers cloud best practices for your stack",
        "Validate and test the implementation before production use"
      ]
    },
    "parallel_execution": {
      "description": "Run tests in parallel with Testcontainers",
      "patterns": {
        "junit_parallel": "Use JUnit 5 parallel execution",
        "testcontainers_reuse": "Reuse containers across tests",
        "port_allocation": "Dynamic port allocation"
      },
      "best_practices": [
        "Enable container reuse",
        "Use dynamic port allocation",
        "Isolate test data",
        "Monitor resource usage"
      ],
      "configuration": "junit.jupiter.execution.parallel.enabled=true",
      "use_when": "When building Java/Spring applications and need parallel execution",
      "code_example": "# Parallel Execution - implement per Java/Spring conventions"
    },
    "common_issues_port_conflicts": {
      "description": "Implements port conflicts for reliable, maintainable code. Use when the scenario requires this pattern.",
      "solution": "Use dynamic port allocation or different ports",
      "prevention": "Let Testcontainers manage ports",
      "use_when": "Apply when implementing port conflicts in testing context",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for port_conflicts",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "common_issues_slow_startup": {
      "description": "Containers take long to start",
      "solution": "Use container reuse or Testcontainers Cloud",
      "prevention": "Use static containers",
      "use_when": "Apply when implementing slow startup in testing context",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for slow_startup",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "common_issues_resource_exhaustion": {
      "description": "Too many containers running",
      "solution": "Enable container reuse, clean up properly",
      "prevention": "Monitor Docker resources",
      "use_when": "Apply when implementing resource exhaustion in testing context",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for resource_exhaustion",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "common_issues_network_issues": {
      "description": "Containers can't communicate",
      "solution": "Use Docker networks, check firewall",
      "prevention": "Use Testcontainers network management",
      "use_when": "Apply when implementing network issues in testing context",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for network_issues",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "ci_cd_integration_github_actions": {
      "description": "Testcontainers in GitHub Actions",
      "setup": "Use services or Docker-in-Docker",
      "example": "services: postgres: image: postgres:15",
      "use_when": "Apply when implementing github actions in testing context",
      "code_example": "services: postgres: image: postgres:15",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for github_actions",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "ci_cd_integration_gitlab_ci": {
      "description": "Testcontainers in GitLab CI",
      "setup": "Use Docker executor or Docker-in-Docker",
      "example": "services: - docker:dind",
      "use_when": "Apply when implementing gitlab ci in testing context",
      "code_example": "services: - docker:dind",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for gitlab_ci",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "ci_cd_integration_jenkins": {
      "description": "Testcontainers in Jenkins",
      "setup": "Install Docker plugin, configure Docker socket",
      "requirements": "Docker available in Jenkins agent",
      "use_when": "Apply when implementing jenkins in testing context",
      "code_example": "def test_pattern():\n    from unittest.mock import Mock\n    mock_dep = Mock(return_value='expected')\n    result = function_under_test(mock_dep)\n    assert result == 'expected'",
      "best_practices": [
        "Document the pattern usage and rationale in code comments for jenkins",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "ci_cd_integration_best_practices": {
      "description": "['Use Docker-in-Docker or Docker socket mounting', 'Enable container reuse', 'Use Testcontainers Cloud for faster execution', 'Clean up containers after pipeline', 'Monitor resource usage']",
      "use_when": "See description for when to apply this pattern.",
      "code_example": "See description for when to apply this pattern.",
      "best_practices": [
        "Review and validate implementation against domain requirements",
        "Review and validate implementation against domain requirements"
      ]
    }
  },
  "best_practices": [
    "Use static containers when possible for performance",
    "Enable container reuse for faster tests",
    "Use @DynamicPropertySource for Spring configuration",
    "Clean up test data with @Transactional or @DirtiesContext",
    "Use appropriate wait strategies",
    "Monitor container resource usage",
    "Use Testcontainers Cloud for CI/CD",
    "Isolate test data per test",
    "Use Docker Compose for complex setups",
    "Configure proper timeouts",
    "Use health checks for container readiness",
    "Clean up containers after tests"
  ],
  "anti_patterns": []
}