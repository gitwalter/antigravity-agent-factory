{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Business Automation Patterns",
  "description": "Patterns for document processing, workflow automation, and CRM integration",
  "version": "1.0.0",
  "patterns": {
    "documentProcessing": {
      "description": "Document parsing and extraction patterns",
      "pdfExtraction": {
        "recommended": "pypdf",
        "ocr": "pytesseract",
        "advanced": "unstructured",
        "installation": "pip install pypdf unstructured pytesseract"
      },
      "basicPdfExtraction": "from pypdf import PdfReader\n\ndef extract_pdf_text(file_path: str) -> str:\n    \"\"\"Extract text from PDF file.\"\"\"\n    reader = PdfReader(file_path)\n    text = ''\n    for page in reader.pages:\n        text += page.extract_text() + '\\n'\n    return text",
      "structuredExtraction": "from unstructured.partition.pdf import partition_pdf\nfrom unstructured.documents.elements import Title, NarrativeText, Table\n\ndef extract_structured_pdf(file_path: str) -> dict:\n    \"\"\"Extract structured content from PDF.\"\"\"\n    elements = partition_pdf(file_path)\n    \n    result = {\n        'titles': [],\n        'paragraphs': [],\n        'tables': []\n    }\n    \n    for element in elements:\n        if isinstance(element, Title):\n            result['titles'].append(str(element))\n        elif isinstance(element, NarrativeText):\n            result['paragraphs'].append(str(element))\n        elif isinstance(element, Table):\n            result['tables'].append(element.metadata.text_as_html)\n    \n    return result",
      "invoiceExtraction": "from pydantic import BaseModel\nfrom typing import List, Optional\nfrom datetime import date\n\nclass LineItem(BaseModel):\n    description: str\n    quantity: float\n    unit_price: float\n    total: float\n\nclass Invoice(BaseModel):\n    invoice_number: str\n    date: date\n    vendor_name: str\n    vendor_address: Optional[str]\n    total_amount: float\n    tax_amount: Optional[float]\n    line_items: List[LineItem]\n\nasync def extract_invoice(pdf_path: str, llm_client) -> Invoice:\n    \"\"\"Extract invoice data using LLM.\"\"\"\n    text = extract_pdf_text(pdf_path)\n    \n    response = await llm_client.chat.completions.create(\n        model='google:gemini-2.5-flash',\n        messages=[{\n            'role': 'user',\n            'content': f'Extract invoice data from this text as JSON:\\n\\n{text}'\n        }],\n        response_format={'type': 'json_object'}\n    )\n    \n    return Invoice.model_validate_json(response.choices[0].message.content)",
      "emailParsing": "import email\nfrom email.policy import default\nfrom typing import List, Tuple\n\ndef parse_email(raw_email: bytes) -> dict:\n    \"\"\"Parse email message.\"\"\"\n    msg = email.message_from_bytes(raw_email, policy=default)\n    \n    return {\n        'from': msg['from'],\n        'to': msg['to'],\n        'subject': msg['subject'],\n        'date': msg['date'],\n        'body': get_email_body(msg),\n        'attachments': get_attachments(msg)\n    }\n\ndef get_email_body(msg) -> str:\n    if msg.is_multipart():\n        for part in msg.walk():\n            if part.get_content_type() == 'text/plain':\n                return part.get_content()\n    return msg.get_content()\n\ndef get_attachments(msg) -> List[Tuple[str, bytes]]:\n    attachments = []\n    for part in msg.walk():\n        if part.get_content_disposition() == 'attachment':\n            attachments.append((\n                part.get_filename(),\n                part.get_content()\n            ))\n    return attachments",
      "use_when": "When implementing documentProcessing",
      "code_example": "// Example for documentProcessing",
      "best_practices": [
        "Use appropriately for best results.",
        "Monitor results and optimize."
      ]
    },
    "workflowAutomation": {
      "description": "Business process automation patterns",
      "stateMachine": "from enum import Enum\nfrom typing import Callable, Dict, Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nclass WorkflowState(str, Enum):\n    PENDING = 'pending'\n    IN_PROGRESS = 'in_progress'\n    REVIEW = 'review'\n    APPROVED = 'approved'\n    REJECTED = 'rejected'\n    COMPLETED = 'completed'\n\nclass WorkflowTransition(BaseModel):\n    from_state: WorkflowState\n    to_state: WorkflowState\n    condition: Optional[str] = None\n    action: Optional[str] = None\n\nclass WorkflowInstance(BaseModel):\n    id: str\n    workflow_type: str\n    current_state: WorkflowState\n    data: dict\n    created_at: datetime\n    updated_at: datetime\n    history: list = []\n\nclass WorkflowEngine:\n    def __init__(self):\n        self.transitions: Dict[str, list] = {}\n        self.actions: Dict[str, Callable] = {}\n    \n    def register_transition(self, workflow_type: str, transition: WorkflowTransition):\n        if workflow_type not in self.transitions:\n            self.transitions[workflow_type] = []\n        self.transitions[workflow_type].append(transition)\n    \n    def register_action(self, name: str, action: Callable):\n        self.actions[name] = action\n    \n    async def transition(self, instance: WorkflowInstance, to_state: WorkflowState) -> bool:\n        valid_transitions = [\n            t for t in self.transitions.get(instance.workflow_type, [])\n            if t.from_state == instance.current_state and t.to_state == to_state\n        ]\n        \n        if not valid_transitions:\n            return False\n        \n        transition = valid_transitions[0]\n        \n        # Execute action if defined\n        if transition.action and transition.action in self.actions:\n            await self.actions**transition.action**\n        \n        # Update state\n        instance.history.append({\n            'from': instance.current_state,\n            'to': to_state,\n            'timestamp': datetime.utcnow()\n        })\n        instance.current_state = to_state\n        instance.updated_at = datetime.utcnow()\n        \n        return True",
      "taskScheduler": "import asyncio\nfrom datetime import datetime, timedelta\nfrom typing import Callable, Dict\nimport heapq\n\nclass ScheduledTask:\n    def __init__(self, run_at: datetime, task_id: str, func: Callable, args: tuple = ()):\n        self.run_at = run_at\n        self.task_id = task_id\n        self.func = func\n        self.args = args\n    \n    def __lt__(self, other):\n        return self.run_at < other.run_at\n\nclass TaskScheduler:\n    def __init__(self):\n        self.queue: list = []\n        self.running = False\n    \n    def schedule(self, task_id: str, func: Callable, delay: timedelta = None, run_at: datetime = None):\n        if delay:\n            run_at = datetime.utcnow() + delay\n        task = ScheduledTask(run_at, task_id, func)\n        heapq.heappush(self.queue, task)\n    \n    async def run(self):\n        self.running = True\n        while self.running:\n            if self.queue:\n                next_task = self.queue[0]\n                wait_time = (next_task.run_at - datetime.utcnow()).total_seconds()\n                \n                if wait_time <= 0:\n                    task = heapq.heappop(self.queue)\n                    await task.func(*task.args)\n                else:\n                    await asyncio.sleep(min(wait_time, 1.0))\n            else:\n                await asyncio.sleep(1.0)\n    \n    def stop(self):\n        self.running = False",
      "approvalWorkflow": "from enum import Enum\nfrom typing import List, Optional\nfrom pydantic import BaseModel\n\nclass ApprovalLevel(BaseModel):\n    level: int\n    approvers: List[str]\n    required_count: int = 1  # How many approvers needed\n    auto_escalate_hours: Optional[int] = None\n\nclass ApprovalRequest(BaseModel):\n    id: str\n    type: str\n    data: dict\n    current_level: int = 0\n    approvals: List[dict] = []\n    rejections: List[dict] = []\n    status: str = 'pending'\n\nclass ApprovalEngine:\n    def __init__(self, levels: List[ApprovalLevel]):\n        self.levels = sorted(levels, key=lambda x: x.level)\n    \n    async def submit(self, request: ApprovalRequest) -> str:\n        await self.notify_approvers(request)\n        return request.id\n    \n    async def approve(self, request: ApprovalRequest, approver: str, comments: str = ''):\n        level = self.levels[request.current_level]\n        \n        if approver not in level.approvers:\n            raise ValueError(f'{approver} is not an approver for level {level.level}')\n        \n        request.approvals.append({\n            'approver': approver,\n            'level': level.level,\n            'comments': comments,\n            'timestamp': datetime.utcnow()\n        })\n        \n        level_approvals = [a for a in request.approvals if a['level'] == level.level]\n        if len(level_approvals) >= level.required_count:\n            if request.current_level < len(self.levels) - 1:\n                request.current_level += 1\n                await self.notify_approvers(request)\n            else:\n                request.status = 'approved'\n                await self.on_approved(request)\n    \n    async def reject(self, request: ApprovalRequest, approver: str, reason: str):\n        request.rejections.append({\n            'approver': approver,\n            'reason': reason,\n            'timestamp': datetime.utcnow()\n        })\n        request.status = 'rejected'\n        await self.on_rejected(request)\n    \n    async def notify_approvers(self, request: ApprovalRequest):\n        level = self.levels[request.current_level]\n        for approver in level.approvers:\n            await self.send_notification(approver, request)\n    \n    async def send_notification(self, approver: str, request: ApprovalRequest):\n        # Implement notification (email, Slack, etc.)\n        pass\n    \n    async def on_approved(self, request: ApprovalRequest):\n        # Implement approved action\n        pass\n    \n    async def on_rejected(self, request: ApprovalRequest):\n        # Implement rejected action\n        pass",
      "use_when": "When implementing workflowAutomation",
      "code_example": "// Example for workflowAutomation",
      "best_practices": [
        "Use appropriately for best results.",
        "Monitor results and optimize."
      ]
    },
    "crmIntegration": {
      "description": "CRM system integration patterns",
      "salesforceClient": "from simple_salesforce import Salesforce\nfrom typing import List, Dict, Optional\n\nclass SalesforceClient:\n    def __init__(self, username: str, password: str, security_token: str, domain: str = 'login'):\n        self.sf = Salesforce(\n            username=username,\n            password=password,\n            security_token=security_token,\n            domain=domain\n        )\n    \n    def get_lead(self, lead_id: str) -> dict:\n        return self.sf.Lead.get(lead_id)\n    \n    def create_lead(self, data: dict) -> str:\n        result = self.sf.Lead.create(data)\n        return result['id']\n    \n    def update_lead(self, lead_id: str, data: dict):\n        self.sf.Lead.update(lead_id, data)\n    \n    def query(self, soql: str) -> List[dict]:\n        result = self.sf.query(soql)\n        return result['records']\n    \n    def get_opportunities(self, account_id: str) -> List[dict]:\n        return self.query(\n            f\"SELECT Id, Name, Amount, StageName FROM Opportunity WHERE AccountId = '{account_id}'\"\n        )",
      "hubspotClient": "import httpx\nfrom typing import List, Optional\n\nclass HubSpotClient:\n    def __init__(self, api_key: str):\n        self.base_url = 'https://api.hubapi.com'\n        self.headers = {'Authorization': f'Bearer {api_key}'}\n    \n    async def get_contact(self, contact_id: str) -> dict:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f'{self.base_url}/crm/v3/objects/contacts/{contact_id}',\n                headers=self.headers\n            )\n            response.raise_for_status()\n            return response.json()\n    \n    async def create_contact(self, properties: dict) -> str:\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                f'{self.base_url}/crm/v3/objects/contacts',\n                headers=self.headers,\n                json={'properties': properties}\n            )\n            response.raise_for_status()\n            return response.json()['id']\n    \n    async def search_contacts(self, query: str) -> List[dict]:\n        async with httpx.AsyncClient() as client:\n            response = await client.post(\n                f'{self.base_url}/crm/v3/objects/contacts/search',\n                headers=self.headers,\n                json={\n                    'filterGroups': [{\n                        'filters': [{\n                            'propertyName': 'email',\n                            'operator': 'CONTAINS_TOKEN',\n                            'value': query\n                        }]\n                    }]\n                }\n            )\n            response.raise_for_status()\n            return response.json()['results']",
      "leadScoring": "from pydantic import BaseModel\nfrom typing import List, Dict\n\nclass ScoringRule(BaseModel):\n    field: str\n    condition: str  # 'equals', 'contains', 'greater_than', 'exists'\n    value: any\n    points: int\n\nclass LeadScorer:\n    def __init__(self, rules: List[ScoringRule]):\n        self.rules = rules\n    \n    def score(self, lead: dict) -> int:\n        total = 0\n        for rule in self.rules:\n            if self._evaluate_rule(lead, rule):\n                total += rule.points\n        return total\n    \n    def _evaluate_rule(self, lead: dict, rule: ScoringRule) -> bool:\n        value = lead.get(rule.field)\n        if value is None:\n            return rule.condition == 'not_exists'\n        \n        if rule.condition == 'equals':\n            return value == rule.value\n        elif rule.condition == 'contains':\n            return rule.value in str(value)\n        elif rule.condition == 'greater_than':\n            return float(value) > float(rule.value)\n        elif rule.condition == 'exists':\n            return True\n        return False\n\n# Example usage\nscorer = LeadScorer([\n    ScoringRule(field='company_size', condition='greater_than', value=100, points=20),\n    ScoringRule(field='job_title', condition='contains', value='CEO', points=30),\n    ScoringRule(field='email', condition='contains', value='@enterprise', points=15),\n    ScoringRule(field='website_visits', condition='greater_than', value=5, points=10)\n])",
      "use_when": "When implementing crmIntegration",
      "code_example": "// Example for crmIntegration",
      "best_practices": [
        "Use appropriately for best results.",
        "Monitor results and optimize."
      ]
    },
    "notifications": {
      "description": "Notification patterns for business workflows",
      "emailNotification": "import smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nfrom typing import List\n\nclass EmailNotifier:\n    def __init__(self, smtp_host: str, smtp_port: int, username: str, password: str):\n        self.smtp_host = smtp_host\n        self.smtp_port = smtp_port\n        self.username = username\n        self.password = password\n    \n    def send(self, to: List[str], subject: str, body: str, html: bool = False):\n        msg = MIMEMultipart('alternative')\n        msg['Subject'] = subject\n        msg['From'] = self.username\n        msg['To'] = ', '.join(to)\n        \n        content_type = 'html' if html else 'plain'\n        msg.attach(MIMEText(body, content_type))\n        \n        with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:\n            server.starttls()\n            server.login(self.username, self.password)\n            server.send_message(msg)",
      "slackNotification": "import httpx\n\nclass SlackNotifier:\n    def __init__(self, webhook_url: str):\n        self.webhook_url = webhook_url\n    \n    async def send(self, message: str, channel: str = None, blocks: list = None):\n        payload = {'text': message}\n        if channel:\n            payload['channel'] = channel\n        if blocks:\n            payload['blocks'] = blocks\n        \n        async with httpx.AsyncClient() as client:\n            response = await client.post(self.webhook_url, json=payload)\n            response.raise_for_status()\n    \n    async def send_alert(self, title: str, message: str, severity: str = 'warning'):\n        color = {'info': '#36a64f', 'warning': '#ff9800', 'error': '#dc3545'}[severity]\n        blocks = [\n            {'type': 'header', 'text': {'type': 'plain_text', 'text': title}},\n            {'type': 'section', 'text': {'type': 'mrkdwn', 'text': message}}\n        ]\n        await self.send(title, blocks=blocks)",
      "use_when": "When implementing notifications",
      "code_example": "// Example for notifications",
      "best_practices": [
        "Use appropriately for best results.",
        "Monitor results and optimize."
      ]
    }
  },
  "langchainIntegration": {
    "documentLoader": "from langchain_community.document_loaders import (\n    PyPDFLoader,\n    UnstructuredEmailLoader,\n    CSVLoader,\n    UnstructuredExcelLoader\n)\n\ndef load_document(file_path: str):\n    \"\"\"Load document based on file type.\"\"\"\n    if file_path.endswith('.pdf'):\n        loader = PyPDFLoader(file_path)\n    elif file_path.endswith('.eml'):\n        loader = UnstructuredEmailLoader(file_path)\n    elif file_path.endswith('.csv'):\n        loader = CSVLoader(file_path)\n    elif file_path.endswith(('.xlsx', '.xls')):\n        loader = UnstructuredExcelLoader(file_path)\n    else:\n        raise ValueError(f'Unsupported file type: {file_path}')\n    \n    return loader.load()",
    "workflowTool": "from langchain_core.tools import tool\n\n@tool\nasync def submit_approval(request_type: str, data: dict, approvers: list) -> str:\n    \"\"\"Submit a request for approval.\n    \n    Args:\n        request_type: Type of approval request (e.g., 'expense', 'leave', 'purchase')\n        data: Request data to be approved\n        approvers: List of approver email addresses\n    \n    Returns:\n        Approval request ID\n    \"\"\"\n    # Implementation\n    pass\n\n@tool\ndef extract_invoice_data(pdf_path: str) -> dict:\n    \"\"\"Extract structured data from an invoice PDF.\n    \n    Args:\n        pdf_path: Path to the invoice PDF file\n    \n    Returns:\n        Extracted invoice data including vendor, amount, line items\n    \"\"\"\n    # Implementation\n    pass"
  },
  "bestPractices": [
    "Use structured extraction with Pydantic models for type safety",
    "Implement idempotent workflow actions to handle retries",
    "Store workflow history for audit trails",
    "Use async operations for I/O-bound tasks",
    "Implement proper error handling with rollback capability",
    "Cache CRM data to reduce API calls",
    "Use webhooks for real-time CRM updates when available",
    "Validate extracted data before processing"
  ],
  "antiPatterns": [
    {
      "name": "No audit trail",
      "problem": "Cannot track workflow history",
      "fix": "Store all state transitions with timestamps"
    },
    {
      "name": "Tight coupling to CRM",
      "problem": "Hard to switch providers",
      "fix": "Use abstraction layer for CRM operations"
    },
    {
      "name": "Synchronous document processing",
      "problem": "Blocks on large files",
      "fix": "Use async processing with progress tracking"
    },
    {
      "name": "No validation",
      "problem": "Invalid data propagates",
      "fix": "Validate all extracted data with Pydantic"
    }
  ],
  "id": "business-automation-patterns",
  "name": "Business Automation Patterns",
  "category": "patterns",
  "best_practices": [],
  "anti_patterns": [],
  "axiomAlignment": {
    "A1_verifiability": "Patterns are verified through automated testing.",
    "A2_user_primacy": "The user maintains control over all generated output.",
    "A3_transparency": "All automated actions are logged and verifiable.",
    "A4_non_harm": "Strict safety checks prevent destructive operations.",
    "A5_consistency": "Uniform patterns ensure predictable system behavior."
  },
  "related_skills": [
    "onboarding-flow"
  ],
  "related_knowledge": [
    "manifest.json"
  ]
}
