{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "tool-design-and-usage-patterns",
  "name": "Tool Design and Usage Patterns",
  "title": "Tool Design and Usage Patterns",
  "description": "Patterns for designing, implementing, and managing tools in LangChain/LangGraph agents including tool decorators, binding, error handling, and permissions",
  "version": "1.0.0",
  "category": "core",
  "axiomAlignment": {
    "A1_verifiability": "All tool patterns include testable examples and validation approaches",
    "A2_user_primacy": "Tools designed to enhance user capabilities with clear boundaries",
    "A3_transparency": "Documented patterns with clear explanations of behavior and side effects",
    "A4_non_harm": "Includes security patterns, permission checks, and error handling for safe tool usage",
    "A5_consistency": "Unified tool design patterns across LangChain and LangGraph ecosystems"
  },
  "related_skills": [
    "tool-usage",
    "mcp-integration",
    "langchain-usage"
  ],
  "related_knowledge": [
    "langchain-patterns.json",
    "mcp-patterns.json"
  ],
  "patterns": {
    "tool_design": {
      "basic_tool": {
        "description": "Simple tool with @tool decorator",
        "example": "@tool\ndef my_tool(arg: str) -> str:\n    \"\"\"Clear docstring for LLM.\"\"\"\n    return result",
        "best_practices": [
          "Write detailed docstrings - LLM uses these",
          "Use type hints for all parameters",
          "Return strings or structured data",
          "Handle errors gracefully"
        ],
        "use_when": "Apply when basic tool is needed in Tool Design and Usage Patterns",
        "code_example": "@tool\ndef my_tool(arg: str) -> str:\n    \"\"\"Clear docstring for LLM.\"\"\"\n    return result"
      },
      "structured_tool": {
        "description": "Tool with Pydantic input schema",
        "example": "StructuredTool.from_function(func=fn, args_schema=InputModel)",
        "use_when": "Complex input validation needed; Multiple optional parameters; Need detailed parameter descriptions",
        "code_example": "StructuredTool.from_function(func=fn, args_schema=InputModel)",
        "best_practices": [
          "Document the pattern usage and rationale in code comments",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "async_tool": {
        "description": "Async tool for I/O operations",
        "example": "@tool\nasync def fetch_data(url: str) -> str:\n    async with httpx.AsyncClient() as client:\n        return (await client.get(url)).text",
        "use_when": "API calls; Database queries; File I/O",
        "code_example": "@tool\nasync def fetch_data(url: str) -> str:\n    async with httpx.AsyncClient() as client:\n        return (await client.get(url)).text",
        "best_practices": [
          "Document the pattern usage and rationale in code comments",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "description": "Category grouping: basic_tool, structured_tool, async_tool",
      "use_when": "Apply when tool design patterns are needed in Tool Design and Usage Patterns",
      "code_example": "# See child patterns under tool_design for implementation examples",
      "best_practices": [
        "Refer to specific child patterns for implementation details",
        "Apply the category pattern appropriate to your use case"
      ]
    },
    "tool_binding": {
      "bind_to_llm": {
        "description": "Attach tools to LLM for calling",
        "example": "llm_with_tools = llm.bind_tools([tool1, tool2])",
        "notes": "Returns AIMessage with tool_calls attribute",
        "use_when": "Apply when bind to llm is needed in Tool Design and Usage Patterns",
        "code_example": "llm_with_tools = llm.bind_tools([tool1, tool2])",
        "best_practices": [
          "Document the pattern usage and rationale in code comments",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "tool_execution": {
        "description": "Execute tool calls from LLM response",
        "pattern": "Build tools_map, iterate tool_calls, invoke each, return ToolMessages",
        "use_when": "Apply when tool execution is needed in Tool Design and Usage Patterns",
        "code_example": "# Implement tool_execution per tool-patterns patterns\n# See description and related documentation",
        "best_practices": [
          "Document the pattern usage and rationale in code comments",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "description": "Category grouping: bind_to_llm, tool_execution",
      "use_when": "Apply when tool binding patterns are needed in Tool Design and Usage Patterns",
      "code_example": "# See child patterns under tool_binding for implementation examples",
      "best_practices": [
        "Refer to specific child patterns for implementation details",
        "Apply the category pattern appropriate to your use case"
      ]
    },
    "error_handling": {
      "retry_pattern": {
        "description": "Retry on transient failures",
        "library": "tenacity",
        "example": "@retry(stop=stop_after_attempt(3), wait=wait_exponential())",
        "use_when": "Apply when retry pattern is needed in Tool Design and Usage Patterns",
        "code_example": "@retry(stop=stop_after_attempt(3), wait=wait_exponential())",
        "best_practices": [
          "Document the pattern usage and rationale in code comments",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "graceful_failure": {
        "description": "Return error message instead of raising",
        "example": "try:\n    return result\nexcept Exception as e:\n    return f'Error: {e}'",
        "use_when": "Apply when graceful failure is needed in Tool Design and Usage Patterns",
        "code_example": "try:\n    return result\nexcept Exception as e:\n    return f'Error: {e}'",
        "best_practices": [
          "Document the pattern usage and rationale in code comments",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "description": "Category grouping: retry_pattern, graceful_failure",
      "use_when": "Apply when error handling patterns are needed in Tool Design and Usage Patterns",
      "code_example": "# See child patterns under error_handling for implementation examples",
      "best_practices": [
        "Refer to specific child patterns for implementation details",
        "Apply the category pattern appropriate to your use case"
      ]
    },
    "security": {
      "input_validation": {
        "description": "Validate and sanitize inputs",
        "patterns": [
          "Path validation",
          "SQL injection prevention",
          "Rate limiting"
        ],
        "use_when": "Apply when input validation is needed in Tool Design and Usage Patterns",
        "code_example": "# Implement input_validation per tool-patterns patterns\n# See description and related documentation",
        "best_practices": [
          "Document the pattern usage and rationale in code comments",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "permission_checking": {
        "description": "Check permissions before execution",
        "levels": [
          "READ",
          "WRITE",
          "EXECUTE",
          "NETWORK"
        ],
        "use_when": "Apply when permission checking is needed in Tool Design and Usage Patterns",
        "code_example": "# Implement permission_checking per tool-patterns patterns\n# See description and related documentation",
        "best_practices": [
          "Document the pattern usage and rationale in code comments",
          "Validate implementation against domain requirements before deployment"
        ]
      },
      "description": "Category grouping: input_validation, permission_checking",
      "use_when": "Apply when security patterns are needed in Tool Design and Usage Patterns",
      "code_example": "# See child patterns under security for implementation examples",
      "best_practices": [
        "Refer to specific child patterns for implementation details",
        "Apply the category pattern appropriate to your use case"
      ]
    }
  },
  "tool_categories": {
    "data_retrieval": [
      "web_search",
      "database_query",
      "api_fetch",
      "file_read"
    ],
    "computation": [
      "calculate",
      "analyze",
      "transform",
      "validate"
    ],
    "io_operations": [
      "read_file",
      "write_file",
      "upload",
      "download"
    ],
    "external_services": [
      "send_email",
      "create_ticket",
      "notify",
      "webhook"
    ],
    "system": [
      "execute_command",
      "manage_process",
      "monitor"
    ]
  },
  "anti_patterns": [
    {
      "name": "Vague or Missing Docstrings",
      "problem": "LLMs rely on tool docstrings to understand what tools do and when to use them. Vague or missing docstrings cause agents to misuse tools, call wrong tools, or fail to use available functionality.",
      "solution": "Write detailed docstrings that clearly describe the tool's purpose, all parameters with types and descriptions, return value format, and example usage. Include edge cases and error conditions."
    },
    {
      "name": "No Error Handling",
      "problem": "Unhandled exceptions in tool execution crash the agent loop, expose stack traces to users, and prevent agents from recovering or trying alternative approaches. Agents cannot distinguish between transient and permanent failures.",
      "solution": "Wrap all tool execution in try/except blocks. Catch specific exceptions, return structured error messages as strings or dicts instead of raising, and log errors for debugging. Use retry decorators for transient failures."
    },
    {
      "name": "Synchronous I/O in Async Context",
      "problem": "Using blocking file I/O, HTTP requests, or database queries in async tool handlers blocks the entire event loop, preventing concurrent tool execution and causing poor performance.",
      "solution": "Use async/await for all I/O operations. Use aiofiles for file I/O, async HTTP clients (httpx, aiohttp), and async database drivers. Never use synchronous I/O libraries (requests, open()) in async handlers."
    },
    {
      "name": "Missing Input Validation",
      "problem": "Accepting tool inputs without validation allows malicious or malformed data to cause security vulnerabilities (path traversal, SQL injection), crashes, or unexpected behavior.",
      "solution": "Validate all inputs using Pydantic models or JSON Schema. Check parameter types, ranges, required fields, and format constraints. Sanitize file paths, SQL queries, and shell commands. Reject invalid inputs with clear error messages."
    },
    {
      "name": "Raising Exceptions Instead of Returning Errors",
      "problem": "Raising exceptions in tools breaks the agent execution flow. Agents cannot handle exceptions gracefully and may retry indefinitely or fail completely instead of trying alternative approaches.",
      "solution": "Return error information as structured data (strings or dicts) instead of raising exceptions. Use return values like {'error': 'message', 'code': 'ERROR_CODE'} or simple error strings. Let the agent decide how to handle errors."
    }
  ],
  "best_practices": [
    "Write comprehensive docstrings for all tools - LLMs use these to understand tool purpose and parameters",
    "Use Pydantic schemas for complex tool inputs to enable validation and clear parameter descriptions",
    "Always return error messages as strings or structured dicts instead of raising exceptions - let agents handle errors",
    "Use async/await for all I/O operations (file, network, database) - never block the event loop with sync I/O",
    "Validate and sanitize all inputs before processing - check types, ranges, and format constraints",
    "Implement retry logic with exponential backoff for transient failures using tenacity decorators",
    "Check permissions before executing actions - verify READ/WRITE/EXECUTE/NETWORK permissions explicitly",
    "Use StructuredTool.from_function() for tools with complex inputs requiring validation",
    "Return structured outputs (dicts with consistent keys) when possible for easier agent parsing",
    "Log all tool executions with context (agent_id, tool_name, inputs, duration) for debugging and monitoring"
  ]
}