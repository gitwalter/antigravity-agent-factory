{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "formal-verification-patterns",
  "name": "Formal Verification Patterns",
  "title": "Formal Verification Patterns",
  "description": "Invariants, pre/post conditions, property-based testing, model checking",
  "version": "1.0.0",
  "last_updated": "2026-02-10",
  "category": "core",
  "axiomAlignment": {
    "A1_verifiability": "Invariants and property-based testing enable verification of correctness",
    "A2_user_primacy": "Preconditions and postconditions prevent failures that harm users",
    "A3_transparency": "Formal specifications make intended behavior explicit",
    "A4_non_harm": "Model checking and fuzzing detect safety violations before deployment",
    "A5_consistency": "Unified verification patterns across invariants, contracts, and tests"
  },
  "related_skills": [
    "grounding-verification",
    "agent-testing",
    "bdd",
    "strawberry-verification"
  ],
  "related_knowledge": [
    "review-checklist.json",
    "axiom-zero.json",
    "test-patterns.json",
    "tdd-patterns.json"
  ],
  "patterns": {
    "invariants": {
      "description": "Properties that must hold at all times during execution",
      "examples": [
        "Balance never negative",
        "List size always non-negative",
        "FIFO order preserved"
      ],
      "when_to_use": "Stateful systems, data structures, protocols",
      "implementation": "Assert statements, runtime checks, or static analysis",
      "best_practices": [
        "Document invariants",
        "Check at critical points",
        "Minimize overhead"
      ],
      "use_when": "Stateful systems, data structures, protocols",
      "code_example": "Balance never negative; List size always non-negative; FIFO order preserved"
    },
    "preconditions": {
      "description": "Conditions that must hold before function execution",
      "idiom": "def withdraw(amount): assert amount > 0 and amount <= balance",
      "when_to_use": "Contract validation, defensive programming",
      "tools": [
        "assert",
        "requires in Eiffel",
        "contracts in Python",
        "JSpecify"
      ],
      "best_practices": [
        "Clear error messages",
        "Document in docstring"
      ],
      "use_when": "Contract validation, defensive programming",
      "code_example": "def withdraw(amount): assert amount > 0 and amount <= balance"
    },
    "postconditions": {
      "description": "Conditions that must hold after function execution",
      "idiom": "def sort(lst): ...; assert is_sorted(lst); return lst",
      "when_to_use": "Guaranteeing output properties",
      "best_practices": [
        "Relate to inputs",
        "Check side effects",
        "Use in property tests"
      ],
      "use_when": "Guaranteeing output properties",
      "code_example": "def sort(lst): ...; assert is_sorted(lst); return lst"
    },
    "property_based_testing": {
      "description": "Generate random inputs; verify invariants and properties",
      "tools": [
        "Hypothesis (Python)",
        "fast-check (JS)",
        "jqwik (Java)",
        "QuickCheck (Haskell)"
      ],
      "properties": [
        "idempotency: f(f(x)) == f(x)",
        "roundtrip: decode(encode(x)) == x",
        "monotonicity"
      ],
      "when_to_use": "Serialization, parsers, pure functions",
      "best_practices": [
        "Define clear properties",
        "Use shrinking",
        "Combine with example tests"
      ],
      "use_when": "Serialization, parsers, pure functions",
      "code_example": "# Implement property_based_testing per formal-verification patterns\n# See description and related documentation"
    },
    "model_checking": {
      "description": "Exhaustively explore state space for temporal logic properties",
      "tools": [
        "TLA+",
        "SPIN",
        "CBMC",
        "Alloy"
      ],
      "when_to_use": "Concurrency, protocols, distributed systems",
      "properties": [
        "Liveness",
        "Safety",
        "Deadlock freedom"
      ],
      "best_practices": [
        "Start with small models",
        "Incrementally refine",
        "Abstract when scaling"
      ],
      "use_when": "Concurrency, protocols, distributed systems",
      "code_example": "# Implement model_checking per formal-verification patterns\n# See description and related documentation"
    },
    "type_based_verification": {
      "description": "Types encode invariants; compiler enforces",
      "techniques": [
        "Phantom types",
        "Refinement types",
        "Dependent types"
      ],
      "when_to_use": "Eliminate entire classes of bugs",
      "best_practices": [
        "Strict types",
        "Use branded types for IDs"
      ],
      "use_when": "Eliminate entire classes of bugs",
      "code_example": "# Implement type_based_verification per formal-verification patterns\n# See description and related documentation"
    },
    "assertion_density": {
      "description": "Strategic placement of assertions for verification",
      "guidelines": [
        "Entry/exit of functions",
        "Loop invariants",
        "After critical operations"
      ],
      "when_to_use": "Complex logic, safety-critical",
      "best_practices": [
        "Don't over-assert",
        "Use in debug builds",
        "Integrate with tests"
      ],
      "use_when": "Complex logic, safety-critical",
      "code_example": "# Implement assertion_density per formal-verification patterns\n# See description and related documentation"
    },
    "fuzzing": {
      "description": "Random or mutation-based input to find bugs",
      "tools": [
        "AFL",
        "libFuzzer",
        "Hypothesis",
        "Jazzer"
      ],
      "when_to_use": "Parsers, decoders, parsers",
      "best_practices": [
        "Corpus for coverage",
        "Minimize for reproduction",
        "Combine with sanitizers"
      ],
      "use_when": "Parsers, decoders, parsers",
      "code_example": "# Implement fuzzing per formal-verification patterns\n# See description and related documentation"
    }
  },
  "best_practices": [
    "Document invariants",
    "Check at critical points",
    "Minimize overhead",
    "Fail fast",
    "Clear error messages",
    "Document in docstring",
    "Relate to inputs",
    "Check side effects"
  ],
  "anti_patterns": [
    "Applying patterns without understanding the underlying concepts",
    "Copy-pasting solutions without adapting to specific context",
    "Over-engineering simple problems with complex patterns"
  ]
}