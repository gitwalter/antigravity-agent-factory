{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "security-checklist",
  "name": "Security Checklist",
  "title": "Security Checklist",
  "description": "Security best practices, OWASP guidelines, and authentication patterns",
  "version": "1.0.0",
  "category": "security",
  "categories": {
    "authentication": {
      "description": "Verifying user identity",
      "priority": "critical"
    },
    "authorization": {
      "description": "Controlling access to resources",
      "priority": "critical"
    },
    "inputValidation": {
      "description": "Validating and sanitizing user input",
      "priority": "critical"
    },
    "dataProtection": {
      "description": "Protecting sensitive data at rest and in transit",
      "priority": "high"
    },
    "secretsManagement": {
      "description": "Handling API keys, passwords, and credentials",
      "priority": "critical"
    },
    "logging": {
      "description": "Security logging and monitoring",
      "priority": "high"
    }
  },
  "owaspTop10": {
    "A01_BrokenAccessControl": {
      "name": "Broken Access Control",
      "description": "Restrictions on authenticated users are not properly enforced",
      "checks": [
        "Verify access control on every request",
        "Deny by default except for public resources",
        "Implement proper CORS policies",
        "Disable directory listing",
        "Invalidate JWT tokens on logout"
      ],
      "codePatterns": {
        "python_fastapi": "@app.get('/resource/{id}')\nasync def get_resource(id: int, user: User = Depends(get_current_user)):\n    resource = await get_resource_by_id(id)\n    if resource.owner_id != user.id:\n        raise HTTPException(status_code=403, detail='Forbidden')\n    return resource",
        "typescript_nextjs": "export async function GET(req: Request, { params }: { params: { id: string } }) {\n  const session = await getServerSession();\n  const resource = await db.resource.findUnique({ where: { id: params.id } });\n  if (resource?.ownerId !== session?.user?.id) {\n    return new Response('Forbidden', { status: 403 });\n  }\n  return Response.json(resource);\n}"
      }
    },
    "A02_CryptographicFailures": {
      "name": "Cryptographic Failures",
      "description": "Failures related to cryptography leading to sensitive data exposure",
      "checks": [
        "Use TLS 1.2+ for all connections",
        "Hash passwords with bcrypt/argon2 (cost factor >= 12)",
        "Never store sensitive data in plain text",
        "Use strong random number generators",
        "Rotate encryption keys regularly"
      ],
      "codePatterns": {
        "python": "from passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')\n\ndef hash_password(password: str) -> str:\n    return pwd_context.hash(password)\n\ndef verify_password(plain: str, hashed: str) -> bool:\n    return pwd_context.verify(plain, hashed)",
        "csharp": "using BCrypt.Net;\n\npublic class PasswordService\n{\n    public string HashPassword(string password) =>\n        BCrypt.HashPassword(password, BCrypt.GenerateSalt(12));\n    \n    public bool VerifyPassword(string password, string hash) =>\n        BCrypt.Verify(password, hash);\n}"
      }
    },
    "A03_Injection": {
      "name": "Injection",
      "description": "User-supplied data is not validated, filtered, or sanitized",
      "checks": [
        "Use parameterized queries or ORMs",
        "Validate and sanitize all user inputs",
        "Escape output based on context (HTML, SQL, JS)",
        "Use allowlists for input validation",
        "Limit SQL query results"
      ],
      "codePatterns": {
        "python_sqlalchemy": "# SAFE: Parameterized query\nresult = db.execute(\n    select(User).where(User.email == email)\n)\n\n# UNSAFE - SQL Injection vulnerable\n# result = db.execute(f\"SELECT * FROM users WHERE email = '{email}'\")",
        "typescript_prisma": "// SAFE: Prisma handles parameterization\nconst user = await prisma.user.findUnique({\n  where: { email: userInput }\n});\n\n// UNSAFE - Raw query with interpolation\n// await prisma.$queryRaw`SELECT * FROM users WHERE email = ${userInput}`"
      }
    },
    "A04_InsecureDesign": {
      "name": "Insecure Design",
      "description": "Missing or ineffective security controls in design",
      "checks": [
        "Implement threat modeling during design",
        "Use secure design patterns",
        "Implement rate limiting",
        "Add circuit breakers for external services",
        "Design for failure and recovery"
      ]
    },
    "A05_SecurityMisconfiguration": {
      "name": "Security Misconfiguration",
      "description": "Missing appropriate security hardening",
      "checks": [
        "Remove default credentials",
        "Disable unnecessary features and services",
        "Configure proper security headers",
        "Keep dependencies updated",
        "Use environment-specific configurations"
      ],
      "securityHeaders": {
        "Content-Security-Policy": "default-src 'self'; script-src 'self'",
        "X-Content-Type-Options": "nosniff",
        "X-Frame-Options": "DENY",
        "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
        "X-XSS-Protection": "1; mode=block"
      }
    },
    "A06_VulnerableComponents": {
      "name": "Vulnerable and Outdated Components",
      "description": "Using components with known vulnerabilities",
      "checks": [
        "Maintain inventory of all components and versions",
        "Remove unused dependencies",
        "Monitor for CVEs in dependencies",
        "Use automated dependency scanning",
        "Subscribe to security advisories"
      ],
      "tools": {
        "python": [
          "pip-audit",
          "safety",
          "bandit"
        ],
        "javascript": [
          "npm audit",
          "snyk",
          "dependabot"
        ],
        "csharp": [
          "dotnet list package --vulnerable",
          "OWASP Dependency-Check"
        ]
      }
    },
    "A07_AuthenticationFailures": {
      "name": "Identification and Authentication Failures",
      "description": "Weaknesses in authentication mechanisms",
      "checks": [
        "Implement multi-factor authentication",
        "Enforce strong password policies",
        "Limit failed login attempts",
        "Use secure session management",
        "Implement proper logout functionality"
      ],
      "passwordPolicy": {
        "minLength": 12,
        "requireUppercase": true,
        "requireLowercase": true,
        "requireNumbers": true,
        "requireSpecialChars": true,
        "preventCommonPasswords": true,
        "preventPasswordReuse": 5
      }
    },
    "A08_SoftwareDataIntegrity": {
      "name": "Software and Data Integrity Failures",
      "description": "Code and infrastructure that does not protect against integrity violations",
      "checks": [
        "Verify digital signatures on updates",
        "Use integrity checking for CI/CD pipelines",
        "Verify npm/pip package integrity",
        "Implement proper deserialization controls",
        "Use signed commits"
      ]
    },
    "A09_LoggingMonitoring": {
      "name": "Security Logging and Monitoring Failures",
      "description": "Insufficient logging, detection, monitoring, and active response",
      "checks": [
        "Log authentication attempts (success and failure)",
        "Log access control failures",
        "Log input validation failures",
        "Ensure logs have sufficient context",
        "Implement alerting for suspicious activities"
      ],
      "logFormat": {
        "fields": [
          "timestamp",
          "level",
          "user_id",
          "action",
          "resource",
          "ip_address",
          "user_agent",
          "result"
        ]
      }
    },
    "A10_SSRF": {
      "name": "Server-Side Request Forgery",
      "description": "Web application fetches remote resources without validating user-supplied URL",
      "checks": [
        "Validate and sanitize all client-supplied URLs",
        "Use allowlists for permitted domains",
        "Disable HTTP redirects",
        "Block requests to internal IP ranges",
        "Use network segmentation"
      ],
      "blockedIpRanges": [
        "10.0.0.0/8",
        "172.16.0.0/12",
        "192.168.0.0/16",
        "127.0.0.0/8",
        "169.254.0.0/16"
      ]
    }
  },
  "authenticationPatterns": {
    "jwt": {
      "name": "JSON Web Tokens",
      "useCase": "Stateless API authentication",
      "bestPractices": [
        "Use RS256 (asymmetric) for distributed systems",
        "Keep token expiry short (15-60 minutes)",
        "Implement refresh token rotation",
        "Store refresh tokens securely (httpOnly cookies)",
        "Include minimal claims in access tokens"
      ],
      "antiPatterns": [
        "Storing JWTs in localStorage (XSS vulnerable)",
        "Long-lived access tokens",
        "Storing sensitive data in JWT payload",
        "Not validating token signature"
      ]
    },
    "session": {
      "name": "Server-Side Sessions",
      "useCase": "Traditional web applications",
      "bestPractices": [
        "Use secure, httpOnly, sameSite cookies",
        "Regenerate session ID after login",
        "Implement session timeout",
        "Store sessions in Redis/database for scalability",
        "Invalidate sessions on logout"
      ]
    },
    "oauth2": {
      "name": "OAuth 2.0",
      "useCase": "Third-party authentication and authorization",
      "flows": {
        "authorizationCode": "Web apps with backend (most secure)",
        "authorizationCodePKCE": "SPAs and mobile apps",
        "clientCredentials": "Machine-to-machine communication"
      },
      "bestPractices": [
        "Always use PKCE for public clients",
        "Validate redirect URIs strictly",
        "Use state parameter to prevent CSRF",
        "Request minimal scopes",
        "Validate ID token claims"
      ]
    }
  },
  "secretsManagement": {
    "rules": [
      "Never commit secrets to version control",
      "Use environment variables or secret managers",
      "Rotate secrets regularly",
      "Use different secrets per environment",
      "Implement secret scanning in CI/CD"
    ],
    "tools": {
      "cloud": [
        "AWS Secrets Manager",
        "Azure Key Vault",
        "Google Secret Manager"
      ],
      "selfHosted": [
        "HashiCorp Vault",
        "Doppler",
        "Infisical"
      ],
      "gitScanning": [
        "git-secrets",
        "gitleaks",
        "trufflehog"
      ]
    },
    "envFileRules": {
      "gitignore": [
        ".env",
        ".env.local",
        ".env.*.local",
        "*.pem",
        "*.key"
      ],
      "exampleFile": "Provide .env.example with placeholder values"
    }
  },
  "inputValidation": {
    "principles": [
      "Validate on both client and server (server is authoritative)",
      "Use allowlists over denylists",
      "Validate type, length, format, and range",
      "Sanitize based on output context",
      "Reject invalid input, don't try to fix it"
    ],
    "commonPatterns": {
      "email": "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
      "uuid": "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
      "slug": "^[a-z0-9]+(?:-[a-z0-9]+)*$",
      "phone": "^\\+?[1-9]\\d{1,14}$"
    }
  },
  "securityByStack": {
    "python-fastapi": {
      "authentication": [
        "python-jose",
        "passlib",
        "authlib"
      ],
      "validation": [
        "pydantic"
      ],
      "scanning": [
        "bandit",
        "safety",
        "pip-audit"
      ]
    },
    "typescript-nextjs": {
      "authentication": [
        "next-auth",
        "lucia",
        "clerk"
      ],
      "validation": [
        "zod",
        "yup"
      ],
      "scanning": [
        "npm audit",
        "snyk"
      ]
    },
    "csharp-dotnet": {
      "authentication": [
        "ASP.NET Core Identity",
        "IdentityServer"
      ],
      "validation": [
        "FluentValidation",
        "DataAnnotations"
      ],
      "scanning": [
        "dotnet list package --vulnerable"
      ]
    }
  },
  "patterns": {
    "general_description": {
      "description": "Security best practices, OWASP guidelines, and authentication patterns",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# general_description pattern for security-checklist\n# Implement based on description: Security best practices, OWASP guidelines, and aut...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "general_usage": {
      "description": "See detailed sections below",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# general_usage pattern for security-checklist\n# Implement based on description: See detailed sections below...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    }
  },
  "best_practices": [
    "Verify access control on every request - check user permissions before allowing access to resources",
    "Use parameterized queries or ORMs for all database operations to prevent SQL injection attacks",
    "Hash passwords with bcrypt or argon2 with appropriate cost factors (bcrypt cost >= 12, argon2 iterations >= 3)",
    "Implement multi-factor authentication (MFA) for sensitive operations and admin accounts",
    "Set secure HTTP headers - Content-Security-Policy, X-Content-Type-Options, X-Frame-Options, Strict-Transport-Security",
    "Use environment variables or secret managers for all credentials - never commit secrets to version control",
    "Validate and sanitize all user inputs on the server side - client-side validation is not sufficient",
    "Implement rate limiting per user and endpoint to prevent brute force and DoS attacks",
    "Log authentication attempts (both success and failure) with sufficient context for security monitoring",
    "Keep dependencies updated and scan for known vulnerabilities using tools like pip-audit, npm audit, or Snyk",
    "Use HTTPS for all connections - enforce TLS 1.2+ and redirect HTTP to HTTPS",
    "Implement proper session management - use secure, httpOnly, sameSite cookies and regenerate session IDs after login",
    "Use JWT tokens with short expiration times (15-60 minutes) and implement refresh token rotation",
    "Block requests to internal IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) to prevent SSRF attacks"
  ],
  "anti_patterns": [
    {
      "name": "Trusting User Input Without Validation",
      "problem": "Accepting user input without validation leads to injection attacks (SQL, XSS, command injection), data corruption, and security vulnerabilities",
      "fix": "Always validate and sanitize user inputs on the server side using allowlists, type checking, length limits, and format validation. Use parameterized queries for database operations"
    },
    {
      "name": "Storing Passwords in Plain Text",
      "problem": "Storing passwords in plain text exposes them if the database is compromised, violating user privacy and security best practices",
      "fix": "Always hash passwords using bcrypt, argon2, or scrypt with appropriate cost factors. Never store passwords in plain text or use weak hashing algorithms like MD5 or SHA1"
    },
    {
      "name": "Hardcoding Secrets and Credentials",
      "problem": "Hardcoding API keys, passwords, or tokens in source code exposes them in version control, making them accessible to anyone with repository access",
      "fix": "Use environment variables, secret management systems (AWS Secrets Manager, HashiCorp Vault), or configuration files excluded from version control. Provide .env.example with placeholder values"
    },
    {
      "name": "Missing Access Control Checks",
      "problem": "Not verifying user permissions on every request allows unauthorized access to resources, leading to data breaches and privilege escalation",
      "fix": "Implement access control checks on every request. Verify user permissions, resource ownership, and role-based access before allowing operations. Deny by default"
    },
    {
      "name": "No Rate Limiting",
      "problem": "Absence of rate limiting allows brute force attacks, DoS attacks, and resource exhaustion, making the system vulnerable to abuse",
      "fix": "Implement rate limiting per user and endpoint using sliding window or token bucket algorithms. Set appropriate limits based on normal usage patterns and monitor for violations"
    },
    {
      "name": "Insufficient Security Logging",
      "problem": "Lack of security event logging makes it impossible to detect attacks, investigate incidents, or comply with audit requirements",
      "fix": "Log all security-relevant events including authentication attempts, access control failures, input validation errors, and suspicious activities. Include sufficient context (timestamp, user ID, IP address, action, result)"
    },
    {
      "name": "Using Weak Authentication Mechanisms",
      "problem": "Weak passwords, no MFA, and long-lived sessions increase the risk of account compromise and unauthorized access",
      "fix": "Enforce strong password policies (min 12 chars, mixed case, numbers, special chars), implement MFA for sensitive accounts, use short-lived sessions with secure cookies, and limit failed login attempts"
    }
  ],
  "axiomAlignment": {
    "A1_verifiability": "All patterns include verifiable examples and test approaches",
    "A2_user_primacy": "Patterns prioritize user needs and practical outcomes",
    "A3_transparency": "Pattern selection rationale is clearly documented",
    "A4_non_harm": "Patterns include safety considerations and error handling",
    "A5_consistency": "Patterns follow established conventions and standards"
  },
  "related_skills": [
    "none"
  ],
  "related_knowledge": [
    "best-practices.json"
  ],
  "sast_dast": {
    "description": "Static and dynamic analysis tools for security testing",
    "use_when": "Identifying vulnerabilities in code and running applications",
    "code_example": "# Static analysis - Bandit (Python)\npip install bandit\nbandit -r src/ -f json -o report.json\n\n# Semgrep\nsemgrep scan --config auto --output results.json\n\n# Dynamic - OWASP ZAP\nzap-cli quick-scan --self-contained http://localhost:8000\nzap-cli active-scan http://localhost:8000\n\n# Burp Suite - proxy at 127.0.0.1:8080 for manual testing",
    "best_practices": [
      "Run SAST in CI/CD pipeline",
      "Use DAST against staging environments",
      "Fix high/critical findings before release"
    ],
    "tools": {
      "sast": [
        "Bandit",
        "SonarQube",
        "Semgrep"
      ],
      "dast": [
        "OWASP ZAP",
        "Burp Suite",
        "Nikto"
      ]
    }
  },
  "dependency_scanning": {
    "description": "Scan dependencies for known vulnerabilities",
    "use_when": "All projects - identify vulnerable packages",
    "code_example": "# Python - pip-audit\npip install pip-audit\npip-audit\n\n# Python - safety\npip install safety\nsafety check --json\n\n# Dependabot (.github/dependabot.yml)\nversion: 2\nupdates:\n  - package-ecosystem: \"pip\"\n    directory: \"/\"\n    schedule: { interval: \"weekly\" }\n\n# Snyk\nsnyk test\nsnyk auth\nsnyk monitor",
    "best_practices": [
      "Run scanning in CI",
      "Configure automated PR creation",
      "Prioritize direct dependency fixes"
    ],
    "tools": {
      "python": [
        "pip-audit",
        "safety",
        "snyk"
      ],
      "javascript": [
        "npm audit",
        "snyk",
        "dependabot"
      ]
    }
  },
  "secure_coding_patterns": {
    "description": "Input validation, parameterized queries, secrets management, CSRF protection",
    "use_when": "Implementing application logic",
    "code_example": "# Input validation (Pydantic)\nfrom pydantic import BaseModel, validator\nclass UserInput(BaseModel):\n    email: str\n    @validator('email')\n    def validate_email(cls, v):\n        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$', v):\n            raise ValueError('Invalid email')\n        return v.lower()\n\n# Parameterized query (SAFE)\ndb.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n\n# Secrets: api_key = os.environ.get('API_KEY')\n\n# CSRF (Flask): from flask_wtf.csrf import CSRFProtect\ncsrf = CSRFProtect(app)",
    "best_practices": [
      "Validate all user input",
      "Never concatenate SQL",
      "Use environment variables for secrets",
      "Enable CSRF for state-changing requests"
    ]
  },
  "container_security": {
    "description": "Image scanning, runtime security, least privilege containers",
    "use_when": "Deploying containerized applications",
    "code_example": "# Trivy - image scanning\ntrivy image python:3.11-slim\ntrivy image --severity HIGH,CRITICAL myapp:latest\n\n# Grype\ngrype myapp:latest -o json\n\n# Dockerfile - least privilege\nFROM python:3.11-slim\nRUN adduser --disabled-password appuser\nUSER appuser\nCOPY --chown=appuser:appuser app/ /app\nWORKDIR /app\n\n# Runtime - read-only, drop capabilities\ndocker run --read-only --cap-drop=ALL myapp:latest\n\n# docker-compose: security_opt: [no-new-privileges:true], read_only: true, user: \"1000:1000\"",
    "best_practices": [
      "Scan images before deployment",
      "Run as non-root user",
      "Use minimal base images",
      "Drop unnecessary capabilities"
    ]
  }
}
