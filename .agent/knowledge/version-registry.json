{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "version-registry",
  "name": "Version Registry",
  "title": "Version Registry",
  "version": "1.1.1",
  "description": "Centralized registry of recommended package versions and LLM models for Factory-generated projects",
  "category": "core",
  "axiomAlignment": {
    "A1_verifiability": "Registry enables verification of project dependency versions",
    "A2_user_primacy": "Version recommendations support user project requirements",
    "A3_transparency": "Explicit version metadata makes compatibility traceable",
    "A4_non_harm": "Version validation prevents incompatible or vulnerable packages",
    "A5_consistency": "Unified version recommendations across languages and stacks"
  },
  "related_skills": [
    "version-check",
    "stack-configuration",
    "factory-updates"
  ],
  "related_knowledge": [
    "skill-catalog.json",
    "dependency-graph.json",
    "factory-updates.json"
  ],
  "last_updated": "2026-02-15",
  "packages": {
    "python": {
      "langchain": "1.2.9",
      "langchain-mcp-adapters": "0.2.0",
      "langgraph": "1.0.8",
      "langgraph-checkpoint-postgres": "2.0+",
      "crewai": "1.9.3",
      "pytorch": "2.10.0",
      "transformers": "5.1.0",
      "fastapi": "0.128.4",
      "pydantic": "2.10.0",
      "pydantic-ai": "0.1+",
      "openai": "1.60+",
      "openai-agents": "0.1+",
      "anthropic": "0.40+",
      "instructor": "1.8+",
      "dspy": "3.0+",
      "aisuite": "0.1.14",
      "autogen-agentchat": "0.4+",
      "autogen-core": "0.4+",
      "mem0ai": "0.1+",
      "colbert-ai": "0.2+"
    },
    "javascript": {
      "next": "16.1.6",
      "react": "19.2.1",
      "typescript": "5.7+",
      "vite": "6.x"
    },
    "java": {
      "spring-boot": "4.0.2",
      "kotlin": "2.1+"
    },
    "dotnet": {
      "aspnetcore": "10.0.0"
    },
    "rust": {
      "anchor": "0.32.1",
      "solana-sdk": "2.x"
    }
  },
  "llm_models": {
    "openai": {
      "flagship": "gpt-5.2",
      "coding": "gpt-5.3-codex",
      "reasoning": "o1-pro",
      "fast": "gpt-4o"
    },
    "anthropic": {
      "flagship": "claude-opus-4.6",
      "balanced": "claude-sonnet-4",
      "fast": "claude-haiku-4"
    },
    "google": {
      "flagship": "gemini-3-pro",
      "fast": "gemini-3-flash",
      "adk_default": "gemini-2.5-flash"
    }
  },
  "agent_frameworks": {
    "langchain": {
      "description": "LangChain 1.x with LCEL for chains and agents",
      "package": "langchain",
      "version": "1.2.9"
    },
    "langgraph": {
      "description": "Stateful multi-agent orchestration with graph workflows",
      "package": "langgraph",
      "version": "1.0.8"
    },
    "crewai": {
      "description": "Multi-agent crews with A2A and MCP support",
      "package": "crewai",
      "version": "1.9.3"
    },
    "openai_agents": {
      "description": "OpenAI Agents SDK (production replacement for Swarm)",
      "package": "openai-agents",
      "version": "0.1+"
    },
    "autogen": {
      "description": "Microsoft AutoGen event-driven multi-agent framework",
      "package": "autogen-agentchat",
      "version": "0.4+"
    },
    "pydantic_ai": {
      "description": "Schema-safe agents with structured outputs",
      "package": "pydantic-ai",
      "version": "0.1+"
    },
    "google_adk": {
      "description": "Google Agent Development Kit for Gemini models",
      "package": "google-adk",
      "version": "0.1+"
    }
  },
  "patterns": {
    "version_lookup": {
      "description": "Query version-registry.json to find recommended package versions for new projects",
      "usage": "Access packages.{language}.{package} or llm_models.{provider}.{model_type} for version recommendations",
      "use_when": "Access packages.{language}.{package} or llm_models.{provider}.{model_type} for version recommendations",
      "code_example": "# Implement version_lookup per version-registry patterns\n# See description and related documentation",
      "best_practices": [
        "Document the pattern usage and rationale in code comments",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "compatibility_checking": {
      "description": "Validate that package versions in projects match version-registry.json recommendations",
      "usage": "Compare project package.json/pom.xml/requirements.txt versions against registry to detect drift",
      "use_when": "Compare project package.json/pom.xml/requirements.txt versions against registry to detect drift",
      "code_example": "# Implement compatibility_checking per version-registry patterns\n# See description and related documentation",
      "best_practices": [
        "Document the pattern usage and rationale in code comments",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "model_selection": {
      "description": "Select LLM models based on use case (flagship for quality, fast for speed, coding for code generation)",
      "usage": "Reference llm_models.{provider}.{model_type} to choose appropriate model for agent or skill requirements",
      "use_when": "Reference llm_models.{provider}.{model_type} to choose appropriate model for agent or skill requirements",
      "code_example": "# Implement model_selection per version-registry patterns\n# See description and related documentation",
      "best_practices": [
        "Document the pattern usage and rationale in code comments",
        "Validate implementation against domain requirements before deployment"
      ]
    },
    "version_synchronization": {
      "description": "Keep version-registry.json synchronized with actual tested versions across Factory projects",
      "usage": "Update registry when upgrading packages in production projects. Use last_updated field to track currency",
      "use_when": "Update registry when upgrading packages in production projects. Use last_updated field to track currency",
      "code_example": "# Implement version_synchronization per version-registry patterns\n# See description and related documentation",
      "best_practices": [
        "Document the pattern usage and rationale in code comments",
        "Validate implementation against domain requirements before deployment"
      ]
    }
  },
  "best_practices": [
    "Use version-registry.json as single source of truth for recommended package versions across all Factory-generated projects",
    "Validate project dependencies against version-registry.json during blueprint generation to ensure compatibility",
    "Update version-registry.json when upgrading packages in production to keep recommendations current and tested",
    "Select LLM models based on task requirements: use flagship models for complex reasoning, fast models for simple tasks",
    "Document version selection rationale when deviating from registry recommendations to help future maintainers",
    "Run compatibility checks before major version upgrades to identify breaking changes and migration requirements",
    "Keep last_updated timestamp current to enable automated checks for stale version recommendations",
    "Use semantic versioning ranges (e.g., '1.8+') for packages with frequent updates, exact versions for stability-critical packages"
  ],
  "anti_patterns": [
    {
      "name": "Version Registry Staleness",
      "problem": "Not updating version-registry.json when upgrading packages leads to outdated recommendations and compatibility issues",
      "fix": "Update version-registry.json immediately after testing package upgrades. Use last_updated field to track currency"
    },
    {
      "name": "Version Drift",
      "problem": "Projects using different package versions than version-registry.json recommendations create maintenance burden and compatibility risks",
      "fix": "Align project dependencies with registry recommendations. Document deviations with rationale and migration plans"
    },
    {
      "name": "Model Misallocation",
      "problem": "Using expensive flagship models (gpt-5.2, claude-opus) for simple tasks wastes costs and slows responses",
      "fix": "Match model selection to task complexity: use fast models for simple tasks, flagship models only when needed"
    },
    {
      "name": "Breaking Change Ignorance",
      "problem": "Upgrading to major versions without checking compatibility breaks existing code and requires emergency fixes",
      "fix": "Review changelogs and test upgrades in staging before updating version-registry.json. Document breaking changes"
    },
    {
      "name": "Exact Version Lock-In",
      "problem": "Using exact versions (e.g., '1.2.9') everywhere prevents security patches and minor improvements",
      "fix": "Use semantic ranges (e.g., '1.2+') for non-critical packages, exact versions only for stability-critical dependencies"
    }
  ]
}
