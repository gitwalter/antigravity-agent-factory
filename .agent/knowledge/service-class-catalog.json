{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "service-class-catalog",
  "name": "Service Class Catalog",
  "title": "ABAP Service Class Catalog",
  "description": "Patterns and catalog for ABAP service classes following Clean ABAP principles",
  "version": "1.0.0",
  "category": "sap",
  "axiomAlignment": {
    "A1_verifiability": "Interface-based design and dependency injection enable testable, verifiable service behavior",
    "A2_user_primacy": "Service layers orchestrate user workflows and preserve business intent",
    "A3_transparency": "Explicit layer separation and interfaces make service responsibilities clear",
    "A4_non_harm": "Validation and exception hierarchy patterns ensure safe operations",
    "A5_consistency": "Unified Clean ABAP patterns across application, domain, and infrastructure layers"
  },
  "related_skills": [
    "rap-behavior-design",
    "cds-grounding",
    "sap-grounding"
  ],
  "related_knowledge": [
    "sap-cap-patterns.json",
    "sap-rap-patterns.json",
    "error-handling-patterns.json",
    "naming-conventions.json"
  ],
  "metadata": {
    "name": "Service Class Catalog",
    "description": "Patterns and catalog for ABAP service classes following Clean ABAP principles",
    "version": "1.0.0",
    "lastUpdated": "2026-01-30"
  },
  "serviceLayerPatterns": {
    "overview": {
      "description": "Service classes encapsulate business logic and coordinate operations",
      "principles": [
        "Single Responsibility - one service per domain",
        "Dependency Injection - inject dependencies via constructor",
        "Interface Segregation - define interfaces for testability",
        "Separation of Concerns - business logic separate from data access"
      ]
    },
    "layers": {
      "presentation": {
        "purpose": "Handle UI interaction, validation, formatting",
        "examples": [
          "Report classes",
          "Fiori handlers",
          "API controllers"
        ]
      },
      "application": {
        "purpose": "Orchestrate use cases, transaction management",
        "examples": [
          "ZCL_TRAVEL_APPLICATION_SERVICE",
          "ZCL_BOOKING_USE_CASE"
        ]
      },
      "domain": {
        "purpose": "Core business logic, domain rules",
        "examples": [
          "ZCL_TRAVEL_DOMAIN_SERVICE",
          "ZCL_PRICING_ENGINE"
        ]
      },
      "infrastructure": {
        "purpose": "Data access, external integrations",
        "examples": [
          "ZCL_TRAVEL_REPOSITORY",
          "ZCL_SAP_CONNECTOR"
        ]
      }
    }
  },
  "servicePatterns": {
    "crudService": {
      "description": "Basic CRUD operations for an entity",
      "interface": "ZIF_TRAVEL_SERVICE",
      "methods": [
        {
          "name": "get_by_id",
          "parameters": "travel_id",
          "returns": "travel_data"
        },
        {
          "name": "get_all",
          "parameters": "filter_criteria",
          "returns": "travel_list"
        },
        {
          "name": "create",
          "parameters": "travel_data",
          "returns": "travel_id"
        },
        {
          "name": "update",
          "parameters": "travel_id, travel_data",
          "returns": "void"
        },
        {
          "name": "delete",
          "parameters": "travel_id",
          "returns": "void"
        }
      ],
      "example": "CLASS zcl_travel_service DEFINITION PUBLIC FINAL CREATE PUBLIC.\n  PUBLIC SECTION.\n    INTERFACES zif_travel_service.\n    METHODS constructor IMPORTING repository TYPE REF TO zif_travel_repository.\n  PRIVATE SECTION.\n    DATA repository TYPE REF TO zif_travel_repository.\nENDCLASS."
    },
    "domainService": {
      "description": "Complex business logic that spans multiple entities",
      "methods": [
        {
          "name": "calculate_total_price",
          "parameters": "travel_id",
          "returns": "amount"
        },
        {
          "name": "apply_discount",
          "parameters": "travel_id, discount_percent",
          "returns": "void"
        },
        {
          "name": "validate_booking",
          "parameters": "booking_data",
          "returns": "validation_result"
        }
      ]
    },
    "orchestrationService": {
      "description": "Coordinate multiple services for a use case",
      "pattern": "Saga pattern for distributed transactions",
      "methods": [
        {
          "name": "book_travel",
          "description": "Orchestrate travel booking across services"
        },
        {
          "name": "cancel_travel",
          "description": "Coordinate cancellation with refund"
        }
      ]
    },
    "validationService": {
      "description": "Centralized validation logic",
      "methods": [
        {
          "name": "validate",
          "parameters": "entity_data",
          "returns": "validation_result"
        },
        {
          "name": "is_valid",
          "parameters": "entity_data",
          "returns": "boolean"
        }
      ]
    },
    "transformationService": {
      "description": "Data transformation and mapping",
      "methods": [
        {
          "name": "to_dto",
          "description": "Convert entity to DTO"
        },
        {
          "name": "from_dto",
          "description": "Convert DTO to entity"
        },
        {
          "name": "map_external",
          "description": "Map external format to internal"
        }
      ]
    }
  },
  "repositoryPatterns": {
    "description": "Data access abstraction",
    "interface": "ZIF_TRAVEL_REPOSITORY",
    "methods": [
      {
        "name": "find_by_id",
        "parameters": "id",
        "returns": "entity or initial"
      },
      {
        "name": "find_all",
        "parameters": "criteria",
        "returns": "entity_list"
      },
      {
        "name": "save",
        "parameters": "entity",
        "returns": "void"
      },
      {
        "name": "delete",
        "parameters": "id",
        "returns": "void"
      },
      {
        "name": "exists",
        "parameters": "id",
        "returns": "boolean"
      }
    ],
    "implementations": {
      "database": "Direct database access",
      "cds": "CDS view access",
      "bapi": "BAPI wrapper",
      "mock": "In-memory for testing"
    }
  },
  "factoryPatterns": {
    "simpleFactory": {
      "description": "Create objects based on type",
      "example": "METHODS create_travel IMPORTING type TYPE string RETURNING VALUE(result) TYPE REF TO zif_travel."
    },
    "abstractFactory": {
      "description": "Create families of related objects",
      "useCase": "Different implementations per system landscape"
    },
    "dependencyInjection": {
      "description": "Inject dependencies via constructor",
      "pattern": "METHODS constructor IMPORTING\n  repository TYPE REF TO zif_repository\n  validator TYPE REF TO zif_validator."
    }
  },
  "exceptionHandling": {
    "pattern": "Define exception class hierarchy per domain",
    "base": "ZCX_TRAVEL_ERROR (inherits from CX_STATIC_CHECK)",
    "specific": [
      "ZCX_TRAVEL_NOT_FOUND",
      "ZCX_TRAVEL_VALIDATION_FAILED",
      "ZCX_TRAVEL_AUTHORIZATION_FAILED"
    ],
    "usage": "RAISING zcx_travel_error in method signature"
  },
  "testability": {
    "interface": "Define interface for every service",
    "mockImplementation": "Create mock implementation for tests",
    "testDouble": "Use test double framework for complex mocking",
    "example": "CLASS zcl_travel_repository_mock DEFINITION FOR TESTING.\n  PUBLIC SECTION.\n    INTERFACES zif_travel_repository.\nENDCLASS."
  },
  "catalogExample": {
    "travelDomain": {
      "services": [
        {
          "name": "ZCL_TRAVEL_SERVICE",
          "interface": "ZIF_TRAVEL_SERVICE",
          "purpose": "Travel CRUD operations"
        },
        {
          "name": "ZCL_TRAVEL_PRICING_SERVICE",
          "interface": "ZIF_PRICING_SERVICE",
          "purpose": "Price calculation"
        },
        {
          "name": "ZCL_TRAVEL_VALIDATION_SERVICE",
          "interface": "ZIF_VALIDATION_SERVICE",
          "purpose": "Business validation"
        }
      ],
      "repositories": [
        {
          "name": "ZCL_TRAVEL_REPOSITORY",
          "interface": "ZIF_TRAVEL_REPOSITORY",
          "purpose": "Travel data access"
        },
        {
          "name": "ZCL_BOOKING_REPOSITORY",
          "interface": "ZIF_BOOKING_REPOSITORY",
          "purpose": "Booking data access"
        }
      ],
      "factories": [
        {
          "name": "ZCL_TRAVEL_FACTORY",
          "purpose": "Create travel service with dependencies"
        }
      ],
      "exceptions": [
        {
          "name": "ZCX_TRAVEL_ERROR",
          "purpose": "Base exception for travel domain"
        },
        {
          "name": "ZCX_TRAVEL_NOT_FOUND",
          "purpose": "Travel entity not found"
        },
        {
          "name": "ZCX_TRAVEL_VALIDATION",
          "purpose": "Validation failure"
        }
      ]
    }
  },
  "best_practices": [
    "One interface per service for testability",
    "Use dependency injection via constructor",
    "Keep services focused on single responsibility",
    "Separate business logic from data access",
    "Use value objects for complex parameters",
    "Define clear exception hierarchy",
    "Write unit tests for all services",
    "Document public interfaces thoroughly"
  ],
  "patterns": {
    "layeredArchitecture": {
      "description": "Four-layer service architecture pattern",
      "layers": [
        "Presentation: UI interaction, validation, formatting",
        "Application: Use case orchestration, transaction management",
        "Domain: Core business logic, domain rules",
        "Infrastructure: Data access, external integrations"
      ],
      "dependency": "Dependencies flow inward: Presentation \u2192 Application \u2192 Domain \u2190 Infrastructure",
      "use_when": "When implementing layeredArchitecture or when Four-layer service architecture pattern",
      "code_example": "DATA(lo_service) = /iwbep/cl_mgw_push_abs_data=>mgw_get_context( )->get_destination( )",
      "best_practices": [
        "One interface per service for testability",
        "Use dependency injection via constructor",
        "Keep services focused on single responsibility",
        "Separate business logic from data access"
      ]
    },
    "repositoryPattern": {
      "description": "Abstract data access behind repository interface",
      "interface": "Define ZIF_*_REPOSITORY interface with find_by_id, find_all, save, delete methods",
      "implementation": "Implement repository with database access, CDS views, or BAPI wrappers",
      "benefit": "Testable, swappable implementations, separation of concerns",
      "use_when": "When implementing repositoryPattern or when Abstract data access behind repository interface",
      "code_example": "DATA(lo_service) = /iwbep/cl_mgw_push_abs_data=>mgw_get_context( )->get_destination( )",
      "best_practices": [
        "One interface per service for testability",
        "Use dependency injection via constructor",
        "Keep services focused on single responsibility",
        "Separate business logic from data access"
      ]
    },
    "dependencyInjectionPattern": {
      "description": "Inject dependencies via constructor",
      "pattern": "METHODS constructor IMPORTING repository TYPE REF TO zif_repository",
      "benefit": "Testable code, loose coupling, easy to mock dependencies",
      "example": "Service receives repository in constructor, not creating it internally",
      "use_when": "When implementing dependencyInjectionPattern or when Inject dependencies via constructor",
      "code_example": "METHODS constructor IMPORTING repository TYPE REF TO zif_repository",
      "best_practices": [
        "One interface per service for testability",
        "Use dependency injection via constructor",
        "Keep services focused on single responsibility",
        "Separate business logic from data access"
      ]
    },
    "exceptionHierarchyPattern": {
      "description": "Domain-specific exception class hierarchy",
      "structure": "Base exception (ZCX_DOMAIN_ERROR) with specific exceptions (ZCX_DOMAIN_NOT_FOUND, ZCX_DOMAIN_VALIDATION)",
      "inheritance": "All domain exceptions inherit from CX_STATIC_CHECK",
      "usage": "RAISING zcx_domain_error in method signatures, catch specific exceptions",
      "use_when": "When implementing exceptionHierarchyPattern or when Domain-specific exception class hierarchy",
      "code_example": "DATA(lo_service) = /iwbep/cl_mgw_push_abs_data=>mgw_get_context( )->get_destination( )",
      "best_practices": [
        "One interface per service for testability",
        "Use dependency injection via constructor",
        "Keep services focused on single responsibility",
        "Separate business logic from data access"
      ]
    },
    "serviceInterfacePattern": {
      "description": "Every service class implements an interface",
      "pattern": "CLASS zcl_service DEFINITION PUBLIC FINAL CREATE PUBLIC. PUBLIC SECTION. INTERFACES zif_service.",
      "benefit": "Enables mocking for unit tests, allows multiple implementations, supports dependency inversion",
      "use_when": "When implementing serviceInterfacePattern or when Every service class implements an interface",
      "code_example": "CLASS zcl_service DEFINITION PUBLIC FINAL CREATE PUBLIC. PUBLIC SECTION. INTERFACES zif_service.",
      "best_practices": [
        "One interface per service for testability",
        "Use dependency injection via constructor",
        "Keep services focused on single responsibility",
        "Separate business logic from data access"
      ]
    },
    "valueObjectPattern": {
      "description": "Use value objects for complex parameters",
      "pattern": "Create structured types or classes for related data instead of many individual parameters",
      "example": "Use ls_travel_data structure instead of 10 individual parameters",
      "benefit": "Better readability, type safety, easier to extend",
      "use_when": "When implementing valueObjectPattern or when Use value objects for complex parameters",
      "code_example": "Create structured types or classes for related data instead of many individual parameters",
      "best_practices": [
        "One interface per service for testability",
        "Use dependency injection via constructor",
        "Keep services focused on single responsibility",
        "Separate business logic from data access"
      ]
    }
  },
  "anti_patterns": [
    {
      "name": "God service class with too many responsibilities",
      "problem": "Single service class handling CRUD, validation, pricing, reporting, and integration violates single responsibility principle and becomes unmaintainable",
      "solution": "Split into focused services: ZCL_TRAVEL_SERVICE (CRUD), ZCL_TRAVEL_VALIDATION_SERVICE (validation), ZCL_TRAVEL_PRICING_SERVICE (pricing)"
    },
    {
      "name": "Service creating its own dependencies",
      "problem": "Service class creating repository internally (CREATE OBJECT) makes testing impossible and creates tight coupling",
      "solution": "Inject dependencies via constructor: METHODS constructor IMPORTING repository TYPE REF TO zif_repository"
    },
    {
      "name": "No interface for service classes",
      "problem": "Service classes without interfaces cannot be mocked, making unit testing difficult or impossible",
      "solution": "Always define interface (ZIF_*_SERVICE) and implement it in service class for testability"
    },
    {
      "name": "Mixing business logic with data access",
      "problem": "Service class directly accessing database tables mixes business logic with data access, violating separation of concerns",
      "solution": "Extract data access to repository class (ZCL_*_REPOSITORY), service calls repository methods"
    },
    {
      "name": "Generic exception handling without specific exceptions",
      "problem": "Catching CX_ROOT or using generic error messages makes debugging difficult and error handling imprecise",
      "solution": "Define domain-specific exception hierarchy (ZCX_DOMAIN_ERROR with specific subclasses) and catch specific exceptions"
    }
  ]
}