{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "agent-coordination-patterns",
  "name": "Agent Coordination Patterns",
  "title": "Agent Coordination Patterns",
  "description": "Patterns for coordinating multiple AI agents in collaborative systems",
  "version": "1.0.0",
  "category": "agents",
  "axiomAlignment": {
    "A2_user_primacy": "Coordination patterns ensure user intent is fulfilled effectively",
    "A3_transparency": "Clear coordination makes multi-agent behavior predictable"
  },
  "coordination_patterns": {
    "peer_collaboration": {
      "description": "Agents work as equals, reviewing each other's output",
      "use_when": [
        "Tasks benefit from multiple perspectives",
        "Quality improvement through critique",
        "Creative problem-solving"
      ],
      "structure": {
        "communication": "broadcast",
        "decision": "consensus_or_voting",
        "conflict_resolution": "voting_or_mediator"
      },
      "implementation": {
        "message_format": {
          "from": "agent_id",
          "to": "all | specific_agent",
          "content": "message",
          "type": "proposal | critique | agreement | question"
        },
        "consensus_protocol": "Require agreement from majority before finalizing"
      },
      "example_use_cases": [
        "Code review with multiple reviewers",
        "Design brainstorming",
        "Research paper writing"
      ],
      "best_practices": [
        "Define clear roles even among peers",
        "Set iteration limits for consensus",
        "Include tie-breaking mechanism"
      ]
    },
    "hierarchical_command": {
      "description": "Supervisor agent coordinates worker agents",
      "use_when": [
        "Complex tasks requiring decomposition",
        "Clear authority structure needed",
        "Resource allocation decisions"
      ],
      "structure": {
        "communication": "top_down_directives",
        "decision": "supervisor_authority",
        "conflict_resolution": "escalation_to_supervisor"
      },
      "implementation": {
        "supervisor_responsibilities": [
          "Task decomposition",
          "Worker selection",
          "Progress monitoring",
          "Result aggregation"
        ],
        "worker_responsibilities": [
          "Execute assigned tasks",
          "Report status",
          "Request clarification when needed"
        ]
      },
      "example_use_cases": [
        "Large codebase refactoring",
        "Multi-file feature implementation",
        "Complex debugging"
      ],
      "best_practices": [
        "Keep supervisor focused on coordination, not execution",
        "Define clear handoff protocols",
        "Implement timeout handling for workers"
      ]
    },
    "pipeline_processing": {
      "description": "Sequential handoff between specialized agents",
      "use_when": [
        "Tasks have clear sequential stages",
        "Each stage requires different expertise",
        "Output of one stage is input to next"
      ],
      "structure": {
        "communication": "handoff_with_context",
        "decision": "stage_owner_authority",
        "conflict_resolution": "pipeline_coordinator"
      },
      "implementation": {
        "handoff_protocol": {
          "output": "Stage output",
          "context": "Relevant context for next stage",
          "status": "complete | needs_revision | blocked"
        },
        "stages_example": [
          "Extract",
          "Transform",
          "Validate",
          "Apply"
        ]
      },
      "example_use_cases": [
        "ETL pipelines",
        "Code generation with review",
        "Document processing"
      ],
      "best_practices": [
        "Define clear interfaces between stages",
        "Allow backward flow for revisions",
        "Include validation at each handoff"
      ]
    },
    "knowledge_mesh": {
      "description": "Agents share knowledge dynamically",
      "use_when": [
        "Research and exploration tasks",
        "Knowledge discovery",
        "Collaborative learning"
      ],
      "structure": {
        "communication": "shared_knowledge_base",
        "decision": "expertise_based",
        "conflict_resolution": "evidence_evaluation"
      },
      "implementation": {
        "knowledge_sharing": {
          "publish": "Agent publishes findings to shared store",
          "subscribe": "Agents subscribe to relevant topics",
          "query": "Agents query shared knowledge as needed"
        },
        "expertise_routing": "Route questions to agent with most relevant expertise"
      },
      "example_use_cases": [
        "Research literature review",
        "Codebase exploration",
        "Documentation generation"
      ],
      "best_practices": [
        "Curate shared knowledge to prevent noise",
        "Tag knowledge with confidence levels",
        "Implement knowledge decay for outdated info"
      ]
    },
    "consensus_reaching": {
      "description": "Agents must agree before proceeding",
      "use_when": [
        "High-stakes decisions",
        "Diverse perspectives needed",
        "Quality assurance"
      ],
      "structure": {
        "communication": "proposal_and_feedback",
        "decision": "unanimous_or_majority",
        "conflict_resolution": "deliberation_rounds"
      },
      "implementation": {
        "protocol": [
          "Agent proposes solution",
          "Other agents provide feedback",
          "Proposer revises based on feedback",
          "Vote on final proposal",
          "Accept if threshold met, else iterate"
        ],
        "voting_options": [
          "accept",
          "reject",
          "abstain"
        ]
      },
      "example_use_cases": [
        "Architecture decisions",
        "Security-critical changes",
        "Production deployments"
      ],
      "best_practices": [
        "Set maximum deliberation rounds",
        "Allow escalation to human if no consensus",
        "Document dissenting opinions"
      ]
    },
    "blackboard": {
      "description": "Shared workspace where agents contribute solutions",
      "use_when": [
        "Problem can be solved incrementally",
        "Multiple solution approaches possible",
        "Opportunistic contribution"
      ],
      "structure": {
        "communication": "read_write_shared_board",
        "decision": "best_contribution_wins",
        "conflict_resolution": "quality_based_selection"
      },
      "implementation": {
        "blackboard_structure": {
          "problem": "Current problem description",
          "partial_solutions": "List of contributions",
          "solution": "Current best solution",
          "metadata": "Quality scores, contributors"
        },
        "contribution_protocol": "Any agent can contribute; controller evaluates"
      },
      "example_use_cases": [
        "Complex debugging",
        "Creative problem solving",
        "Multi-approach optimization"
      ]
    }
  },
  "communication_protocols": {
    "message_types": {
      "request": "Ask another agent to do something",
      "inform": "Share information without expecting action",
      "propose": "Suggest a course of action for consideration",
      "accept": "Agree to a proposal",
      "reject": "Decline a proposal with reason",
      "query": "Ask for information",
      "confirm": "Verify understanding"
    },
    "message_structure": {
      "id": "Unique message identifier",
      "from": "Sender agent ID",
      "to": "Recipient agent ID or 'all'",
      "type": "Message type from types above",
      "content": "Message payload",
      "in_reply_to": "ID of message being responded to",
      "timestamp": "When message was sent"
    },
    "conversation_patterns": {
      "request_response": "Agent A requests -> Agent B responds",
      "negotiation": "Propose -> Counter-propose -> Accept/Reject",
      "broadcast": "Agent A informs all -> Others acknowledge",
      "subscription": "Agent A subscribes to topic -> Publisher agents notify"
    }
  },
  "conflict_resolution": {
    "authority_based": {
      "description": "Higher authority agent decides",
      "use_when": "Clear hierarchy exists",
      "implementation": "Escalate to supervisor or designated authority"
    },
    "voting_based": {
      "description": "Majority or consensus vote",
      "use_when": "Peer agents with equal authority",
      "implementation": "Collect votes, apply threshold"
    },
    "evidence_based": {
      "description": "Decision based on supporting evidence",
      "use_when": "Objective criteria available",
      "implementation": "Compare evidence quality and quantity"
    },
    "human_escalation": {
      "description": "Escalate to human for decision",
      "use_when": "Stakes too high for autonomous decision",
      "implementation": "Pause workflow, present options to human",
      "axiom_alignment": "A2 (User Primacy) - Defer to human for critical decisions"
    }
  },
  "state_management": {
    "shared_state": {
      "description": "All agents share common state",
      "implementation": "Central state store (e.g., LangGraph state)",
      "considerations": [
        "Concurrency control needed",
        "Clear ownership of state sections",
        "State versioning for debugging"
      ]
    },
    "message_passing": {
      "description": "Agents communicate via messages only",
      "implementation": "Message queue or event bus",
      "considerations": [
        "More decoupled",
        "Easier to test independently",
        "May need state reconstruction from messages"
      ]
    },
    "hybrid": {
      "description": "Shared state for coordination, messages for tasks",
      "implementation": "Combine approaches based on need",
      "considerations": [
        "Best of both worlds",
        "More complex implementation"
      ]
    }
  },
  "implementation_with_langgraph": {
    "multi_agent_graph": {
      "description": "Multiple agent nodes in single graph",
      "code_example": "graph = StateGraph(State)\ngraph.add_node('agent_a', agent_a_node)\ngraph.add_node('agent_b', agent_b_node)\ngraph.add_node('coordinator', coordinator_node)\n# Coordinator routes between agents"
    },
    "subgraph_composition": {
      "description": "Compose multiple agent graphs",
      "use_when": "Complex agents that need their own internal graphs",
      "code_example": "agent_a_graph = create_agent_a_graph()\nagent_b_graph = create_agent_b_graph()\n\ndef agent_a_node(state):\n    return agent_a_graph.invoke(state)\n\nmain_graph.add_node('agent_a', agent_a_node)"
    }
  },
  "best_practices": [
    "Define clear agent responsibilities with non-overlapping roles to prevent conflicts",
    "Establish explicit communication protocols with standardized message formats",
    "Implement timeout and retry logic with exponential backoff for resilience",
    "Log all inter-agent communication with correlation IDs for traceability",
    "Test agents independently before integration to catch issues early",
    "Use structured outputs for agent-to-agent communication to ensure consistency",
    "Implement graceful degradation when agent tools fail to maintain system stability",
    "Monitor agent resource usage and implement backpressure to prevent overload",
    "Design coordination patterns for idempotency to handle retries safely",
    "Use async communication for I/O-bound tasks to improve throughput"
  ],
  "patterns": {
    "peer_collaboration": {
      "description": "Agents work as equals, reviewing each other's output",
      "use_when": "Tasks benefit from multiple perspectives or quality improvement through critique"
    },
    "hierarchical_command": {
      "description": "Supervisor agent coordinates worker agents",
      "use_when": "Complex tasks requiring decomposition or clear authority structure"
    },
    "pipeline_processing": {
      "description": "Sequential handoff between specialized agents",
      "use_when": "Tasks have clear sequential stages with different expertise requirements"
    },
    "knowledge_mesh": {
      "description": "Agents share knowledge dynamically",
      "use_when": "Research and exploration tasks requiring collaborative learning"
    },
    "consensus_reaching": {
      "description": "Agents must agree before proceeding",
      "use_when": "High-stakes decisions or quality assurance requirements"
    },
    "blackboard": {
      "description": "Shared workspace where agents contribute solutions",
      "use_when": "Problem can be solved incrementally with multiple solution approaches"
    }
  },
  "anti_patterns": [
    {
      "name": "Unbounded agent loops",
      "problem": "Agents coordinate indefinitely without termination, consuming resources",
      "solution": "Set max_iterations and implement timeout handling with clear termination conditions"
    },
    {
      "name": "Circular delegation",
      "problem": "Agents delegate tasks to each other in circles, never completing work",
      "solution": "Track delegation depth, prevent cycles, and implement delegation limits"
    },
    {
      "name": "No error propagation",
      "problem": "Agent failures are silently ignored, leading to incorrect system state",
      "solution": "Implement error propagation mechanisms and failure notifications to coordinating agents"
    },
    {
      "name": "Tight coupling between agents",
      "problem": "Agents depend on internal implementation details, making changes difficult",
      "solution": "Use message-based communication with well-defined interfaces and contracts"
    },
    {
      "name": "No coordination observability",
      "problem": "Cannot debug or understand multi-agent interactions when issues occur",
      "solution": "Log all coordination events, use correlation IDs, and implement distributed tracing"
    }
  ]
}