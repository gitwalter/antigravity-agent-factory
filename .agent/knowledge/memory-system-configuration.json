{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "memory-system-configuration",
  "name": "Memory System Configuration",
  "title": "Memory System Configuration",
  "description": "Configuration for the inductive memory system that enables user-validated learning",
  "version": "1.0.0",
  "category": "agent-patterns",
  "axiomAlignment": {
    "A2_user_primacy": "All memory creation requires explicit user approval",
    "A3_transparency": "Memory source and confidence are always displayed",
    "A5_consistency": "Protected layers (L0-L2) cannot be modified",
    "A1_verifiability": "All patterns include verifiable examples and test approaches",
    "A4_non_harm": "Patterns include safety considerations and error handling"
  },
  "embedding": {
    "model": "all-MiniLM-L6-v2",
    "description": "Sentence-transformers model for local embeddings (no API required)",
    "dimension": 384,
    "cache_dir": "data/models"
  },
  "storage": {
    "vector_db": "chromadb",
    "persist_dir": "data/memory",
    "json_knowledge": "{directories.knowledge}/",
    "collections": [
      {
        "name": "semantic",
        "description": "User-approved long-term memories"
      },
      {
        "name": "episodic",
        "description": "Session-based observations"
      },
      {
        "name": "pending",
        "description": "Proposals awaiting user approval"
      },
      {
        "name": "rejected",
        "description": "Rejected proposals (to avoid re-proposing)"
      }
    ]
  },
  "protection": {
    "immutable_layers": [
      "L0",
      "L1",
      "L2"
    ],
    "protected_paths": [
      ".cursorrules",
      "{directories.patterns}/axioms/",
      "{directories.patterns}/principles/",
      "{directories.patterns}/enforcement/",
      "PURPOSE.md"
    ],
    "mutable_paths": [
      "{directories.knowledge}/*.json",
      "{directories.patterns}/stacks/",
      "{directories.blueprints}/",
      "{directories.templates}/",
      "data/"
    ]
  },
  "proposals": {
    "require_user_approval": true,
    "show_confidence": true,
    "show_source": true,
    "rejection_similarity_threshold": 0.9,
    "min_content_length": 10
  },
  "observation_types": {
    "user_correction": {
      "description": "User corrected the agent's behavior",
      "confidence": 0.95,
      "scope": "global"
    },
    "explicit_teaching": {
      "description": "User explicitly taught something",
      "confidence": 1.0,
      "scope": "global"
    },
    "successful_pattern": {
      "description": "A pattern that worked well",
      "confidence": 0.7,
      "scope": "project"
    },
    "error_resolution": {
      "description": "How an error was resolved",
      "confidence": 0.8,
      "scope": "global"
    },
    "preference": {
      "description": "User preference detected",
      "confidence": 0.85,
      "scope": "global"
    }
  },
  "phase": {
    "current": 1,
    "description": "Phase 1: Conservative (user-validated). Phase 2 requires explicit enablement.",
    "phase1": {
      "require_user_approval": true,
      "auto_apply": false
    },
    "phase2": {
      "enabled": false,
      "confidence_threshold": 0.95,
      "requires_validation": true,
      "validation_period_days": 14
    }
  },
  "first_run": {
    "message": "I don't have any memories yet. I'll learn from our interactions.",
    "create_directories": true,
    "download_model": true
  },
  "patterns": {
    "user_validated_learning_description": {
      "description": "All memory proposals require explicit user approval before storage",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# user_validated_learning_description pattern for memory-config\n# Implement based on description: All memory proposals require explicit user approva...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "user_validated_learning_implementation": {
      "description": "Store proposals in 'pending' collection, present to user with confidence scores and sources, move to 'semantic' collection on approval",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# user_validated_learning_implementation pattern for memory-config\n# Implement based on description: Store proposals in 'pending' collection, present t...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "confidence_based_proposals_description": {
      "description": "Use observation type confidence scores to prioritize proposals",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# confidence_based_proposals_description pattern for memory-config\n# Implement based on description: Use observation type confidence scores to prioriti...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "confidence_based_proposals_implementation": {
      "description": "Higher confidence observations (explicit_teaching=1.0, user_correction=0.95) are presented first, lower confidence (successful_pattern=0.7) require more context",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# confidence_based_proposals_implementation pattern for memory-config\n# Implement based on description: Higher confidence observations (explicit_teaching=...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "rejection_tracking_description": {
      "description": "Track rejected proposals to avoid re-proposing similar content",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# rejection_tracking_description pattern for memory-config\n# Implement based on description: Track rejected proposals to avoid re-proposing sim...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "rejection_tracking_implementation": {
      "description": "Store rejected proposals in 'rejected' collection, check similarity threshold (0.9) before proposing new memories",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# rejection_tracking_implementation pattern for memory-config\n# Implement based on description: Store rejected proposals in 'rejected' collection,...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "protected_layer_enforcement_description": {
      "description": "Prevent modification of immutable layers (L0-L2) containing core axioms and principles",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# protected_layer_enforcement_description pattern for memory-config\n# Implement based on description: Prevent modification of immutable layers (L0-L2) c...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "protected_layer_enforcement_implementation": {
      "description": "Check protected_paths before any write operations, reject modifications to immutable layers",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# protected_layer_enforcement_implementation pattern for memory-config\n# Implement based on description: Check protected_paths before any write operations,...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "phase_gated_learning_description": {
      "description": "Phase 1 requires user approval, Phase 2 enables auto-apply for high-confidence memories",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# phase_gated_learning_description pattern for memory-config\n# Implement based on description: Phase 1 requires user approval, Phase 2 enables au...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    },
    "phase_gated_learning_implementation": {
      "description": "Phase 1: require_user_approval=true, auto_apply=false. Phase 2: enabled only after explicit enablement, confidence_threshold=0.95",
      "use_when": "Apply when implementing this pattern in your domain context",
      "code_example": "# phase_gated_learning_implementation pattern for memory-config\n# Implement based on description: Phase 1: require_user_approval=true, auto_apply=fa...",
      "best_practices": [
        "Validate implementation against domain requirements",
        "Document the pattern usage and rationale in code"
      ]
    }
  },
  "best_practices": [
    "Always require user approval for memory creation in Phase 1 to ensure user primacy and prevent unwanted memory storage",
    "Display confidence scores and source context when presenting memory proposals so users can make informed decisions",
    "Use similarity threshold (0.9) to prevent re-proposing rejected memories, reducing user friction and improving proposal quality",
    "Enforce protected layer immutability by checking protected_paths before write operations to maintain system integrity",
    "Namespace embedding cache by model version to prevent cross-version contamination and ensure consistent semantic search",
    "Store episodic observations separately from semantic memories to enable temporal analysis and pattern detection",
    "Implement minimum content length validation (10 chars) to filter out noise and ensure meaningful memory proposals",
    "Use local embedding models (all-MiniLM-L6-v2) for privacy-sensitive applications, avoiding API calls for embedding generation"
  ],
  "anti_patterns": [
    {
      "name": "Auto-creating memories without approval",
      "problem": "Violates user primacy axiom, stores unwanted information, reduces user trust and control",
      "fix": "Always require explicit user approval in Phase 1, use require_user_approval=true, present proposals with context before storage"
    },
    {
      "name": "Not showing memory sources",
      "problem": "Users cannot verify memory accuracy or understand context, violating transparency axiom",
      "fix": "Always display source context and confidence scores (show_source=true, show_confidence=true) when presenting proposals"
    },
    {
      "name": "Modifying protected layers",
      "problem": "Corrupts core system axioms and principles, breaks system consistency and trust",
      "fix": "Enforce immutable_layers protection, check protected_paths before writes, reject modifications to L0-L2 layers"
    },
    {
      "name": "Re-proposing rejected memories",
      "problem": "Frustrates users with repeated proposals, wastes system resources, reduces proposal quality",
      "fix": "Store rejected proposals in 'rejected' collection, check similarity threshold (0.9) before proposing, avoid re-proposing similar content"
    },
    {
      "name": "Enabling Phase 2 without validation",
      "problem": "Auto-applies memories without sufficient confidence validation, risks storing incorrect information",
      "fix": "Require explicit enablement, set high confidence_threshold (0.95), implement validation_period_days (14) before full activation"
    }
  ],
  "related_skills": [
    "none"
  ],
  "related_knowledge": [
    "best-practices.json"
  ]
}
