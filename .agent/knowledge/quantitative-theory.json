{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "id": "quantitative-theory",
    "name": "Quantitative Theory & Math Library",
    "title": "Quantitative Theory & Math Library",
    "description": "Standardized mathematical formulas and statistical techniques for trading agents",
    "version": "1.0.0",
    "category": "trading",
    "axiomAlignment": {
        "A1_verifiability": "Formulas must be statistically sound and verifiable",
        "A2_user_primacy": "User determines metric thresholds for strategy validation",
        "A3_transparency": "All math must be explicitly documented and non-opaque",
        "A4_non_harm": "Accuracy in risk calculation prevents catastrophic loss",
        "A5_consistency": "Uniform math library across all trading agents"
    },
    "patterns": {
        "return_calculation": {
            "description": "Standard methods for calculating asset returns",
            "use_when": "Transforming price series to returns for statistical modeling",
            "code_example": "returns = np.log(prices / prices.shift(1))",
            "best_practices": [
                "Use log returns for time-series additivity",
                "Handle zero-volume periods with forward-fill"
            ]
        },
        "risk_evaluation": {
            "description": "Standard risk-adjusted performance metrics",
            "use_when": "Comparing strategies with different volatility profiles",
            "code_example": "sharpe = (returns.mean() - risk_free) / returns.std()",
            "best_practices": [
                "Always specify the risk-free rate used",
                "Annualize metrics for cross-asset comparison"
            ]
        }
    },
    "math_library": {
        "returns": {
            "log_returns": "ln(Price_t / Price_{t-1})",
            "simple_returns": "(Price_t - Price_{t-1}) / Price_{t-1}",
            "note": "Log returns are preferred for statistical modeling due to additivity."
        },
        "risk_metrics": {
            "sharpe_ratio": "(Mean_Return - Risk_Free_Rate) / Std_Dev_Return",
            "sortino_ratio": "(Mean_Return - Target_Return) / Downside_Deviation",
            "maximum_drawdown": "min((Peak - Trough) / Peak)"
        },
        "normalization": {
            "z_score": "(Value - Mean) / Std_Dev",
            "min_max": "(Value - Min) / (Max - Min)"
        },
        "volatility": {
            "atr": "Average True Range (Standard measure of volatility)",
            "annualized_vol": "Std_Dev_Returns * sqrt(252)"
        },
        "macro_metrics": {
            "real_yield": "Nominal Yield - Expected Inflation",
            "yield_spread": "10Y_Treasury_Yield - 2Y_Treasury_Yield"
        },
        "microstructure_metrics": {
            "amihud_illiquidity": "|Return| / (Price * Volume)",
            "order_flow_imbalance": "(Bid_Qty - Ask_Qty) / (Bid_Qty + Ask_Qty)"
        }
    },
    "best_practices": [
        "Validate math implementations with unit tests",
        "Document assumptions (e.g. 252 trading days per year)",
        "Use vectorized operations for performance"
    ],
    "anti_patterns": [
        {
            "name": "Look-Ahead Return Calculation",
            "problem": "Using current price to calculate future returns",
            "fix": "Ensure indexing aligns with available data at time T"
        }
    ],
    "related_skills": [
        "trading-algorithmically",
        "trading-intelligence"
    ],
    "related_knowledge": [
        "trading-intelligence-patterns.json"
    ]
}
