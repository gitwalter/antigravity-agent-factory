{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "React Patterns",
  "description": "Modern React patterns, hooks, and best practices for building scalable applications",
  "version": "1.0.0",
  "sources": [
    "https://react.dev/",
    "https://react.dev/reference/react"
  ],
  "axiomAlignment": {
    "A1_verifiability": "Patterns include testing strategies",
    "A3_transparency": "Component design emphasizes predictability"
  },
  "core_patterns": {
    "component_composition": {
      "description": "Build complex UIs from simple, reusable components",
      "patterns": {
        "container_presentational": {
          "description": "Separate data fetching from rendering",
          "code_example": "// Container (handles data)\nfunction UserListContainer() {\n  const [users, setUsers] = useState([]);\n  useEffect(() => {\n    fetchUsers().then(setUsers);\n  }, []);\n  return <UserList users={users} />;\n}\n\n// Presentational (pure rendering)\nfunction UserList({ users }) {\n  return (\n    <ul>\n      {users.map(user => <UserItem key={user.id} user={user} />)}\n    </ul>\n  );\n}"
        },
        "compound_components": {
          "description": "Components that work together implicitly",
          "code_example": "const Tabs = ({ children, defaultTab }) => {\n  const [activeTab, setActiveTab] = useState(defaultTab);\n  return (\n    <TabsContext.Provider value={{ activeTab, setActiveTab }}>\n      {children}\n    </TabsContext.Provider>\n  );\n};\n\nconst TabList = ({ children }) => <div role=\"tablist\">{children}</div>;\nconst Tab = ({ id, children }) => {\n  const { activeTab, setActiveTab } = useContext(TabsContext);\n  return (\n    <button\n      role=\"tab\"\n      aria-selected={activeTab === id}\n      onClick={() => setActiveTab(id)}\n    >\n      {children}\n    </button>\n  );\n};\n\n// Usage\n<Tabs defaultTab=\"tab1\">\n  <TabList>\n    <Tab id=\"tab1\">Tab 1</Tab>\n    <Tab id=\"tab2\">Tab 2</Tab>\n  </TabList>\n  <TabPanel id=\"tab1\">Content 1</TabPanel>\n  <TabPanel id=\"tab2\">Content 2</TabPanel>\n</Tabs>"
        },
        "render_props": {
          "description": "Share code via prop that is a function",
          "code_example": "function MouseTracker({ render }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  const handleMouseMove = (e) => {\n    setPosition({ x: e.clientX, y: e.clientY });\n  };\n  \n  return (\n    <div onMouseMove={handleMouseMove}>\n      {render(position)}\n    </div>\n  );\n}\n\n// Usage\n<MouseTracker render={({ x, y }) => (\n  <p>Mouse position: {x}, {y}</p>\n)} />"
        }
      }
    },
    "hooks_patterns": {
      "useState": {
        "description": "Add state to functional components",
        "patterns": {
          "lazy_initialization": {
            "code_example": "// Expensive computation only runs once\nconst [state, setState] = useState(() => computeExpensiveValue());"
          },
          "functional_update": {
            "code_example": "// When new state depends on previous\nsetCount(prev => prev + 1);"
          }
        }
      },
      "useEffect": {
        "description": "Handle side effects in components",
        "patterns": {
          "cleanup": {
            "code_example": "useEffect(() => {\n  const subscription = subscribe();\n  return () => subscription.unsubscribe();\n}, []);"
          },
          "dependency_array": {
            "empty": "Run once on mount",
            "with_deps": "Run when dependencies change",
            "no_array": "Run on every render (usually wrong)"
          }
        }
      },
      "useCallback": {
        "description": "Memoize callbacks to prevent unnecessary re-renders",
        "code_example": "const handleClick = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);"
      },
      "useMemo": {
        "description": "Memoize expensive computations",
        "code_example": "const sortedList = useMemo(() => {\n  return [...list].sort((a, b) => a.name.localeCompare(b.name));\n}, [list]);"
      },
      "useReducer": {
        "description": "Complex state logic with predictable updates",
        "code_example": "const initialState = { count: 0, step: 1 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { ...state, count: state.count + state.step };\n    case 'setStep':\n      return { ...state, step: action.payload };\n    default:\n      throw new Error(`Unknown action: ${action.type}`);\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      <span>{state.count}</span>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n    </>\n  );\n}"
      },
      "useRef": {
        "description": "Persist values without causing re-renders",
        "use_cases": [
          "DOM element references",
          "Storing previous values",
          "Instance variables"
        ]
      }
    },
    "custom_hooks": {
      "description": "Extract reusable stateful logic",
      "examples": {
        "useLocalStorage": {
          "code_example": "function useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      return initialValue;\n    }\n  });\n\n  const setValue = (value) => {\n    const valueToStore = value instanceof Function\n      ? value(storedValue)\n      : value;\n    setStoredValue(valueToStore);\n    window.localStorage.setItem(key, JSON.stringify(valueToStore));\n  };\n\n  return [storedValue, setValue];\n}"
        },
        "useFetch": {
          "code_example": "function useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const controller = new AbortController();\n    \n    async function fetchData() {\n      try {\n        const response = await fetch(url, { signal: controller.signal });\n        const json = await response.json();\n        setData(json);\n      } catch (err) {\n        if (err.name !== 'AbortError') {\n          setError(err);\n        }\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    fetchData();\n    return () => controller.abort();\n  }, [url]);\n\n  return { data, loading, error };\n}"
        },
        "useDebounce": {
          "code_example": "function useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedValue(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debouncedValue;\n}"
        }
      }
    }
  },
  "state_management": {
    "context_api": {
      "description": "Share state without prop drilling",
      "code_example": "const ThemeContext = createContext('light');\n\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  return (\n    <ThemeContext.Provider value={{ theme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}",
      "best_practices": [
        "Split contexts by update frequency",
        "Use separate contexts for state and dispatch",
        "Create custom hooks for consuming context"
      ]
    },
    "external_state": {
      "libraries": {
        "zustand": "Simple, hook-based state management",
        "jotai": "Atomic state management",
        "redux_toolkit": "Feature-rich, scalable state management",
        "tanstack_query": "Server state management and caching"
      }
    }
  },
  "performance_patterns": {
    "memo": {
      "description": "Prevent unnecessary re-renders",
      "code_example": "const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {\n  // Only re-renders if data changes\n  return <div>{processData(data)}</div>;\n});"
    },
    "virtualization": {
      "description": "Render only visible items in long lists",
      "libraries": ["@tanstack/react-virtual", "react-window"]
    },
    "code_splitting": {
      "description": "Load components on demand",
      "code_example": "const HeavyComponent = lazy(() => import('./HeavyComponent'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<Loading />}>\n      <HeavyComponent />\n    </Suspense>\n  );\n}"
    }
  },
  "error_handling": {
    "error_boundaries": {
      "description": "Catch and handle render errors",
      "code_example": "class ErrorBoundary extends Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    logError(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <FallbackUI />;\n    }\n    return this.props.children;\n  }\n}"
    }
  },
  "testing_patterns": {
    "testing_library": {
      "description": "Test components as users would interact",
      "code_example": "import { render, screen, fireEvent } from '@testing-library/react';\n\ntest('increments counter', () => {\n  render(<Counter />);\n  \n  const button = screen.getByRole('button', { name: /increment/i });\n  fireEvent.click(button);\n  \n  expect(screen.getByText(/count: 1/i)).toBeInTheDocument();\n});"
    },
    "best_practices": [
      "Query by role, text, or label over test IDs",
      "Test behavior, not implementation",
      "Use userEvent over fireEvent for realistic interactions"
    ]
  },
  "best_practices": [
    "Lift state up only as needed",
    "Keep components small and focused",
    "Use TypeScript for type safety",
    "Prefer composition over inheritance",
    "Memoize expensive computations",
    "Handle loading and error states",
    "Use semantic HTML for accessibility",
    "Test user interactions, not implementation"
  ],
  "anti_patterns": {
    "prop_drilling": {
      "problem": "Passing props through many levels",
      "solution": "Use Context or state management library"
    },
    "useEffect_for_derived_state": {
      "problem": "Using effect to sync derived data",
      "solution": "Calculate during render or use useMemo"
    },
    "inline_objects_in_deps": {
      "problem": "New object reference causes infinite loops",
      "solution": "Define objects outside component or memoize"
    }
  }
}
