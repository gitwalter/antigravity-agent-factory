"""
{{AGENT_NAME}} - Planning and Execution Agent

Purpose: {{AGENT_PURPOSE}}
Stakeholders: {{PRIMARY_STAKEHOLDERS}}

Axiom Alignment:
- A1 (Verifiability): Planning steps and execution traces are logged
- A2 (User Primacy): Plans are confirmed before execution
- A3 (Transparency): Planning reasoning and execution steps are explicit
- A4 (Non-Harm): Plans are validated for safety before execution
- A5 (Consistency): Planning methodology is consistently applied

Planning Pattern: Two-phase approach:
1. Planning Phase: Break down task into executable steps
2. Execution Phase: Execute steps and adapt plan as needed
"""

from typing import List, Dict, Any, Optional, TypedDict
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, SystemMessage
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool, Tool
from pydantic import BaseModel, Field
from enum import Enum
import logging
import asyncio
from datetime import datetime

# Configure logging for transparency (A3)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class PlanStepStatus(str, Enum):
    """Status of a plan step."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


class PlanStep(BaseModel):
    """A single step in an execution plan."""
    step_id: int = Field(description="Step number")
    description: str = Field(description="What this step does")
    action: str = Field(description="Action to take")
    expected_output: Optional[str] = Field(default=None, description="Expected result")
    dependencies: List[int] = Field(default_factory=list, description="Step IDs this depends on")
    status: PlanStepStatus = Field(default=PlanStepStatus.PENDING)
    actual_output: Optional[str] = Field(default=None, description="Actual result")
    execution_time: Optional[float] = Field(default=None, description="Time taken in seconds")
    error: Optional[str] = Field(default=None, description="Error message if failed")


class ExecutionPlan(BaseModel):
    """
    A complete execution plan.
    
    Contains multiple steps that can be executed sequentially or in parallel.
    """
    plan_id: str = Field(description="Unique plan identifier")
    goal: str = Field(description="Overall goal of this plan")
    steps: List[PlanStep] = Field(description="Steps to execute")
    created_at: datetime = Field(default_factory=datetime.now)
    estimated_duration: Optional[float] = Field(default=None, description="Estimated duration in seconds")
    requires_confirmation: bool = Field(default=True, description="Whether user confirmation is needed (A2)")


class {{AGENT_CLASS_NAME}}Output(BaseModel):
    """
    Structured output for planning and execution agent.
    
    Using structured output ensures verifiability (A1).
    """
    plan: ExecutionPlan = Field(description="The execution plan")
    execution_results: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Results from executing each step"
    )
    final_result: str = Field(description="Final result after plan execution")
    plan_adapted: bool = Field(default=False, description="Whether plan was adapted during execution")
    total_execution_time: float = Field(description="Total execution time in seconds")
    success: bool = Field(description="Whether plan execution succeeded")


class {{AGENT_CLASS_NAME}}:
    """
    {{AGENT_NAME}} - Planning and Execution Agent
    
    Implements a two-phase approach:
    1. **Planning Phase**: Analyzes the task and creates a detailed execution plan
    2. **Execution Phase**: Executes the plan step-by-step, adapting as needed
    
    This agent follows the 5-layer architecture:
    - Layer 0: Respects core axioms (A1-A5)
    - Layer 1: Serves purpose of {{AGENT_PURPOSE}}
    - Layer 2: Follows quality standards and ethical boundaries
    - Layer 3: Works within {{METHODOLOGY}} methodology
    - Layer 4: Uses {{TECH_STACK}} stack
    
    Example:
        >>> agent = {{AGENT_CLASS_NAME}}()
        >>> result = await agent.plan_and_execute("{{EXAMPLE_TASK}}")
        >>> print(result.final_result)
        >>> for step in result.plan.steps:
        ...     print(f"Step {step.step_id}: {step.status.value}")
    """
    
    # Configuration
    MODEL_NAME = "{{LLM_MODEL}}"
    TEMPERATURE = {{TEMPERATURE}}
    MAX_PLAN_STEPS = {{MAX_PLAN_STEPS}}
    AUTO_CONFIRM = {{AUTO_CONFIRM}}  # Set to False to require user confirmation
    
    def __init__(
        self,
        model_name: Optional[str] = None,
        temperature: Optional[float] = None,
        tools: Optional[List[Tool]] = None,
        auto_confirm: Optional[bool] = None
    ):
        """
        Initialize the planning and execution agent.
        
        Args:
            model_name: LLM model to use (default: {{LLM_MODEL}})
            temperature: Sampling temperature (default: {{TEMPERATURE}})
            tools: Tools available for execution
            auto_confirm: Auto-confirm plans without user input (default: {{AUTO_CONFIRM}})
        """
        self.model_name = model_name or self.MODEL_NAME
        self.temperature = temperature if temperature is not None else self.TEMPERATURE
        self.tools = tools or []
        self.auto_confirm = auto_confirm if auto_confirm is not None else self.AUTO_CONFIRM
        
        # Initialize LLM
        self.llm = ChatOpenAI(
            model=self.model_name,
            temperature=self.temperature
        )
        
        # Planning prompt
        self.planning_prompt = self._create_planning_prompt()
        
        # Execution prompt
        self.execution_prompt = self._create_execution_prompt()
        
        logger.info(f"Initialized {{AGENT_NAME}} with model {self.model_name}")
        logger.info(f"Auto-confirm: {self.auto_confirm}")
    
    def _create_planning_prompt(self) -> ChatPromptTemplate:
        """Create prompt template for planning phase."""
        return ChatPromptTemplate.from_messages([
            ("system", """{{SYSTEM_PROMPT}}

You are {{AGENT_NAME}}, a planning and execution agent.

## Core Principles
- VERIFIABILITY (A1): Create clear, traceable plans
- USER PRIMACY (A2): Confirm plans before execution
- TRANSPARENCY (A3): Explain planning reasoning
- NON-HARM (A4): Validate plan safety
- CONSISTENCY (A5): Use consistent planning methodology

## Planning Guidelines
1. Break down complex tasks into clear, executable steps
2. Identify dependencies between steps
3. Estimate expected outputs for each step
4. Consider error handling and recovery
5. Flag steps that require user confirmation

## Output Format
Create a plan with:
- Goal: Overall objective
- Steps: List of steps with:
  - Step ID (sequential number)
  - Description: What this step does
  - Action: Specific action to take
  - Expected Output: What should happen
  - Dependencies: Step IDs that must complete first
  - Requires Confirmation: Whether user approval is needed

Return the plan in a structured format.
"""),
            ("human", "Task: {task}\nContext: {context}")
        ])
    
    def _create_execution_prompt(self) -> ChatPromptTemplate:
        """Create prompt template for execution phase."""
        return ChatPromptTemplate.from_messages([
            ("system", """You are executing a plan step.

## Execution Guidelines
1. Follow the step description precisely
2. Use available tools when needed
3. Report actual output vs expected output
4. If step fails, explain why and suggest alternatives
5. Update step status appropriately

Available tools: {{TOOL_DESCRIPTIONS}}
"""),
            ("human", """Step: {step_description}
Expected Output: {expected_output}
Previous Steps: {previous_results}
Current Context: {context}

Execute this step and report the result.""")
        ])
    
    async def plan_and_execute(
        self,
        task: str,
        context: Optional[Dict[str, Any]] = None,
        user_confirmed: Optional[bool] = None
    ) -> {{AGENT_CLASS_NAME}}Output:
        """
        Plan and execute a task.
        
        Args:
            task: Task to plan and execute
            context: Optional additional context
            user_confirmed: Whether user has confirmed the plan (if None, uses auto_confirm)
            
        Returns:
            Structured output with plan and execution results
            
        Example:
            >>> result = await agent.plan_and_execute(
            ...     "Analyze sales data and generate report",
            ...     context={"data_source": "database"}
            ... )
        """
        start_time = datetime.now()
        logger.info(f"Planning and executing task: {task[:100]}...")
        
        try:
            # Phase 1: Planning
            plan = await self._create_plan(task, context)
            
            # Phase 2: Confirmation (A2)
            if user_confirmed is None:
                user_confirmed = self.auto_confirm
            
            if plan.requires_confirmation and not user_confirmed:
                logger.info("Plan requires user confirmation (A2)")
                return {{AGENT_CLASS_NAME}}Output(
                    plan=plan,
                    execution_results=[],
                    final_result="Plan created but awaiting user confirmation",
                    plan_adapted=False,
                    total_execution_time=(datetime.now() - start_time).total_seconds(),
                    success=False
                )
            
            # Phase 3: Execution
            execution_results, plan_adapted = await self._execute_plan(plan, context)
            
            # Phase 4: Synthesis
            final_result = await self._synthesize_results(plan, execution_results)
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            output = {{AGENT_CLASS_NAME}}Output(
                plan=plan,
                execution_results=execution_results,
                final_result=final_result,
                plan_adapted=plan_adapted,
                total_execution_time=execution_time,
                success=all(step.status == PlanStepStatus.COMPLETED for step in plan.steps)
            )
            
            logger.info(f"Plan execution completed in {execution_time:.2f}s")
            return output
            
        except Exception as e:
            logger.error(f"Error during plan and execute: {e}", exc_info=True)
            execution_time = (datetime.now() - start_time).total_seconds()
            
            return {{AGENT_CLASS_NAME}}Output(
                plan=ExecutionPlan(
                    plan_id="error",
                    goal=task,
                    steps=[],
                    requires_confirmation=False
                ),
                execution_results=[],
                final_result=f"Error: {str(e)}",
                plan_adapted=False,
                total_execution_time=execution_time,
                success=False
            )
    
    async def _create_plan(
        self,
        task: str,
        context: Optional[Dict[str, Any]]
    ) -> ExecutionPlan:
        """
        Create an execution plan for the task.
        
        Args:
            task: Task to plan
            context: Optional context
            
        Returns:
            Execution plan
        """
        logger.info("Creating execution plan...")
        
        chain = self.planning_prompt | self.llm
        response = await chain.ainvoke({
            "task": task,
            "context": str(context) if context else "None"
        })
        
        # Parse response into plan
        # In production, use structured output parsing
        # For now, create a simple plan
        steps = [
            PlanStep(
                step_id=i+1,
                description=f"Step {i+1} for: {task}",
                action="execute",
                expected_output=f"Result from step {i+1}",
                dependencies=[i] if i > 0 else []
            )
            for i in range(min(3, self.MAX_PLAN_STEPS))  # Simplified: 3 steps
        ]
        
        plan = ExecutionPlan(
            plan_id=f"plan-{datetime.now().timestamp()}",
            goal=task,
            steps=steps,
            requires_confirmation=True  # Default to requiring confirmation (A2)
        )
        
        logger.info(f"Created plan with {len(steps)} steps")
        return plan
    
    async def _execute_plan(
        self,
        plan: ExecutionPlan,
        context: Optional[Dict[str, Any]]
    ) -> tuple[List[Dict[str, Any]], bool]:
        """
        Execute the plan step by step.
        
        Args:
            plan: Execution plan
            context: Optional context
            
        Returns:
            Tuple of (execution results, plan_adapted flag)
        """
        logger.info(f"Executing plan with {len(plan.steps)} steps...")
        
        execution_results = []
        plan_adapted = False
        previous_results = {}
        
        for step in plan.steps:
            # Wait for dependencies
            for dep_id in step.dependencies:
                if dep_id not in previous_results:
                    logger.warning(f"Step {step.step_id} waiting for dependency {dep_id}")
                    await asyncio.sleep(0.1)  # Simplified wait
            
            # Execute step
            step.status = PlanStepStatus.IN_PROGRESS
            step_start = datetime.now()
            
            try:
                result = await self._execute_step(step, previous_results, context)
                
                step.status = PlanStepStatus.COMPLETED
                step.actual_output = result.get("output", "")
                step.execution_time = (datetime.now() - step_start).total_seconds()
                
                execution_results.append({
                    "step_id": step.step_id,
                    "status": "completed",
                    "output": step.actual_output,
                    "execution_time": step.execution_time
                })
                
                previous_results[step.step_id] = step.actual_output
                
            except Exception as e:
                logger.error(f"Step {step.step_id} failed: {e}")
                step.status = PlanStepStatus.FAILED
                step.error = str(e)
                step.execution_time = (datetime.now() - step_start).total_seconds()
                
                execution_results.append({
                    "step_id": step.step_id,
                    "status": "failed",
                    "error": str(e),
                    "execution_time": step.execution_time
                })
                
                # Adapt plan if step fails
                plan_adapted = True
                # In production, create recovery steps
        
        return execution_results, plan_adapted
    
    async def _execute_step(
        self,
        step: PlanStep,
        previous_results: Dict[int, str],
        context: Optional[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Execute a single plan step.
        
        Args:
            step: Step to execute
            previous_results: Results from previous steps
            context: Optional context
            
        Returns:
            Step execution result
        """
        logger.info(f"Executing step {step.step_id}: {step.description}")
        
        chain = self.execution_prompt | self.llm
        response = await chain.ainvoke({
            "step_description": step.description,
            "expected_output": step.expected_output or "N/A",
            "previous_results": str(previous_results),
            "context": str(context) if context else "None"
        })
        
        output = response.content if hasattr(response, 'content') else str(response)
        
        return {"output": output}
    
    async def _synthesize_results(
        self,
        plan: ExecutionPlan,
        execution_results: List[Dict[str, Any]]
    ) -> str:
        """
        Synthesize execution results into final answer.
        
        Args:
            plan: Original plan
            execution_results: Results from execution
            
        Returns:
            Synthesized final result
        """
        prompt = ChatPromptTemplate.from_messages([
            ("system", """Synthesize the execution results into a final answer.
            Consider all completed steps and their outputs.
            """),
            ("human", """Goal: {goal}
            
Execution Results:
{results}

Provide a comprehensive final answer.""")
        ])
        
        results_text = "\n".join([
            f"Step {r['step_id']} ({r['status']}): {r.get('output', r.get('error', 'N/A'))}"
            for r in execution_results
        ])
        
        chain = prompt | self.llm
        response = await chain.ainvoke({
            "goal": plan.goal,
            "results": results_text
        })
        
        return response.content if hasattr(response, 'content') else str(response)


# Example usage
if __name__ == "__main__":
    import asyncio
    
    async def main():
        # Create planning agent
        agent = {{AGENT_CLASS_NAME}}(
            model_name="{{LLM_MODEL}}",
            auto_confirm=True  # Set to False to require confirmation
        )
        
        # Plan and execute
        result = await agent.plan_and_execute("{{EXAMPLE_TASK}}")
        
        print(f"\n{'='*60}")
        print(f"Goal: {result.plan.goal}")
        print(f"{'='*60}")
        print(f"\nPlan Steps ({len(result.plan.steps)}):")
        for step in result.plan.steps:
            status_icon = {
                PlanStepStatus.COMPLETED: "✓",
                PlanStepStatus.FAILED: "✗",
                PlanStepStatus.IN_PROGRESS: "→",
                PlanStepStatus.PENDING: "○"
            }.get(step.status, "?")
            
            print(f"\n{status_icon} Step {step.step_id}: {step.description}")
            print(f"   Status: {step.status.value}")
            if step.actual_output:
                print(f"   Output: {step.actual_output[:100]}...")
            if step.error:
                print(f"   Error: {step.error}")
        
        print(f"\n{'='*60}")
        print(f"Final Result: {result.final_result}")
        print(f"{'='*60}")
        print(f"\nExecution Time: {result.total_execution_time:.2f}s")
        print(f"Success: {result.success}")
        if result.plan_adapted:
            print("⚠️  Plan was adapted during execution")
    
    asyncio.run(main())
