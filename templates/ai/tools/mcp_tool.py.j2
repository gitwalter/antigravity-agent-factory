"""
{{ tool_name | default('MCP Tool') }} - Model Context Protocol Tool Integration

Purpose: {{ tool_purpose | default('Integrate MCP servers as LangChain tools') }}
Author: {{ author | default('Cursor Agent Factory') }}
Date: {{ date | default('2026-02-08') }}

Axiom Alignment:
- A1 (Verifiability): MCP tool calls are logged and traceable
- A3 (Transparency): MCP server capabilities are explicitly exposed
- A4 (Non-Harm): Input validation before MCP tool execution

This tool provides integration between MCP servers and LangChain agents:
- MCP server connection and tool discovery
- Tool registration as LangChain tools
- Async tool execution with error handling
"""

from typing import Dict, Any, Optional, List, Union
from langchain_core.tools import tool, BaseTool, StructuredTool
from pydantic import BaseModel, Field
import logging
import asyncio
from datetime import datetime

# MCP imports
try:
    from mcp import ClientSession, StdioServerParameters
    from mcp.client.stdio import stdio_client
    from mcp.types import Tool, TextContent
    MCP_AVAILABLE = True
except ImportError:
    MCP_AVAILABLE = False
    logging.warning("MCP library not available. Install with: pip install mcp")

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MCPServerConfig(BaseModel):
    """MCP server configuration."""
    name: str = Field(description="Server name")
    command: str = Field(description="Command to start MCP server")
    args: Optional[List[str]] = Field(default=None, description="Command arguments")
    env: Optional[Dict[str, str]] = Field(default=None, description="Environment variables")


class MCPToolWrapper(BaseTool):
    """
    Wrapper to convert MCP tools to LangChain tools.
    
    This allows MCP server tools to be used seamlessly with LangChain agents.
    """
    
    def __init__(
        self,
        mcp_tool: Tool,
        session: Any,
        server_name: str
    ):
        """
        Initialize MCP tool wrapper.
        
        Args:
            mcp_tool: MCP Tool definition
            session: MCP client session
            server_name: Name of MCP server
        """
        super().__init__(
            name=f"{server_name}_{mcp_tool.name}",
            description=mcp_tool.description or f"MCP tool: {mcp_tool.name}",
        )
        self.mcp_tool = mcp_tool
        self.session = session
        self.server_name = server_name
    
    def _run(self, *args, **kwargs) -> str:
        """Synchronous tool execution (not supported for MCP)."""
        raise NotImplementedError(
            "MCP tools are async only. Use _arun() or async context."
        )
    
    async def _arun(self, *args, **kwargs) -> str:
        """
        Async tool execution.
        
        Args:
            *args: Positional arguments
            **kwargs: Keyword arguments matching tool input schema
            
        Returns:
            Tool result as string
        """
        logger.info(
            f"Calling MCP tool {self.mcp_tool.name} "
            f"from server {self.server_name}"
        )
        
        try:
            # Call MCP tool
            result = await self.session.call_tool(
                self.mcp_tool.name,
                kwargs
            )
            
            # Extract text content from result
            if isinstance(result, list) and len(result) > 0:
                content = result[0]
                if isinstance(content, TextContent):
                    return content.text
                elif isinstance(content, dict) and 'text' in content:
                    return content['text']
                else:
                    return str(content)
            else:
                return str(result)
                
        except Exception as e:
            logger.error(f"Error calling MCP tool {self.mcp_tool.name}: {e}")
            raise


class {{ tool_class_name | default('MCPTool') }}:
    """
    {{ tool_name | default('MCP Tool') }} - MCP Server Integration for LangChain
    
    Connects to MCP servers and exposes their tools as LangChain-compatible tools.
    Supports multiple MCP servers and automatic tool discovery.
    
    Example:
        >>> mcp_tool = {{ tool_class_name | default('MCPTool') }}()
        >>> await mcp_tool.connect_server(
        ...     name="filesystem",
        ...     command="npx",
        ...     args=["-y", "@modelcontextprotocol/server-filesystem", "/path"]
        ... )
        >>> tools = await mcp_tool.get_langchain_tools()
        >>> print(f"Available tools: {[t.name for t in tools]}")
    """
    
    def __init__(self):
        """Initialize MCP tool manager."""
        if not MCP_AVAILABLE:
            raise ImportError(
                "MCP library not available. Install with: pip install mcp"
            )
        
        self.servers: Dict[str, Any] = {}
        self.sessions: Dict[str, Any] = {}
        self.tools: Dict[str, List[BaseTool]] = {}
        
        logger.info("Initialized {{ tool_class_name | default('MCPTool') }}")
    
    async def connect_server(
        self,
        name: str,
        command: str,
        args: Optional[List[str]] = None,
        env: Optional[Dict[str, str]] = None
    ):
        """
        Connect to an MCP server.
        
        Args:
            name: Server identifier
            command: Command to start server
            args: Command arguments
            env: Environment variables
            
        Example:
            >>> await mcp_tool.connect_server(
            ...     name="github",
            ...     command="npx",
            ...     args=["-y", "@modelcontextprotocol/server-github"]
            ... )
        """
        logger.info(f"Connecting to MCP server: {name}")
        
        try:
            # Create server parameters
            server_params = StdioServerParameters(
                command=command,
                args=args or [],
                env=env
            )
            
            # Create client session
            async with stdio_client(server_params) as (read, write):
                async with ClientSession(read, write) as session:
                    # Initialize session
                    await session.initialize()
                    
                    # List available tools
                    tools_result = await session.list_tools()
                    tools = tools_result.tools if hasattr(tools_result, 'tools') else []
                    
                    # Convert MCP tools to LangChain tools
                    langchain_tools = [
                        MCPToolWrapper(tool, session, name)
                        for tool in tools
                    ]
                    
                    # Store session and tools
                    self.servers[name] = server_params
                    self.sessions[name] = session
                    self.tools[name] = langchain_tools
                    
                    logger.info(
                        f"Connected to {name}: {len(langchain_tools)} tools available"
                    )
                    
                    return langchain_tools
                    
        except Exception as e:
            logger.error(f"Error connecting to MCP server {name}: {e}")
            raise
    
    async def disconnect_server(self, name: str):
        """
        Disconnect from an MCP server.
        
        Args:
            name: Server identifier
        """
        if name in self.sessions:
            # Session cleanup handled by context manager
            del self.sessions[name]
            del self.tools[name]
            logger.info(f"Disconnected from MCP server: {name}")
    
    async def get_tools(
        self,
        server_name: Optional[str] = None
    ) -> List[BaseTool]:
        """
        Get LangChain tools from MCP server(s).
        
        Args:
            server_name: Specific server name (None for all servers)
            
        Returns:
            List of LangChain tools
        """
        if server_name:
            return self.tools.get(server_name, [])
        else:
            # Return all tools from all servers
            all_tools = []
            for tools_list in self.tools.values():
                all_tools.extend(tools_list)
            return all_tools
    
    async def list_servers(self) -> List[str]:
        """
        List connected MCP servers.
        
        Returns:
            List of server names
        """
        return list(self.servers.keys())
    
    async def list_tools(self, server_name: Optional[str] = None) -> Dict[str, List[str]]:
        """
        List available tools from server(s).
        
        Args:
            server_name: Specific server name (None for all)
            
        Returns:
            Dictionary mapping server names to tool names
        """
        if server_name:
            return {
                server_name: [tool.name for tool in self.tools.get(server_name, [])]
            }
        else:
            return {
                name: [tool.name for tool in tools]
                for name, tools in self.tools.items()
            }
    
    async def call_tool(
        self,
        tool_name: str,
        arguments: Dict[str, Any],
        server_name: Optional[str] = None
    ) -> str:
        """
        Call an MCP tool directly.
        
        Args:
            tool_name: Tool name (with or without server prefix)
            arguments: Tool arguments
            server_name: Server name if tool_name doesn't include prefix
            
        Returns:
            Tool result as string
        """
        # Find tool
        if server_name:
            tools = self.tools.get(server_name, [])
        else:
            # Search all servers
            tools = []
            for tools_list in self.tools.values():
                tools.extend(tools_list)
        
        # Find matching tool
        tool = None
        for t in tools:
            if t.name == tool_name or t.name.endswith(f"_{tool_name}"):
                tool = t
                break
        
        if not tool:
            raise ValueError(f"Tool {tool_name} not found")
        
        # Call tool
        return await tool._arun(**arguments)


# Convenience function to create MCP tools
async def create_mcp_tools(
    server_configs: List[MCPServerConfig]
) -> List[BaseTool]:
    """
    Create LangChain tools from MCP server configurations.
    
    Args:
        server_configs: List of MCP server configurations
        
    Returns:
        List of LangChain tools
        
    Example:
        >>> configs = [
        ...     MCPServerConfig(
        ...         name="filesystem",
        ...         command="npx",
        ...         args=["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
        ...     )
        ... ]
        >>> tools = await create_mcp_tools(configs)
    """
    mcp_tool = {{ tool_class_name | default('MCPTool') }}()
    
    for config in server_configs:
        await mcp_tool.connect_server(
            name=config.name,
            command=config.command,
            args=config.args,
            env=config.env
        )
    
    return await mcp_tool.get_tools()


# LangChain tool wrapper for specific MCP tool
@tool
async def {{ tool_function_name | default('mcp_tool_call') }}(
    server_name: str,
    tool_name: str,
    arguments: str
) -> str:
    """
    Call an MCP tool from a connected server.
    
    This tool implements A1 (Verifiability) by logging all MCP calls.
    This tool implements A3 (Transparency) by exposing MCP server capabilities.
    
    Args:
        server_name: Name of MCP server
        tool_name: Name of tool to call
        arguments: JSON string of tool arguments
        
    Returns:
        Tool result as string
        
    Example:
        >>> result = await {{ tool_function_name | default('mcp_tool_call') }}(
        ...     server_name="filesystem",
        ...     tool_name="read_file",
        ...     arguments='{"path": "/tmp/file.txt"}'
        ... )
    """
    import json
    
    # Parse arguments
    args_dict = json.loads(arguments) if arguments else {}
    
    # Create tool instance (in production, this should be a singleton)
    mcp_tool = {{ tool_class_name | default('MCPTool') }}()
    
    # Call tool
    result = await mcp_tool.call_tool(
        tool_name=tool_name,
        arguments=args_dict,
        server_name=server_name
    )
    
    return result


# Example usage
if __name__ == "__main__":
    async def main():
        mcp_tool = {{ tool_class_name | default('MCPTool') }}()
        
        try:
            # Connect to MCP server
            # Example: filesystem server
            # await mcp_tool.connect_server(
            #     name="filesystem",
            #     command="npx",
            #     args=["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
            # )
            
            # List servers and tools
            servers = await mcp_tool.list_servers()
            print(f"Connected servers: {servers}")
            
            tools_info = await mcp_tool.list_tools()
            print(f"Available tools: {tools_info}")
            
            # Get LangChain tools
            tools = await mcp_tool.get_tools()
            print(f"LangChain tools: {[t.name for t in tools]}")
            
        except Exception as e:
            print(f"Error: {e}")
    
    asyncio.run(main())
