{
  "$schema": "../learning-workshop-pattern.json",
  "workshopId": "L13_docker_containerization",
  "name": "Docker Containerization Best Practices",
  "technology": {
    "category": "cloud_native",
    "stack": "Docker",
    "language": "Dockerfile",
    "version": "Docker 24+"
  },
  "level": "intermediate",
  "prerequisites": {
    "workshops": [],
    "knowledge": [
      "Basic Linux commands",
      "Understanding of application deployment",
      "Command line basics"
    ],
    "tools": [
      "Docker Desktop or Docker Engine",
      "VS Code with Docker extension",
      "Git"
    ]
  },
  "duration": {
    "total_hours": 2.5,
    "concept_minutes": 30,
    "demo_minutes": 30,
    "exercise_minutes": 45,
    "challenge_minutes": 30,
    "reflection_minutes": 15
  },
  "learning_objectives": [
    {
      "objective": "Write efficient Dockerfiles using multi-stage builds",
      "bloom_level": "apply",
      "verification": "Creates Dockerfile with multi-stage build that reduces image size"
    },
    {
      "objective": "Optimize Docker layer caching for faster builds",
      "bloom_level": "analyze",
      "verification": "Orders Dockerfile instructions to maximize cache hits"
    },
    {
      "objective": "Implement security best practices (non-root user, minimal base images)",
      "bloom_level": "apply",
      "verification": "Creates secure Dockerfile with non-root user and minimal image"
    },
    {
      "objective": "Use Docker Compose for multi-container applications",
      "bloom_level": "apply",
      "verification": "Creates docker-compose.yml for multi-service application"
    },
    {
      "objective": "Configure Docker networking and volumes",
      "bloom_level": "apply",
      "verification": "Sets up networks and volumes for container communication and persistence"
    }
  ],
  "knowledge_files": [
    "docker-patterns.json"
  ],
  "phases": [
    {
      "phaseId": "concept",
      "name": "Docker Fundamentals and Best Practices",
      "type": "concept",
      "duration_minutes": 30,
      "description": "Understanding Docker architecture and production best practices",
      "content": {
        "topics": [
          "Docker architecture: images, containers, layers",
          "Dockerfile best practices",
          "Multi-stage builds for optimization",
          "Layer caching and build optimization",
          "Security: non-root users, minimal images, secrets",
          "Docker Compose for orchestration",
          "Networking: bridge, host, overlay networks",
          "Volumes: bind mounts and named volumes"
        ],
        "diagrams": [
          "Docker image layers",
          "Multi-stage build process",
          "Docker networking architecture",
          "Volume mounting strategies"
        ],
        "key_points": [
          "Multi-stage builds reduce final image size",
          "Layer order affects cache efficiency",
          "Always use non-root users in production",
          "Minimal base images improve security",
          "Compose simplifies multi-container apps"
        ]
      },
      "facilitator_notes": "Emphasize security and optimization. Show the impact of layer ordering on build times.",
      "common_questions": [
        "How do multi-stage builds work?",
        "Why should I use non-root users?",
        "What's the difference between COPY and ADD?"
      ]
    },
    {
      "phaseId": "demo",
      "name": "Building Production-Ready Containers",
      "type": "demo",
      "duration_minutes": 30,
      "description": "Live coding a secure, optimized Dockerfile",
      "content": {
        "topics": [
          "Writing multi-stage Dockerfile",
          "Optimizing layer caching",
          "Adding non-root user",
          "Creating docker-compose.yml",
          "Setting up networks and volumes",
          "Building and testing the image"
        ],
        "code_examples": [
          "Multi-stage Dockerfile",
          "docker-compose.yml",
          "Docker build commands",
          "Security scanning"
        ],
        "key_points": [
          "Separate build and runtime stages",
          "Copy only what's needed",
          "Use specific base image tags",
          "Set proper file permissions"
        ]
      },
      "facilitator_notes": "Show build time differences. Demonstrate security scanning tools."
    },
    {
      "phaseId": "exercise_1",
      "name": "Multi-Stage Dockerfile",
      "type": "exercise",
      "duration_minutes": 20,
      "description": "Create an optimized multi-stage Dockerfile",
      "content": {
        "topics": [
          "Write build stage",
          "Create runtime stage",
          "Copy artifacts efficiently",
          "Add non-root user",
          "Optimize layer order"
        ]
      }
    },
    {
      "phaseId": "exercise_2",
      "name": "Docker Compose Setup",
      "type": "exercise",
      "duration_minutes": 25,
      "description": "Create docker-compose.yml for multi-service app",
      "content": {
        "topics": [
          "Define services",
          "Configure networks",
          "Set up volumes",
          "Add environment variables",
          "Configure dependencies"
        ]
      }
    },
    {
      "phaseId": "challenge",
      "name": "Full Stack Application Containerization",
      "type": "challenge",
      "duration_minutes": 30,
      "description": "Containerize a complete application with frontend, backend, and database",
      "content": {
        "topics": [
          "Containerize frontend application",
          "Containerize backend API",
          "Set up database container",
          "Create docker-compose.yml",
          "Configure networking",
          "Set up volumes for persistence",
          "Add health checks"
        ]
      }
    },
    {
      "phaseId": "reflection",
      "name": "Key Takeaways and Production Considerations",
      "type": "reflection",
      "duration_minutes": 15,
      "description": "Consolidate learning and discuss deployment",
      "content": {
        "topics": [
          "Docker best practices summary",
          "Security considerations",
          "Performance optimization",
          "CI/CD integration",
          "Monitoring and logging"
        ],
        "key_points": [
          "Always use multi-stage builds",
          "Security is non-negotiable",
          "Optimize for cache efficiency",
          "Use Compose for development",
          "Monitor container health"
        ]
      }
    }
  ],
  "exercises": [
    {
      "exerciseId": "ex1_multistage",
      "name": "Multi-Stage Dockerfile",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 20,
      "description": "Create an optimized multi-stage Dockerfile for a Python application",
      "starter_code": "# Dockerfile\n# TODO: Create build stage\n# FROM python:3.11-slim as builder\n# WORKDIR /app\n# COPY requirements.txt .\n# RUN pip install --user -r requirements.txt\n\n# TODO: Create runtime stage\n# FROM python:3.11-slim\n# WORKDIR /app\n# COPY --from=builder /root/.local /root/.local\n# COPY . .\n# ENV PATH=/root/.local/bin:$PATH\n# CMD [\"python\", \"app.py\"]",
      "solution_code": "# Dockerfile\n# Build stage\nFROM python:3.11-slim as builder\n\nWORKDIR /app\n\n# Install build dependencies\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    gcc \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy requirements and install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir --user -r requirements.txt\n\n# Runtime stage\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Create non-root user\nRUN groupadd -r appuser && useradd -r -g appuser appuser\n\n# Copy installed packages from builder\nCOPY --from=builder /root/.local /home/appuser/.local\n\n# Copy application code\nCOPY --chown=appuser:appuser . .\n\n# Set PATH to include user-installed packages\nENV PATH=/home/appuser/.local/bin:$PATH\n\n# Switch to non-root user\nUSER appuser\n\n# Expose port\nEXPOSE 8000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD python -c \"import requests; requests.get('http://localhost:8000/health')\" || exit 1\n\n# Run application\nCMD [\"python\", \"app.py\"]",
      "hints": [
        "Separate build dependencies from runtime",
        "Use --from flag to copy from builder stage",
        "Create non-root user before copying files",
        "Set proper file ownership with --chown",
        "Use HEALTHCHECK for container health"
      ],
      "verification": "Dockerfile builds successfully, image size is reduced, runs as non-root user",
      "common_mistakes": [
        "Not separating build and runtime stages",
        "Forgetting to switch to non-root user",
        "Copying unnecessary files",
        "Not optimizing layer order",
        "Missing health checks"
      ]
    },
    {
      "exerciseId": "ex2_compose",
      "name": "Docker Compose Setup",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 25,
      "description": "Create docker-compose.yml for a web application with database",
      "starter_code": "# docker-compose.yml\nversion: '3.8'\n\nservices:\n  # TODO: Define web service\n  # web:\n  #   build: .\n  #   ports:\n  #     - \"8000:8000\"\n  #   environment:\n  #     - DATABASE_URL=postgresql://user:pass@db:5432/mydb\n  #   depends_on:\n  #     - db\n  \n  # TODO: Define database service\n  # db:\n  #   image: postgres:15-alpine\n  #   environment:\n  #     - POSTGRES_USER=user\n  #     - POSTGRES_PASSWORD=pass\n  #     - POSTGRES_DB=mydb\n  #   volumes:\n  #     - db_data:/var/lib/postgresql/data\n\n# TODO: Define volumes\n# volumes:\n#   db_data:",
      "solution_code": "# docker-compose.yml\nversion: '3.8'\n\nservices:\n  web:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    container_name: web-app\n    ports:\n      - \"8000:8000\"\n    environment:\n      - DATABASE_URL=postgresql://appuser:apppass@db:5432/appdb\n      - DEBUG=false\n    env_file:\n      - .env\n    depends_on:\n      db:\n        condition: service_healthy\n    networks:\n      - app-network\n    volumes:\n      - ./logs:/app/logs\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n      start_period: 40s\n\n  db:\n    image: postgres:15-alpine\n    container_name: app-db\n    environment:\n      - POSTGRES_USER=appuser\n      - POSTGRES_PASSWORD=apppass\n      - POSTGRES_DB=appdb\n    volumes:\n      - db_data:/var/lib/postgresql/data\n      - ./init.sql:/docker-entrypoint-initdb.d/init.sql\n    networks:\n      - app-network\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U appuser\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  nginx:\n    image: nginx:alpine\n    container_name: app-nginx\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n    depends_on:\n      - web\n    networks:\n      - app-network\n    restart: unless-stopped\n\nnetworks:\n  app-network:\n    driver: bridge\n\nvolumes:\n  db_data:\n    driver: local",
      "verification": "All services start correctly, networking works, volumes persist data, health checks pass",
      "common_mistakes": [
        "Not setting up health checks",
        "Missing depends_on conditions",
        "Not configuring networks",
        "Forgetting volume definitions",
        "Not using restart policies"
      ]
    }
  ],
  "challenges": [
    {
      "challengeId": "fullstack",
      "name": "Full Stack Application Containerization",
      "description": "Containerize a complete application with frontend, backend, and database",
      "requirements": [
        "Create multi-stage Dockerfile for frontend",
        "Create multi-stage Dockerfile for backend",
        "Set up PostgreSQL database container",
        "Create docker-compose.yml orchestrating all services",
        "Configure custom networks",
        "Set up volumes for database persistence",
        "Add health checks for all services",
        "Implement non-root users in all containers",
        "Optimize image sizes"
      ],
      "evaluation_criteria": [
        "All Dockerfiles use multi-stage builds",
        "Images are optimized and secure",
        "Compose file orchestrates all services",
        "Networking allows service communication",
        "Volumes persist data correctly",
        "Health checks work",
        "All containers run as non-root",
        "Build times are optimized"
      ],
      "stretch_goals": [
        "Add Redis cache container",
        "Implement Docker secrets",
        "Set up reverse proxy with Nginx",
        "Add monitoring with Prometheus",
        "Create production and development Compose files"
      ]
    }
  ],
  "resources": {
    "official_docs": [
      "https://docs.docker.com/",
      "https://docs.docker.com/develop/develop-images/dockerfile_best-practices/",
      "https://docs.docker.com/compose/"
    ],
    "tutorials": [
      "Docker Getting Started - Official",
      "Docker Deep Dive - Pluralsight"
    ],
    "videos": [
      "Docker Tutorial for Beginners - freeCodeCamp",
      "Docker Best Practices - DockerCon"
    ],
    "community": [
      "Docker Community Forums",
      "r/docker",
      "Stack Overflow - docker tag"
    ]
  },
  "assessment": {
    "knowledge_check": [
      {
        "question": "What are the benefits of multi-stage builds?",
        "type": "short_answer",
        "answer": "Multi-stage builds reduce final image size by excluding build tools and dependencies. They improve security by using minimal runtime images. They also separate build and runtime concerns, making images more maintainable.",
        "explanation": "Multi-stage builds are essential for production images"
      },
      {
        "question": "Why should containers run as non-root users?",
        "type": "short_answer",
        "answer": "Running as non-root reduces security risk. If a container is compromised, the attacker has limited privileges. It follows the principle of least privilege and is a security best practice.",
        "explanation": "Security is critical in containerized applications"
      },
      {
        "question": "How does Docker layer caching work?",
        "type": "short_answer",
        "answer": "Docker caches each layer. If a layer hasn't changed, Docker reuses the cached layer. Order matters: place frequently changing instructions (like COPY . .) at the end, and stable instructions (like installing dependencies) earlier to maximize cache hits.",
        "explanation": "Layer ordering significantly impacts build performance"
      }
    ],
    "practical_assessment": "Create production-ready Dockerfiles and docker-compose.yml for a multi-service application with security best practices and optimizations",
    "self_assessment": [
      "Can I write efficient multi-stage Dockerfiles?",
      "Do I understand layer caching optimization?",
      "Can I implement security best practices?",
      "Do I know how to use Docker Compose?",
      "Can I configure networking and volumes?"
    ]
  },
  "next_steps": {
    "next_workshop": "L12_kubernetes_production",
    "practice_projects": [
      "Containerize a microservices architecture",
      "Set up CI/CD with Docker",
      "Create development and production environments"
    ],
    "deeper_learning": [
      "Advanced Docker networking",
      "Docker security scanning",
      "Container orchestration with Kubernetes"
    ]
  },
  "axiom_zero_integration": {
    "love_moments": [
      "Celebrating first successful container build",
      "Encouraging experimentation with different optimizations",
      "Patient debugging of Docker issues"
    ],
    "truth_moments": [
      "Honest discussion of Docker complexity",
      "Clear explanation of security implications",
      "Acknowledging when containers aren't needed"
    ],
    "beauty_moments": [
      "Elegant multi-stage Dockerfiles",
      "Beautiful docker-compose configurations",
      "Clean, optimized images that are secure and efficient"
    ]
  }
}
