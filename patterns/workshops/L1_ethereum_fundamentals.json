{
  "$schema": "../learning-workshop-pattern.json",
  "workshopId": "L1_ethereum_fundamentals",
  "name": "Ethereum Smart Contract Development",
  "technology": {
    "category": "blockchain",
    "stack": "Ethereum + Hardhat",
    "language": "Solidity",
    "version": "Solidity 0.8+"
  },
  "level": "fundamentals",
  "prerequisites": {
    "workshops": [],
    "knowledge": [
      "Basic programming concepts (variables, functions, control flow)",
      "Understanding of blockchain basics (blocks, transactions, consensus)",
      "JavaScript/TypeScript familiarity for testing"
    ],
    "tools": [
      "Node.js 18+ installed",
      "npm or yarn package manager",
      "Code editor (VS Code recommended)",
      "Git for version control"
    ]
  },
  "duration": {
    "total_hours": 2.5,
    "concept_minutes": 30,
    "demo_minutes": 30,
    "exercise_minutes": 45,
    "challenge_minutes": 30,
    "reflection_minutes": 15
  },
  "learning_objectives": [
    {
      "objective": "Understand the Ethereum Virtual Machine (EVM) architecture, storage model, and gas mechanism",
      "bloom_level": "understand",
      "verification": "Can explain how EVM executes bytecode, how storage slots work, and why gas costs matter"
    },
    {
      "objective": "Write basic Solidity smart contracts with state variables, functions, and events",
      "bloom_level": "apply",
      "verification": "Successfully compile and deploy a contract to local Hardhat network"
    },
    {
      "objective": "Use Hardhat framework for development, testing, and deployment",
      "bloom_level": "apply",
      "verification": "Can write and run tests, use console.log for debugging, and deploy contracts"
    },
    {
      "objective": "Implement common token patterns including ERC20 fungible tokens and ERC721 non-fungible tokens",
      "bloom_level": "apply",
      "verification": "Create working ERC20 token contract and basic ERC721 NFT contract"
    },
    {
      "objective": "Identify and apply security best practices to prevent common vulnerabilities",
      "bloom_level": "analyze",
      "verification": "Can spot reentrancy risks, integer overflow issues, and missing access controls"
    }
  ],
  "knowledge_files": [
    "solidity-patterns.json",
    "ethereum-security.json"
  ],
  "phases": [
    {
      "phaseId": "concept",
      "name": "EVM Architecture and Solidity Fundamentals",
      "type": "concept",
      "duration_minutes": 30,
      "description": "Deep dive into how Ethereum works under the hood",
      "content": {
        "topics": [
          "EVM architecture: bytecode execution, stack machine model",
          "Storage model: storage slots, memory, calldata, stack",
          "Gas mechanism: computation costs, storage costs, gas optimization",
          "Account model: EOA vs Contract accounts",
          "Transaction lifecycle: creation, validation, execution",
          "Solidity basics: data types, visibility modifiers, inheritance"
        ],
        "diagrams": [
          "EVM execution flow diagram",
          "Storage layout visualization",
          "Gas cost breakdown chart",
          "Transaction structure diagram"
        ],
        "key_points": [
          "Storage is persistent but expensive (20,000 gas per write)",
          "Memory is temporary and cheaper",
          "Every operation costs gas - optimization matters",
          "Contracts are immutable once deployed",
          "State changes persist across transactions"
        ]
      },
      "facilitator_notes": "Use visual diagrams to show EVM internals. Compare gas costs for different operations. Emphasize that understanding gas helps write efficient contracts.",
      "common_questions": [
        "Why is storage so expensive compared to computation?",
        "What happens if a transaction runs out of gas?",
        "Can I update a deployed contract?",
        "How do I estimate gas costs?"
      ]
    },
    {
      "phaseId": "demo",
      "name": "Building an ERC20 Token",
      "type": "demo",
      "duration_minutes": 30,
      "description": "Live coding a complete ERC20 token contract from scratch",
      "content": {
        "topics": [
          "Hardhat project setup and structure",
          "ERC20 standard interface",
          "Implementing transfer, approve, transferFrom",
          "Events: Transfer, Approval",
          "Testing with Hardhat and ethers.js",
          "Deploying to local network"
        ],
        "code_examples": [
          "npx hardhat init",
          "Complete ERC20 contract implementation",
          "Hardhat test file with multiple test cases",
          "Deployment script"
        ],
        "key_points": [
          "ERC20 is a standard interface, not an implementation",
          "Always emit events for state changes",
          "Use SafeMath or Solidity 0.8+ overflow protection",
          "Test both success and failure paths"
        ]
      },
      "facilitator_notes": "Type code live, explain each function. Show how to test transfers, approvals, and edge cases. Demonstrate debugging with console.log."
    },
    {
      "phaseId": "exercise_1",
      "name": "Guided Contract Development",
      "type": "exercise",
      "duration_minutes": 30,
      "description": "Build a simple voting contract with guided steps",
      "content": {
        "topics": [
          "Create Voting contract with proposals and votes",
          "Implement vote casting with duplicate prevention",
          "Add access control for admin functions",
          "Write comprehensive tests"
        ]
      }
    },
    {
      "phaseId": "exercise_2",
      "name": "Testing and Debugging",
      "type": "exercise",
      "duration_minutes": 15,
      "description": "Practice writing tests and debugging failed transactions",
      "content": {
        "topics": [
          "Writing test cases with ethers.js",
          "Testing edge cases and error conditions",
          "Using Hardhat console.log for debugging",
          "Reading transaction receipts and events"
        ]
      }
    },
    {
      "phaseId": "challenge",
      "name": "Build a Mini-NFT Contract",
      "type": "challenge",
      "duration_minutes": 30,
      "description": "Apply all concepts to build a basic NFT contract",
      "content": {
        "topics": [
          "Implement ERC721 standard (mint, transfer, ownerOf)",
          "Add metadata URI storage",
          "Implement minting with unique token IDs",
          "Add basic access control",
          "Write tests for minting and transfers"
        ]
      }
    },
    {
      "phaseId": "reflection",
      "name": "Key Takeaways and Security Awareness",
      "type": "reflection",
      "duration_minutes": 15,
      "description": "Consolidate learning and emphasize security mindset",
      "content": {
        "topics": [
          "Summary of EVM and gas optimization",
          "Importance of following standards (ERC20, ERC721)",
          "Security best practices and common pitfalls",
          "Resources for continued learning and auditing"
        ],
        "key_points": [
          "Always validate inputs and check access controls",
          "Use reentrancy guards for external calls",
          "Prefer pull over push patterns for payments",
          "Test thoroughly before mainnet deployment",
          "Consider gas costs in contract design"
        ]
      }
    }
  ],
  "exercises": [
    {
      "exerciseId": "ex1_voting_contract",
      "name": "Voting Contract",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 30,
      "description": "Create a simple voting contract where users can vote on proposals",
      "starter_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract Voting {\n    // TODO: Define state variables\n    // - proposals array\n    // - votes mapping (address => bool)\n    // - admin address\n    \n    constructor() {\n        // TODO: Set admin\n    }\n    \n    function addProposal(string memory description) public {\n        // TODO: Only admin can add proposals\n        // TODO: Add proposal to array\n    }\n    \n    function vote(uint256 proposalId) public {\n        // TODO: Prevent double voting\n        // TODO: Record vote\n        // TODO: Increment vote count\n    }\n    \n    function getProposal(uint256 proposalId) public view returns (string memory, uint256) {\n        // TODO: Return proposal description and vote count\n    }\n}",
      "solution_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract Voting {\n    struct Proposal {\n        string description;\n        uint256 voteCount;\n    }\n    \n    Proposal[] public proposals;\n    mapping(address => bool) public hasVoted;\n    address public admin;\n    \n    event ProposalAdded(uint256 indexed proposalId, string description);\n    event VoteCast(address indexed voter, uint256 indexed proposalId);\n    \n    constructor() {\n        admin = msg.sender;\n    }\n    \n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Only admin can perform this action\");\n        _;\n    }\n    \n    function addProposal(string memory description) public onlyAdmin {\n        proposals.push(Proposal({\n            description: description,\n            voteCount: 0\n        }));\n        emit ProposalAdded(proposals.length - 1, description);\n    }\n    \n    function vote(uint256 proposalId) public {\n        require(proposalId < proposals.length, \"Invalid proposal ID\");\n        require(!hasVoted[msg.sender], \"Already voted\");\n        \n        hasVoted[msg.sender] = true;\n        proposals[proposalId].voteCount++;\n        \n        emit VoteCast(msg.sender, proposalId);\n    }\n    \n    function getProposal(uint256 proposalId) public view returns (string memory, uint256) {\n        require(proposalId < proposals.length, \"Invalid proposal ID\");\n        Proposal memory proposal = proposals[proposalId];\n        return (proposal.description, proposal.voteCount);\n    }\n    \n    function getProposalCount() public view returns (uint256) {\n        return proposals.length;\n    }\n}",
      "hints": [
        "Use a struct to group proposal data together",
        "Use mapping(address => bool) to track who has voted",
        "Create a modifier for admin-only functions",
        "Always emit events for important state changes",
        "Validate proposalId to prevent out-of-bounds access"
      ],
      "verification": "Contract compiles, tests pass, and voting works correctly",
      "common_mistakes": [
        "Forgetting to check if user already voted",
        "Not validating proposalId bounds",
        "Missing access control on addProposal",
        "Not emitting events",
        "Using storage instead of memory in view functions"
      ]
    },
    {
      "exerciseId": "ex2_testing",
      "name": "Testing the Voting Contract",
      "type": "guided",
      "difficulty": "medium",
      "duration_minutes": 15,
      "description": "Write comprehensive tests for the voting contract",
      "starter_code": "const { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\ndescribe(\"Voting\", function () {\n  let voting;\n  let owner, voter1, voter2;\n\n  beforeEach(async function () {\n    [owner, voter1, voter2] = await ethers.getSigners();\n    const Voting = await ethers.getContractFactory(\"Voting\");\n    voting = await Voting.deploy();\n    await voting.deployed();\n  });\n\n  it(\"Should allow admin to add proposals\", async function () {\n    // TODO: Test adding a proposal\n  });\n\n  it(\"Should prevent non-admin from adding proposals\", async function () {\n    // TODO: Test access control\n  });\n\n  it(\"Should allow users to vote\", async function () {\n    // TODO: Test voting functionality\n  });\n\n  it(\"Should prevent double voting\", async function () {\n    // TODO: Test duplicate vote prevention\n  });\n\n  it(\"Should return correct proposal details\", async function () {\n    // TODO: Test getProposal function\n  });\n});",
      "solution_code": "const { expect } = require(\"chai\");\nconst { ethers } = require(\"hardhat\");\n\ndescribe(\"Voting\", function () {\n  let voting;\n  let owner, voter1, voter2;\n\n  beforeEach(async function () {\n    [owner, voter1, voter2] = await ethers.getSigners();\n    const Voting = await ethers.getContractFactory(\"Voting\");\n    voting = await Voting.deploy();\n    await voting.deployed();\n  });\n\n  it(\"Should allow admin to add proposals\", async function () {\n    await voting.addProposal(\"Proposal 1\");\n    const [description, voteCount] = await voting.getProposal(0);\n    expect(description).to.equal(\"Proposal 1\");\n    expect(voteCount).to.equal(0);\n  });\n\n  it(\"Should prevent non-admin from adding proposals\", async function () {\n    await expect(\n      voting.connect(voter1).addProposal(\"Unauthorized proposal\")\n    ).to.be.revertedWith(\"Only admin can perform this action\");\n  });\n\n  it(\"Should allow users to vote\", async function () {\n    await voting.addProposal(\"Proposal 1\");\n    await voting.connect(voter1).vote(0);\n    const [, voteCount] = await voting.getProposal(0);\n    expect(voteCount).to.equal(1);\n    expect(await voting.hasVoted(voter1.address)).to.be.true;\n  });\n\n  it(\"Should prevent double voting\", async function () {\n    await voting.addProposal(\"Proposal 1\");\n    await voting.connect(voter1).vote(0);\n    await expect(\n      voting.connect(voter1).vote(0)\n    ).to.be.revertedWith(\"Already voted\");\n  });\n\n  it(\"Should return correct proposal details\", async function () {\n    await voting.addProposal(\"Test Proposal\");\n    await voting.connect(voter1).vote(0);\n    await voting.connect(voter2).vote(0);\n    const [description, voteCount] = await voting.getProposal(0);\n    expect(description).to.equal(\"Test Proposal\");\n    expect(voteCount).to.equal(2);\n  });\n\n  it(\"Should revert on invalid proposal ID\", async function () {\n    await expect(\n      voting.connect(voter1).vote(999)\n    ).to.be.revertedWith(\"Invalid proposal ID\");\n  });\n});",
      "verification": "All test cases pass",
      "common_mistakes": [
        "Not using connect() to test from different addresses",
        "Forgetting to await async calls",
        "Not testing error conditions",
        "Incorrect event assertions",
        "Not resetting state between tests"
      ]
    }
  ],
  "challenges": [
    {
      "challengeId": "mini_nft",
      "name": "Build a Mini-NFT Contract",
      "description": "Create a basic ERC721 non-fungible token contract",
      "requirements": [
        "Implement ERC721 interface: mint, transfer, ownerOf, balanceOf",
        "Store token metadata URI for each token",
        "Mint function that assigns unique token IDs",
        "Only contract owner can mint",
        "Emit Transfer events on mint and transfer",
        "Write tests covering minting, transfers, and ownership queries"
      ],
      "evaluation_criteria": [
        "Contract compiles without errors",
        "Can mint NFTs with unique IDs",
        "Transfer function works correctly",
        "ownerOf returns correct addresses",
        "Access control prevents unauthorized minting",
        "All tests pass"
      ],
      "stretch_goals": [
        "Add tokenURI function that returns metadata",
        "Implement burn functionality",
        "Add approval mechanism for transfers",
        "Create a simple frontend to display NFTs"
      ]
    }
  ],
  "resources": {
    "official_docs": [
      "https://docs.soliditylang.org/",
      "https://hardhat.org/docs",
      "https://ethereum.org/en/developers/docs/"
    ],
    "tutorials": [
      "https://ethereum.org/en/developers/tutorials/",
      "https://hardhat.org/tutorial",
      "https://docs.openzeppelin.com/contracts"
    ],
    "videos": [
      "Ethereum Foundation YouTube channel",
      "Dapp University Solidity tutorials"
    ],
    "books": [
      "Mastering Ethereum by Andreas Antonopoulos",
      "Solidity by Example"
    ],
    "community": [
      "Ethereum Stack Exchange",
      "r/ethereum on Reddit",
      "Hardhat Discord"
    ]
  },
  "assessment": {
    "knowledge_check": [
      {
        "question": "What is the main difference between storage and memory in Solidity?",
        "type": "short_answer",
        "answer": "Storage is persistent, expensive (20,000 gas per write), and stored on-chain permanently. Memory is temporary, cheaper, and cleared after function execution.",
        "explanation": "Understanding this difference is crucial for gas optimization"
      },
      {
        "question": "What happens if a transaction runs out of gas?",
        "type": "short_answer",
        "answer": "The transaction reverts - all state changes are rolled back, but the gas spent is still consumed (not refunded).",
        "explanation": "This is why gas estimation is important before sending transactions"
      },
      {
        "question": "Which visibility modifier allows a function to be called only from within the contract?",
        "type": "multiple_choice",
        "answer": "private",
        "explanation": "private functions can only be called from within the same contract, internal can be called from derived contracts"
      },
      {
        "question": "What is the purpose of the ERC20 standard?",
        "type": "short_answer",
        "answer": "ERC20 defines a standard interface for fungible tokens, ensuring interoperability between different token contracts and wallets.",
        "explanation": "Standards enable composability in DeFi"
      }
    ],
    "practical_assessment": "Deploy a working ERC20 token contract to a testnet with comprehensive tests",
    "self_assessment": [
      "Can I explain how the EVM executes smart contracts?",
      "Do I understand when to use storage vs memory vs calldata?",
      "Can I write tests that cover both success and failure cases?",
      "Am I aware of common security vulnerabilities in Solidity?",
      "Can I estimate and optimize gas costs?"
    ]
  },
  "next_steps": {
    "next_workshop": "L3_ethereum_defi",
    "practice_projects": [
      "Multi-signature wallet contract",
      "Decentralized exchange (DEX) with liquidity pools",
      "Staking contract with rewards",
      "Governance token with voting"
    ],
    "deeper_learning": [
      "Advanced Solidity patterns (proxy, factory, diamond)",
      "Gas optimization techniques",
      "Security auditing and formal verification",
      "DeFi protocol development"
    ]
  },
  "axiom_zero_integration": {
    "love_moments": [
      "Patient explanation of complex EVM concepts",
      "Encouraging support when debugging failed transactions",
      "Celebrating successful contract deployments",
      "Creating a safe learning environment where mistakes are expected"
    ],
    "truth_moments": [
      "Honest discussion of Ethereum's scalability limitations",
      "Clear security warnings about common vulnerabilities",
      "Accurate gas cost explanations and optimization guidance",
      "Verified code examples that actually work",
      "Transparent about testing requirements before mainnet"
    ],
    "beauty_moments": [
      "Appreciation for elegant contract design patterns",
      "Clean, readable Solidity code structure",
      "The satisfaction of a gas-efficient contract",
      "Beautiful test coverage with clear assertions",
      "Elegant use of events for off-chain indexing"
    ]
  }
}
