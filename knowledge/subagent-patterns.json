{
  "id": "subagent-patterns",
  "name": "Subagent Orchestration Patterns",
  "version": "1.0.0",
  "category": "agent-development",
  "description": "Patterns for spawning, managing, and orchestrating subagents including communication, resource management, and error propagation",
  "patterns": {
    "spawning_strategies": {
      "dynamic_spawning": {
        "description": "Create subagents on demand based on task requirements",
        "pattern": "Analyze task -> Determine needed roles -> Spawn subagents -> Delegate",
        "example": "async def spawn_subagent(agent_id: str, role: str) -> Subagent:\n    subagent = Subagent(agent_id, role, llm)\n    self.subagents[agent_id] = subagent\n    return subagent",
        "use_when": ["Variable workloads", "Task-specific agents", "Dynamic decomposition"],
        "best_practices": [
          "Track spawned agents",
          "Set limits on concurrent agents",
          "Clean up when done"
        ]
      },
      "pool_pattern": {
        "description": "Maintain a pool of reusable subagents",
        "pattern": "Initialize pool -> Acquire agent -> Use -> Release back to pool",
        "use_when": ["High-throughput tasks", "Consistent workloads", "Resource optimization"],
        "benefits": [
          "Reduced overhead",
          "Better resource utilization",
          "Faster task execution"
        ]
      },
      "hierarchical_spawning": {
        "description": "Parent agent spawns child agents which may spawn grandchildren",
        "pattern": "Parent -> Children -> Grandchildren (multi-level hierarchy)",
        "use_when": ["Complex decomposition", "Specialized sub-tasks", "Organizational structures"]
      },
      "on_demand_specialists": {
        "description": "Spawn specialist agents based on task requirements",
        "pattern": "Identify needed expertise -> Spawn specialist -> Delegate -> Cleanup",
        "use_when": ["Specialized knowledge needed", "Domain-specific tasks"]
      }
    },
    "communication_patterns": {
      "task_delegation": {
        "description": "Parent assigns tasks to child agents",
        "pattern": "Parent creates task -> Sends to subagent -> Subagent executes -> Returns result",
        "message_types": ["TASK", "RESULT", "QUERY", "STATUS"],
        "best_practices": [
          "Include task context",
          "Set clear expectations",
          "Track task IDs"
        ]
      },
      "bidirectional_communication": {
        "description": "Two-way communication between parent and child",
        "pattern": "Parent <-> Child message passing with message queues",
        "use_when": ["Interactive workflows", "Status updates", "Clarification needed"],
        "implementation": "Message queues with sender/receiver IDs and message types"
      },
      "result_aggregation": {
        "description": "Combine results from multiple subagents",
        "patterns": {
          "parallel_aggregation": "Aggregate independent results from concurrent subagents",
          "sequential_aggregation": "Synthesize results from sequential pipeline",
          "voting_consensus": "Determine consensus from multiple agent opinions"
        },
        "use_when": ["Multi-agent outputs", "Synthesis needed", "Consensus building"]
      },
      "status_queries": {
        "description": "Parent checks child agent status",
        "pattern": "Parent sends QUERY -> Child responds with STATUS",
        "use_when": ["Monitoring", "Progress tracking", "Health checks"]
      }
    },
    "resource_management": {
      "lifecycle_tracking": {
        "description": "Track subagent lifecycle and resource usage",
        "tracked_metrics": [
          "created_at",
          "status",
          "task_count",
          "memory_usage",
          "terminated_at"
        ],
        "best_practices": [
          "Monitor resource usage",
          "Set limits on concurrent agents",
          "Track agent health"
        ]
      },
      "automatic_cleanup": {
        "description": "Automatically clean up subagents when done",
        "pattern": "Use context managers for automatic cleanup",
        "example": "async with resource_manager.managed_subagent(id, role, llm) as agent:\n    result = await agent.execute_task(task)\n    # Auto cleanup on exit",
        "benefits": [
          "Prevents memory leaks",
          "Ensures proper cleanup",
          "Simplifies resource management"
        ]
      },
      "resource_limits": {
        "description": "Set limits on concurrent subagents and resource usage",
        "limits": [
          "Max concurrent agents",
          "Memory per agent",
          "Task queue size",
          "Execution timeout"
        ],
        "best_practices": [
          "Set reasonable limits",
          "Monitor usage",
          "Handle limit exceeded gracefully"
        ]
      },
      "graceful_shutdown": {
        "description": "Properly shut down all subagents",
        "pattern": "Signal shutdown -> Wait for completion -> Cleanup resources",
        "best_practices": [
          "Allow in-flight tasks to complete",
          "Save necessary state",
          "Release all resources"
        ]
      }
    },
    "error_propagation": {
      "error_handling": {
        "description": "Handle errors from subagent execution",
        "pattern": "Wrap subagent calls in try/except -> Log error -> Report to parent",
        "best_practices": [
          "Catch specific exceptions",
          "Provide error context",
          "Don't silently fail"
        ]
      },
      "error_propagation": {
        "description": "Propagate errors from child to parent",
        "pattern": "Child error -> Wrap in error message -> Send to parent -> Parent handles",
        "use_when": ["Critical failures", "Error recovery needed", "Logging requirements"]
      },
      "retry_strategies": {
        "description": "Retry failed subagent tasks",
        "strategies": [
          "Exponential backoff",
          "Max retry attempts",
          "Conditional retry based on error type"
        ],
        "use_when": ["Transient failures", "Network issues", "Temporary errors"]
      },
      "timeout_handling": {
        "description": "Handle subagent timeouts",
        "pattern": "Set timeout -> Monitor execution -> Cancel on timeout -> Report",
        "best_practices": [
          "Set reasonable timeouts",
          "Cancel long-running tasks",
          "Report timeout to parent"
        ]
      }
    },
    "orchestration_patterns": {
      "task_decomposition": {
        "description": "Break complex tasks into subtasks for subagents",
        "pattern": "Analyze task -> Identify subtasks -> Assign to subagents -> Execute",
        "use_when": ["Complex tasks", "Multi-step workflows", "Parallelizable work"]
      },
      "dependency_management": {
        "description": "Handle dependencies between subtasks",
        "pattern": "Build dependency graph -> Execute in order -> Wait for dependencies",
        "use_when": ["Sequential dependencies", "Data pipelines", "Ordered execution"]
      },
      "concurrent_execution": {
        "description": "Execute multiple subagents concurrently",
        "pattern": "Use asyncio.gather() for parallel execution",
        "example": "results = await asyncio.gather(*[agent.execute_task(t) for agent, t in tasks])",
        "use_when": ["Independent tasks", "Parallel processing", "Performance optimization"]
      },
      "sequential_pipeline": {
        "description": "Chain subagents in sequence",
        "pattern": "Agent1 -> Agent2 -> Agent3 (passing results)",
        "use_when": ["Dependent tasks", "Processing pipelines", "Sequential workflows"]
      }
    }
  },
  "best_practices": [
    "Always clean up subagents when done",
    "Use context managers for automatic cleanup",
    "Track resource usage and limit concurrent subagents",
    "Implement proper error handling for subagent failures",
    "Use result aggregation for combining outputs",
    "Monitor subagent status and health",
    "Set timeouts for subagent operations",
    "Use pools for high-throughput scenarios",
    "Implement graceful shutdown procedures",
    "Log subagent activities for debugging",
    "Set limits on spawned agents",
    "Handle subagent failures gracefully",
    "Use async/await for concurrent operations",
    "Track task IDs for correlation",
    "Implement retry strategies for transient failures"
  ],
  "anti_patterns": [
    {
      "name": "Not cleaning up subagents",
      "problem": "Memory leaks and resource exhaustion",
      "fix": "Use context managers or explicit cleanup"
    },
    {
      "name": "Spawning unlimited subagents",
      "problem": "Resource exhaustion and performance degradation",
      "fix": "Set limits and use pools"
    },
    {
      "name": "No error handling",
      "problem": "Subagent failures break parent agent",
      "fix": "Wrap subagent calls in try/except"
    },
    {
      "name": "Blocking on subagents",
      "problem": "Poor performance and scalability",
      "fix": "Use async/await and concurrent execution"
    },
    {
      "name": "No resource tracking",
      "problem": "Can't monitor or debug issues",
      "fix": "Implement resource monitoring"
    },
    {
      "name": "Ignoring subagent failures",
      "problem": "Silent failures and incorrect results",
      "fix": "Handle and propagate errors"
    },
    {
      "name": "No timeout on operations",
      "problem": "Hanging subagents block parent",
      "fix": "Set timeouts for subagent tasks"
    },
    {
      "name": "Memory leaks",
      "problem": "Accumulating state and messages",
      "fix": "Clear agent state on cleanup"
    },
    {
      "name": "No task correlation",
      "problem": "Can't track which result belongs to which task",
      "fix": "Use task IDs and correlation"
    }
  ],
  "related_skills": [
    "subagent-orchestration",
    "langgraph-agent-building",
    "crewai-agents",
    "state-management",
    "tool-usage"
  ]
}
