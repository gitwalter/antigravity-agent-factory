{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "spring-microservices-patterns",
  "name": "Spring Microservices Patterns",
  "title": "Spring Microservices Architecture Patterns",
  "description": "Best practices and patterns for building microservices architectures with Spring Boot and Spring Cloud",
  "version": "1.0.0",
  "category": "patterns",
  "axiomAlignment": {
    "A1_verifiability": "Patterns include health checks, metrics, and distributed tracing for verification",
    "A3_transparency": "All patterns emphasize observability, logging, and distributed tracing"
  },
  "patterns": {
    "service_decomposition": {
      "description": "Breaking down monoliths into microservices",
      "strategies": {
        "business_capability": "Organize services by business function (e.g., Product Service, Order Service, Payment Service)",
        "domain_driven_design": "Use DDD bounded contexts to identify service boundaries",
        "data_ownership": "Each service owns its data - no shared databases",
        "team_structure": "Align service boundaries with team boundaries (Conway's Law)"
      },
      "principles": [
        "Single Responsibility Principle per service",
        "High cohesion within service, low coupling between services",
        "Independent deployment and scaling",
        "Technology diversity allowed per service",
        "API-first design",
        "Fail fast and degrade gracefully"
      ],
      "best_practices": [
        "Start with larger services, split as needed (don't over-microservice)",
        "Identify clear service boundaries using domain modeling",
        "Avoid shared databases - each service has its own",
        "Define clear API contracts with OpenAPI/Swagger",
        "Document service responsibilities and SLAs",
        "Use event-driven communication for loose coupling",
        "Implement idempotency for distributed operations"
      ]
    },
    "api_gateway": {
      "description": "Single entry point for client requests",
      "implementations": {
        "spring_cloud_gateway": {
          "description": "Spring Cloud Gateway - reactive API gateway",
          "features": [
            "Reactive routing",
            "Load balancing",
            "Circuit breaker integration",
            "Rate limiting",
            "Request/response transformation",
            "Health checks"
          ],
          "use_when": "Need reactive, Spring-native gateway",
          "example": "spring.cloud.gateway.routes with predicates and filters"
        },
        "zuul": {
          "description": "Netflix Zuul (legacy, use Gateway instead)",
          "features": [
            "Routing",
            "Filtering",
            "Load balancing"
          ],
          "use_when": "Legacy systems only",
          "deprecated": true
        },
        "kong": {
          "description": "Kong API Gateway",
          "features": [
            "Plugin ecosystem",
            "Rate limiting",
            "Authentication",
            "Analytics"
          ],
          "use_when": "Need advanced gateway features outside Spring ecosystem"
        }
      },
      "patterns": {
        "routing": "Route requests to appropriate backend services using predicates",
        "aggregation": "Combine multiple service responses into single response",
        "transformation": "Transform requests/responses (headers, body)",
        "authentication": "Centralized authentication and authorization",
        "rate_limiting": "Control request rate per client/service",
        "caching": "Cache responses to reduce backend load",
        "circuit_breaker": "Protect against downstream service failures",
        "retry": "Retry failed requests with exponential backoff"
      },
      "best_practices": [
        "Use Spring Cloud Gateway for Spring Boot applications",
        "Implement health checks for routing decisions",
        "Add correlation IDs for request tracing",
        "Implement request/response logging",
        "Use circuit breaker for downstream services",
        "Cache static responses",
        "Implement rate limiting per client",
        "Use load balancing for service instances"
      ]
    },
    "service_discovery": {
      "description": "Dynamic service location and registration",
      "implementations": {
        "eureka": {
          "description": "Netflix Eureka - service registry",
          "features": [
            "Service registration",
            "Service discovery",
            "Health checks",
            "Load balancing"
          ],
          "use_when": "Spring Cloud Netflix ecosystem",
          "configuration": "eureka.client.service-url.defaultZone"
        },
        "consul": {
          "description": "HashiCorp Consul - service mesh and discovery",
          "features": [
            "Service discovery",
            "Health checking",
            "Key-value store",
            "Multi-datacenter"
          ],
          "use_when": "Need service mesh features or multi-datacenter",
          "configuration": "spring.cloud.consul.host"
        },
        "kubernetes": {
          "description": "Kubernetes native service discovery",
          "features": [
            "DNS-based discovery",
            "Service labels",
            "Native K8s integration"
          ],
          "use_when": "Deploying to Kubernetes",
          "configuration": "Use K8s Service objects"
        },
        "zookeeper": {
          "description": "Apache Zookeeper for service discovery",
          "features": [
            "Distributed coordination",
            "Service registration"
          ],
          "use_when": "Existing Zookeeper infrastructure"
        }
      },
      "patterns": {
        "client_side_discovery": "Client queries service registry to find service instances",
        "server_side_discovery": "Load balancer queries registry and routes requests",
        "self_registration": "Service registers itself with registry",
        "third_party_registration": "Service registrar handles registration"
      },
      "best_practices": [
        "Use Eureka for Spring Cloud applications",
        "Implement health checks for service status",
        "Configure proper lease renewal intervals",
        "Use service names instead of hardcoded URLs",
        "Implement retry logic for service discovery",
        "Monitor service registry health",
        "Use Kubernetes Service discovery when on K8s"
      ]
    },
    "config_management": {
      "description": "Centralized configuration management",
      "implementations": {
        "spring_cloud_config": {
          "description": "Spring Cloud Config Server",
          "features": [
            "Centralized config",
            "Version control integration",
            "Environment-specific configs",
            "Refresh mechanism"
          ],
          "use_when": "Need centralized configuration",
          "configuration": "spring.cloud.config.uri"
        },
        "kubernetes_configmap": {
          "description": "Kubernetes ConfigMaps",
          "features": [
            "K8s native",
            "Environment variables",
            "Volume mounts"
          ],
          "use_when": "Deploying to Kubernetes",
          "configuration": "configMapRef in deployment"
        },
        "vault": {
          "description": "HashiCorp Vault for secrets",
          "features": [
            "Secret management",
            "Dynamic secrets",
            "Encryption"
          ],
          "use_when": "Need advanced secret management",
          "configuration": "spring.cloud.vault.*"
        }
      },
      "patterns": {
        "centralized_config": "Single source of truth for configuration",
        "environment_specific": "Different configs per environment (dev, prod)",
        "refresh_mechanism": "@RefreshScope for dynamic config updates",
        "secret_management": "Secure storage of sensitive configuration",
        "version_control": "Config stored in Git repository"
      },
      "best_practices": [
        "Use Spring Cloud Config for centralized config",
        "Store config in version control (Git)",
        "Use @RefreshScope for dynamic updates",
        "Separate secrets from regular config",
        "Use environment-specific profiles",
        "Implement config encryption for sensitive data",
        "Monitor config server health",
        "Use Kubernetes ConfigMaps when on K8s"
      ]
    },
    "circuit_breaker": {
      "description": "Prevent cascading failures",
      "implementations": {
        "resilience4j": {
          "description": "Resilience4j - lightweight fault tolerance library",
          "features": [
            "Circuit breaker",
            "Retry",
            "Rate limiter",
            "Bulkhead",
            "Time limiter"
          ],
          "use_when": "Spring Boot 3+ applications",
          "configuration": "resilience4j.circuitbreaker.instances.*"
        },
        "spring_cloud_circuit_breaker": {
          "description": "Spring Cloud Circuit Breaker abstraction",
          "features": [
            "Multiple implementations",
            "Spring integration"
          ],
          "use_when": "Need abstraction over implementations",
          "providers": [
            "Resilience4j",
            "Sentinel"
          ]
        },
        "hystrix": {
          "description": "Netflix Hystrix (deprecated)",
          "deprecated": true,
          "replacement": "Resilience4j"
        }
      },
      "patterns": {
        "circuit_breaker": "Open circuit when failure threshold reached",
        "fallback": "Return default response when circuit is open",
        "retry": "Retry failed requests with exponential backoff",
        "timeout": "Fail fast when service doesn't respond",
        "bulkhead": "Isolate resources to prevent resource exhaustion"
      },
      "states": {
        "closed": "Normal operation, requests pass through",
        "open": "Circuit open, requests fail fast",
        "half_open": "Testing if service recovered, limited requests allowed"
      },
      "best_practices": [
        "Use Resilience4j for Spring Boot 3+",
        "Configure appropriate failure thresholds",
        "Implement fallback mechanisms",
        "Monitor circuit breaker metrics",
        "Use retry with circuit breaker",
        "Set proper timeout values",
        "Implement bulkhead pattern for resource isolation",
        "Log circuit state changes"
      ]
    },
    "distributed_tracing": {
      "description": "Track requests across service boundaries",
      "implementations": {
        "micrometer_tracing": {
          "description": "Micrometer Tracing - Spring-native tracing",
          "features": [
            "Multiple tracer support",
            "Spring integration",
            "Automatic instrumentation"
          ],
          "use_when": "Spring Boot 3+ applications",
          "configuration": "management.tracing.*"
        },
        "zipkin": {
          "description": "Zipkin distributed tracing system",
          "features": [
            "Request tracing",
            "Dependency graph",
            "Timing analysis"
          ],
          "use_when": "Need distributed tracing visualization",
          "configuration": "management.zipkin.tracing.endpoint"
        },
        "jaeger": {
          "description": "Jaeger distributed tracing",
          "features": [
            "High performance",
            "OpenTelemetry support",
            "UI"
          ],
          "use_when": "Need high-performance tracing",
          "configuration": "management.tracing.export.jaeger.*"
        },
        "opentelemetry": {
          "description": "OpenTelemetry standard",
          "features": [
            "Vendor-neutral",
            "Multiple languages",
            "Standard APIs"
          ],
          "use_when": "Multi-language microservices",
          "configuration": "OpenTelemetry SDK"
        }
      },
      "patterns": {
        "trace": "Complete request path across services",
        "span": "Individual operation within a trace",
        "correlation_id": "Unique ID propagated across services",
        "baggage": "Context data propagated with trace",
        "sampling": "Reduce trace volume in high-throughput systems"
      },
      "best_practices": [
        "Use Micrometer Tracing with Spring Boot",
        "Propagate trace context across service calls",
        "Add custom spans for business operations",
        "Use correlation IDs in logs",
        "Configure appropriate sampling rates",
        "Monitor trace volume and performance",
        "Use Zipkin or Jaeger for visualization",
        "Add trace context to error messages"
      ]
    },
    "event_driven_architecture": {
      "description": "Loose coupling through events",
      "implementations": {
        "spring_cloud_stream": {
          "description": "Spring Cloud Stream - event-driven microservices",
          "features": [
            "Multiple binder support",
            "Declarative programming",
            "Consumer groups"
          ],
          "use_when": "Need event-driven communication",
          "binders": [
            "Kafka",
            "RabbitMQ",
            "Amazon Kinesis",
            "Google Pub/Sub"
          ]
        },
        "apache_kafka": {
          "description": "Apache Kafka - distributed event streaming",
          "features": [
            "High throughput",
            "Fault tolerance",
            "Replay capability",
            "Partitioning"
          ],
          "use_when": "Need high-throughput event streaming",
          "configuration": "spring.kafka.*"
        },
        "rabbitmq": {
          "description": "RabbitMQ message broker",
          "features": [
            "Multiple exchange types",
            "Routing",
            "Reliability"
          ],
          "use_when": "Need flexible routing patterns",
          "configuration": "spring.rabbitmq.*"
        }
      },
      "patterns": {
        "event_sourcing": "Store state as sequence of events",
        "cqr": "Separate read and write models",
        "saga": "Distributed transaction pattern using events",
        "publish_subscribe": "One-to-many event distribution",
        "event_replay": "Replay events to rebuild state",
        "idempotency": "Handle duplicate events safely"
      },
      "best_practices": [
        "Use Spring Cloud Stream for abstraction",
        "Use Kafka for high-throughput scenarios",
        "Implement idempotent event handlers",
        "Use consumer groups for load balancing",
        "Implement event versioning",
        "Handle event ordering when needed",
        "Monitor event processing lag",
        "Implement dead letter queues for failed events",
        "Use schema registry for event schemas"
      ]
    },
    "saga_pattern": {
      "description": "Manage distributed transactions",
      "implementations": {
        "orchestration": {
          "description": "Central orchestrator coordinates saga",
          "use_when": "Complex workflows, need centralized control",
          "example": "Saga orchestrator service coordinates all steps"
        },
        "choreography": {
          "description": "Services coordinate through events",
          "use_when": "Simple workflows, prefer loose coupling",
          "example": "Each service publishes events, others react"
        }
      },
      "patterns": {
        "compensating_transaction": "Undo previous operations on failure",
        "saga_step": "Individual operation in saga",
        "saga_coordinator": "Orchestrates saga execution",
        "compensation": "Rollback operation for each step"
      },
      "best_practices": [
        "Use orchestration for complex workflows",
        "Use choreography for simple workflows",
        "Implement idempotent compensation",
        "Log all saga steps for debugging",
        "Handle partial failures gracefully",
        "Set timeouts for saga steps",
        "Monitor saga completion rates"
      ]
    },
    "cqrs": {
      "description": "Command Query Responsibility Segregation",
      "patterns": {
        "command_side": "Write operations, optimized for writes",
        "query_side": "Read operations, optimized for reads",
        "event_store": "Store events for command side",
        "read_model": "Denormalized views for query side",
        "eventual_consistency": "Read model eventually syncs with write model"
      },
      "use_cases": [
        "High read/write ratio",
        "Different read and write requirements",
        "Need to scale reads independently",
        "Complex query requirements"
      ],
      "best_practices": [
        "Use CQRS when read/write patterns differ significantly",
        "Keep command and query models separate",
        "Use events to sync read models",
        "Accept eventual consistency",
        "Monitor read model lag",
        "Implement read model rebuild capability"
      ]
    },
    "api_versioning": {
      "description": "Manage API changes over time",
      "strategies": {
        "url_versioning": "Version in URL path (/api/v1/products)",
        "header_versioning": "Version in HTTP header (Accept: application/vnd.api.v1+json)",
        "query_parameter": "Version as query parameter (?version=1)",
        "content_negotiation": "Version via Accept header"
      },
      "best_practices": [
        "Use URL versioning for REST APIs",
        "Maintain backward compatibility when possible",
        "Deprecate old versions gradually",
        "Document versioning strategy",
        "Monitor version usage",
        "Plan version lifecycle"
      ]
    },
    "distributed_caching": {
      "description": "Cache data across service instances",
      "implementations": {
        "redis": {
          "description": "Redis distributed cache",
          "features": [
            "In-memory",
            "Pub/sub",
            "Data structures"
          ],
          "use_when": "Need distributed cache",
          "configuration": "spring.data.redis.*"
        },
        "hazelcast": {
          "description": "Hazelcast in-memory data grid",
          "features": [
            "Distributed",
            "In-memory",
            "Compute"
          ],
          "use_when": "Need in-memory data grid"
        },
        "caffeine": {
          "description": "Caffeine local cache",
          "features": [
            "High performance",
            "Local only"
          ],
          "use_when": "Single instance caching"
        }
      },
      "patterns": {
        "cache_aside": "Application manages cache",
        "write_through": "Write to cache and database",
        "write_behind": "Write to cache, async to database",
        "cache_invalidation": "Invalidate cache on updates"
      },
      "best_practices": [
        "Use Redis for distributed caching",
        "Implement cache invalidation strategy",
        "Set appropriate TTL values",
        "Monitor cache hit rates",
        "Use cache keys with service prefix",
        "Handle cache failures gracefully",
        "Consider cache warming on startup"
      ]
    },
    "service_mesh": {
      "description": "Infrastructure layer for service communication",
      "implementations": {
        "istio": {
          "description": "Istio service mesh",
          "features": [
            "Traffic management",
            "Security",
            "Observability"
          ],
          "use_when": "Kubernetes deployment, need advanced features"
        },
        "linkerd": {
          "description": "Linkerd service mesh",
          "features": [
            "Lightweight",
            "Easy setup",
            "Performance"
          ],
          "use_when": "Need simple, lightweight mesh"
        }
      },
      "benefits": [
        "Traffic management without code changes",
        "Automatic mTLS",
        "Observability out of the box",
        "Policy enforcement"
      ],
      "best_practices": [
        "Consider service mesh for complex deployments",
        "Use Istio for Kubernetes",
        "Start with basic features",
        "Monitor mesh performance",
        "Use for cross-cutting concerns"
      ]
    }
  },
  "best_practices": [],
  "anti_patterns": []
}