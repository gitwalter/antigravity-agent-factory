{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "id": "blazor-patterns",
  "name": "Blazor Patterns",
  "title": "Blazor Development Patterns",
  "description": "Best practices and patterns for building Blazor Server, WebAssembly, and Auto applications",
  "version": "1.0.0",
  "category": "patterns",
  "axiomAlignment": {
    "A1_verifiability": "Patterns include testing strategies for component verification",
    "A3_transparency": "All patterns emphasize clear component structure and state management"
  },
  "patterns": {
    "render_modes": {
      "server": {
        "description": "Server-side rendering with SignalR connection",
        "use_when": [
          "Real-time updates needed",
          "Small client footprint",
          "Fast initial load"
        ],
        "characteristics": {
          "latency": "Network latency affects UI responsiveness",
          "scalability": "Limited by server connections",
          "offline": "Requires constant connection"
        },
        "best_practices": [
          "Optimize SignalR message size",
          "Use circuit reconnection handling",
          "Implement proper state management",
          "Handle connection state changes"
        ]
      },
      "webassembly": {
        "description": "Client-side rendering, runs in browser",
        "use_when": [
          "Offline capability needed",
          "Rich client-side interactions",
          "Reduced server load"
        ],
        "characteristics": {
          "latency": "No network latency for UI",
          "scalability": "Scales with client devices",
          "offline": "Can work offline with caching"
        },
        "best_practices": [
          "Optimize initial download size",
          "Use lazy loading for assemblies",
          "Implement proper caching",
          "Handle offline scenarios"
        ]
      },
      "auto": {
        "description": "Server first, then WebAssembly (.NET 8+)",
        "use_when": [
          "Best of both worlds",
          "Progressive enhancement"
        ],
        "characteristics": {
          "initial_load": "Fast server-side initial load",
          "interactivity": "Switches to WebAssembly for interactivity",
          "best_experience": "Combines benefits of both modes"
        },
        "best_practices": [
          "Use for new applications",
          "Leverage server-side rendering initially",
          "Transition to WebAssembly smoothly"
        ]
      },
      "ssr": {
        "description": "Static Server-Side Rendering",
        "use_when": [
          "SEO important",
          "Static content",
          "No interactivity needed"
        ],
        "characteristics": {
          "performance": "Fast initial render",
          "seo": "Fully crawlable",
          "interactivity": "No client-side interactivity"
        }
      }
    },
    "component_patterns": {
      "component_structure": {
        "description": "Organize components effectively",
        "structure": {
          "presentation": "UI-only components",
          "container": "Components with business logic",
          "layout": "Page layout components",
          "shared": "Reusable components"
        },
        "best_practices": [
          "Separate presentation from logic",
          "Use component parameters for data flow",
          "Implement component composition",
          "Create reusable component libraries"
        ]
      },
      "component_lifecycle": {
        "description": "Understand and use component lifecycle methods",
        "methods": {
          "OnInitialized": "Synchronous initialization",
          "OnInitializedAsync": "Async initialization (preferred)",
          "OnParametersSet": "Parameter changes",
          "OnParametersSetAsync": "Async parameter handling",
          "OnAfterRender": "After render completion",
          "OnAfterRenderAsync": "Async post-render operations"
        },
        "best_practices": [
          "Use async lifecycle methods for data loading",
          "Call StateHasChanged() when needed",
          "Implement IAsyncDisposable for cleanup",
          "Avoid blocking calls in lifecycle methods"
        ]
      },
      "parameter_patterns": {
        "description": "Pass data to components",
        "types": {
          "simple": "Primitive types (string, int, etc.)",
          "complex": "Objects and models",
          "event_callbacks": "Parent-child communication",
          "cascading": "Multi-level component communication"
        },
        "best_practices": [
          "Use [Parameter] attribute",
          "Use EventCallback for events",
          "Use CascadingValue for context sharing",
          "Validate parameters"
        ]
      },
      "component_communication": {
        "description": "Communicate between components",
        "patterns": {
          "parent_to_child": "Parameters",
          "child_to_parent": "EventCallback",
          "sibling": "Shared service or state container",
          "cascading": "CascadingValue and CascadingParameter"
        },
        "best_practices": [
          "Use parameters for parent-to-child",
          "Use EventCallback for child-to-parent",
          "Use state container for complex state",
          "Avoid prop drilling with cascading values"
        ]
      }
    },
    "state_management": {
      "in_memory": {
        "description": "Component-level state",
        "use_when": "Simple, component-specific state",
        "implementation": "Private fields in component",
        "limitations": "Lost on navigation or refresh"
      },
      "cascading_values": {
        "description": "Share state across component tree",
        "use_when": "Theme, user context, settings",
        "implementation": "CascadingValue component",
        "best_practices": [
          "Use for read-only shared state",
          "Avoid deep cascading hierarchies",
          "Use named cascading values when needed"
        ]
      },
      "state_container": {
        "description": "Centralized state management service",
        "use_when": "Complex application state",
        "implementation": "Singleton service with events",
        "best_practices": [
          "Use events to notify components",
          "Call StateHasChanged() in event handlers",
          "Implement proper state immutability"
        ]
      },
      "fluxor": {
        "description": "Redux-like state management library",
        "use_when": "Complex state with actions and reducers",
        "features": [
          "Actions",
          "Reducers",
          "Effects",
          "Middleware"
        ],
        "best_practices": [
          "Define clear action types",
          "Keep reducers pure",
          "Use effects for side effects",
          "Implement proper state immutability"
        ]
      },
      "persistent_storage": {
        "description": "Persist state across sessions",
        "options": [
          "LocalStorage",
          "SessionStorage",
          "IndexedDB",
          "Server-side storage"
        ],
        "best_practices": [
          "Use LocalStorage for user preferences",
          "Use SessionStorage for temporary data",
          "Serialize/deserialize properly",
          "Handle storage quota errors"
        ]
      }
    },
    "javascript_interop": {
      "description": "Call JavaScript from C# and vice versa",
      "patterns": {
        "csharp_to_javascript": {
          "description": "Call JavaScript functions from C#",
          "implementation": "IJSRuntime.InvokeAsync",
          "use_cases": [
            "DOM manipulation",
            "Third-party libraries",
            "Browser APIs"
          ],
          "best_practices": [
            "Use IJSObjectReference for modules",
            "Dispose JS object references",
            "Handle JavaScript errors",
            "Minimize interop calls"
          ]
        },
        "javascript_to_csharp": {
          "description": "Call C# methods from JavaScript",
          "implementation": "DotNet.invokeMethodAsync",
          "use_cases": [
            "Event handlers",
            "Callbacks",
            "Third-party integrations"
          ],
          "best_practices": [
            "Use [JSInvokable] attribute",
            "Handle async operations properly",
            "Pass serializable data"
          ]
        },
        "js_modules": {
          "description": "Import JavaScript modules",
          "implementation": "IJSObjectReference",
          "benefits": [
            "Better performance",
            "Module isolation",
            "Reusability"
          ],
          "best_practices": [
            "Import modules in OnAfterRenderAsync",
            "Dispose modules properly",
            "Use async/await"
          ]
        }
      }
    },
    "forms_and_validation": {
      "editform": {
        "description": "Blazor's form component",
        "features": [
          "Two-way binding",
          "Validation",
          "Model binding"
        ],
        "best_practices": [
          "Use EditForm with Model",
          "Add DataAnnotationsValidator",
          "Use ValidationMessage components",
          "Handle OnValidSubmit"
        ]
      },
      "input_components": {
        "description": "Built-in input components",
        "components": [
          "InputText",
          "InputNumber",
          "InputDate",
          "InputCheckbox",
          "InputSelect",
          "InputTextArea"
        ],
        "best_practices": [
          "Use appropriate input type",
          "Add validation attributes",
          "Use ValidationMessage for errors"
        ]
      },
      "validation": {
        "description": "Validate form input",
        "methods": {
          "data_annotations": "Built-in validation attributes",
          "fluent_validation": "FluentValidation library",
          "custom_validators": "Custom validation logic"
        },
        "best_practices": [
          "Use DataAnnotations for simple validation",
          "Use FluentValidation for complex rules",
          "Show validation errors clearly",
          "Validate on submit and blur"
        ]
      }
    },
    "authentication": {
      "aspnet_identity": {
        "description": "ASP.NET Core Identity integration",
        "features": [
          "User management",
          "Roles",
          "Claims",
          "Two-factor authentication"
        ],
        "best_practices": [
          "Use AuthorizeView component",
          "Check authentication state",
          "Implement role-based authorization",
          "Handle authentication state changes"
        ]
      },
      "authorization": {
        "description": "Control access to components and pages",
        "attributes": [
          "[Authorize]",
          "[Authorize(Roles = \"Admin\")]"
        ],
        "components": [
          "AuthorizeView",
          "CascadingAuthenticationState"
        ],
        "best_practices": [
          "Use AuthorizeView for conditional rendering",
          "Use [Authorize] attribute for pages",
          "Implement policy-based authorization",
          "Handle unauthorized access gracefully"
        ]
      }
    },
    "performance": {
      "optimization_techniques": {
        "virtualization": {
          "description": "Render only visible items",
          "implementation": "Virtualize component",
          "use_when": "Large lists or tables",
          "benefits": [
            "Reduced DOM elements",
            "Better performance",
            "Lower memory usage"
          ]
        },
        "lazy_loading": {
          "description": "Load components on demand",
          "implementation": "Lazy loading with Router",
          "use_when": "Large applications with many pages",
          "benefits": [
            "Smaller initial bundle",
            "Faster initial load"
          ]
        },
        "prerendering": {
          "description": "Render components on server first",
          "implementation": "Server-side rendering",
          "use_when": "SEO important or fast initial load",
          "benefits": [
            "Better SEO",
            "Faster perceived load time"
          ]
        },
        "key_directive": {
          "description": "Help Blazor track components in lists",
          "implementation": "@key directive",
          "use_when": "Rendering lists of components",
          "benefits": [
            "Better diffing",
            "Preserved component state"
          ]
        }
      },
      "best_practices": [
        "Use @key in loops for better performance",
        "Implement virtualization for large lists",
        "Use lazy loading for large applications",
        "Minimize JavaScript interop calls",
        "Use ShouldRender() to prevent unnecessary renders",
        "Optimize SignalR message size (Server mode)",
        "Use compiled bindings for better performance"
      ]
    },
    "signalr_integration": {
      "description": "Real-time communication with SignalR (Blazor Server)",
      "patterns": {
        "hub_connection": {
          "description": "Connect to SignalR hub",
          "implementation": "HubConnectionBuilder",
          "use_cases": [
            "Real-time updates",
            "Notifications",
            "Chat applications"
          ]
        },
        "hub_methods": {
          "description": "Send and receive messages",
          "implementation": "HubConnection.On and SendAsync",
          "best_practices": [
            "Handle connection state",
            "Implement reconnection logic",
            "Dispose connections properly",
            "Handle errors gracefully"
          ]
        }
      }
    },
    "testing": {
      "unit_testing": {
        "description": "Test components in isolation",
        "tools": [
          "bUnit",
          "xUnit",
          "Moq"
        ],
        "best_practices": [
          "Test component rendering",
          "Test parameter binding",
          "Test event callbacks",
          "Mock dependencies"
        ]
      },
      "integration_testing": {
        "description": "Test component interactions",
        "tools": [
          "Playwright",
          "Selenium",
          "bUnit"
        ],
        "best_practices": [
          "Test user interactions",
          "Test form submission",
          "Test navigation",
          "Test authentication flows"
        ]
      }
    }
  },
  "best_practices": [
    "Use async lifecycle methods (OnInitializedAsync) for data loading",
    "Implement IAsyncDisposable for proper cleanup",
    "Use @key directive in loops for better performance",
    "Minimize JavaScript interop calls",
    "Use StateHasChanged() sparingly and appropriately",
    "Implement proper error boundaries",
    "Use cascading values for theme/context sharing",
    "Validate user input with DataAnnotations or FluentValidation",
    "Use AuthorizeView for conditional rendering based on auth",
    "Implement proper loading states",
    "Handle connection state in Blazor Server",
    "Use virtualization for large lists",
    "Optimize bundle size with lazy loading",
    "Use compiled bindings for better performance",
    "Implement proper state management patterns"
  ],
  "anti_patterns": []
}